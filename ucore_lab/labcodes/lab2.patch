Binary files lab2_origin/bin/bootblock and lab2/bin/bootblock differ
Binary files lab2_origin/bin/kernel and lab2/bin/kernel differ
Binary files lab2_origin/bin/kernel_nopage and lab2/bin/kernel_nopage differ
Binary files lab2_origin/bin/sign and lab2/bin/sign differ
Binary files lab2_origin/bin/ucore.img and lab2/bin/ucore.img differ
diff -r -u -P lab2_origin/boot/asm.h lab2/boot/asm.h
--- lab2_origin/boot/asm.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/boot/asm.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,26 @@
+#ifndef __BOOT_ASM_H__
+#define __BOOT_ASM_H__
+
+/* Assembler macros to create x86 segments */
+
+/* Normal segment */
+#define SEG_NULLASM                                             \
+    .word 0, 0;                                                 \
+    .byte 0, 0, 0, 0
+
+#define SEG_ASM(type,base,lim)                                  \
+    .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);          \
+    .byte (((base) >> 16) & 0xff), (0x90 | (type)),             \
+        (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+
+
+/* Application segment type bits */
+#define STA_X       0x8     // Executable segment
+#define STA_E       0x4     // Expand down (non-executable segments)
+#define STA_C       0x4     // Conforming code segment (executable only)
+#define STA_W       0x2     // Writeable (non-executable segments)
+#define STA_R       0x2     // Readable (executable segments)
+#define STA_A       0x1     // Accessed
+
+#endif /* !__BOOT_ASM_H__ */
+
diff -r -u -P lab2_origin/boot/bootasm.S lab2/boot/bootasm.S
--- lab2_origin/boot/bootasm.S	1970-01-01 08:00:00.000000000 +0800
+++ lab2/boot/bootasm.S	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,107 @@
+#include <asm.h>
+
+# Start the CPU: switch to 32-bit protected mode, jump into C.
+# The BIOS loads this code from the first sector of the hard disk into
+# memory at physical address 0x7c00 and starts executing in real mode
+# with %cs=0 %ip=7c00.
+
+.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
+.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
+.set CR0_PE_ON,             0x1                     # protected mode enable flag
+.set SMAP,                  0x534d4150
+
+# start address should be 0:7c00, in real mode, the beginning address of the running bootloader
+.globl start
+start:
+.code16                                             # Assemble for 16-bit mode
+    cli                                             # Disable interrupts
+    cld                                             # String operations increment
+
+    # Set up the important data segment registers (DS, ES, SS).
+    xorw %ax, %ax                                   # Segment number zero
+    movw %ax, %ds                                   # -> Data Segment
+    movw %ax, %es                                   # -> Extra Segment
+    movw %ax, %ss                                   # -> Stack Segment
+
+    # Enable A20:
+    #  For backwards compatibility with the earliest PCs, physical
+    #  address line 20 is tied low, so that addresses higher than
+    #  1MB wrap around to zero by default. This code undoes this.
+seta20.1:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    testb $0x2, %al
+    jnz seta20.1
+
+    movb $0xd1, %al                                 # 0xd1 -> port 0x64
+    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
+
+seta20.2:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    testb $0x2, %al
+    jnz seta20.2
+
+    movb $0xdf, %al                                 # 0xdf -> port 0x60
+    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
+
+probe_memory:
+    movl $0, 0x8000
+    xorl %ebx, %ebx
+    movw $0x8004, %di
+start_probe:
+    movl $0xE820, %eax
+    movl $20, %ecx
+    movl $SMAP, %edx
+    int $0x15
+    jnc cont
+    movw $12345, 0x8000
+    jmp finish_probe
+cont:
+    addw $20, %di
+    incl 0x8000
+    cmpl $0, %ebx
+    jnz start_probe
+finish_probe:
+
+    # Switch from real to protected mode, using a bootstrap GDT
+    # and segment translation that makes virtual addresses
+    # identical to physical addresses, so that the
+    # effective memory map does not change during the switch.
+    lgdt gdtdesc
+    movl %cr0, %eax
+    orl $CR0_PE_ON, %eax
+    movl %eax, %cr0
+
+    # Jump to next instruction, but in 32-bit code segment.
+    # Switches processor into 32-bit mode.
+    ljmp $PROT_MODE_CSEG, $protcseg
+
+.code32                                             # Assemble for 32-bit mode
+protcseg:
+    # Set up the protected-mode data segment registers
+    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
+    movw %ax, %ds                                   # -> DS: Data Segment
+    movw %ax, %es                                   # -> ES: Extra Segment
+    movw %ax, %fs                                   # -> FS
+    movw %ax, %gs                                   # -> GS
+    movw %ax, %ss                                   # -> SS: Stack Segment
+
+    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
+    movl $0x0, %ebp
+    movl $start, %esp
+    call bootmain
+
+    # If bootmain returns (it shouldn't), loop.
+spin:
+    jmp spin
+
+.data
+# Bootstrap GDT
+.p2align 2                                          # force 4 byte alignment
+gdt:
+    SEG_NULLASM                                     # null seg
+    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
+    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
+
+gdtdesc:
+    .word 0x17                                      # sizeof(gdt) - 1
+    .long gdt                                       # address gdt
diff -r -u -P lab2_origin/boot/bootmain.c lab2/boot/bootmain.c
--- lab2_origin/boot/bootmain.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/boot/bootmain.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,116 @@
+#include <defs.h>
+#include <x86.h>
+#include <elf.h>
+
+/* *********************************************************************
+ * This a dirt simple boot loader, whose sole job is to boot
+ * an ELF kernel image from the first IDE hard disk.
+ *
+ * DISK LAYOUT
+ *  * This program(bootasm.S and bootmain.c) is the bootloader.
+ *    It should be stored in the first sector of the disk.
+ *
+ *  * The 2nd sector onward holds the kernel image.
+ *
+ *  * The kernel image must be in ELF format.
+ *
+ * BOOT UP STEPS
+ *  * when the CPU boots it loads the BIOS into memory and executes it
+ *
+ *  * the BIOS intializes devices, sets of the interrupt routines, and
+ *    reads the first sector of the boot device(e.g., hard-drive)
+ *    into memory and jumps to it.
+ *
+ *  * Assuming this boot loader is stored in the first sector of the
+ *    hard-drive, this code takes over...
+ *
+ *  * control starts in bootasm.S -- which sets up protected mode,
+ *    and a stack so C code then run, then calls bootmain()
+ *
+ *  * bootmain() in this file takes over, reads in the kernel and jumps to it.
+ * */
+
+#define SECTSIZE        512
+#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space
+
+/* waitdisk - wait for disk ready */
+static void
+waitdisk(void) {
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+        /* do nothing */;
+}
+
+/* readsect - read a single sector at @secno into @dst */
+static void
+readsect(void *dst, uint32_t secno) {
+    // wait for disk to be ready
+    waitdisk();
+
+    outb(0x1F2, 1);                         // count = 1
+    outb(0x1F3, secno & 0xFF);
+    outb(0x1F4, (secno >> 8) & 0xFF);
+    outb(0x1F5, (secno >> 16) & 0xFF);
+    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
+    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors
+
+    // wait for disk to be ready
+    waitdisk();
+
+    // read a sector
+    insl(0x1F0, dst, SECTSIZE / 4);
+}
+
+/* *
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    uintptr_t end_va = va + count;
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+        readsect((void *)va, secno);
+    }
+}
+
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    // read the 1st page off disk
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+
+    // is this a valid ELF?
+    if (ELFHDR->e_magic != ELF_MAGIC) {
+        goto bad;
+    }
+
+    struct proghdr *ph, *eph;
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    eph = ph + ELFHDR->e_phnum;
+    for (; ph < eph; ph ++) {
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    }
+
+    // call the entry point from the ELF header
+    // note: does not return
+    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
+
+bad:
+    outw(0x8A00, 0x8A00);
+    outw(0x8A00, 0x8E00);
+
+    /* do nothing */
+    while (1);
+}
+
diff -r -u -P lab2_origin/.gdb.in lab2/.gdb.in
--- lab2_origin/.gdb.in	1970-01-01 08:00:00.000000000 +0800
+++ lab2/.gdb.in	2021-08-29 21:35:39.894604841 +0800
@@ -0,0 +1,3 @@
+target remote localhost:1234
+break *0xc0100233
+continue
diff -r -u -P lab2_origin/kern/debug/assert.h lab2/kern/debug/assert.h
--- lab2_origin/kern/debug/assert.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/debug/assert.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,27 @@
+#ifndef __KERN_DEBUG_ASSERT_H__
+#define __KERN_DEBUG_ASSERT_H__
+
+#include <defs.h>
+
+void __warn(const char *file, int line, const char *fmt, ...);
+void __noreturn __panic(const char *file, int line, const char *fmt, ...);
+
+#define warn(...)                                       \
+    __warn(__FILE__, __LINE__, __VA_ARGS__)
+
+#define panic(...)                                      \
+    __panic(__FILE__, __LINE__, __VA_ARGS__)
+
+#define assert(x)                                       \
+    do {                                                \
+        if (!(x)) {                                     \
+            panic("assertion failed: %s", #x);          \
+        }                                               \
+    } while (0)
+
+// static_assert(x) will generate a compile-time error if 'x' is false.
+#define static_assert(x)                                \
+    switch (x) { case 0: case (x): ; }
+
+#endif /* !__KERN_DEBUG_ASSERT_H__ */
+
diff -r -u -P lab2_origin/kern/debug/kdebug.c lab2/kern/debug/kdebug.c
--- lab2_origin/kern/debug/kdebug.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/debug/kdebug.c	2021-08-29 19:25:23.639095530 +0800
@@ -0,0 +1,320 @@
+#include <defs.h>
+#include <x86.h>
+#include <stab.h>
+#include <stdio.h>
+#include <string.h>
+#include <kdebug.h>
+
+#define STACKFRAME_DEPTH 20
+
+extern const struct stab __STAB_BEGIN__[];  // beginning of stabs table
+extern const struct stab __STAB_END__[];    // end of stabs table
+extern const char __STABSTR_BEGIN__[];      // beginning of string table
+extern const char __STABSTR_END__[];        // end of string table
+
+/* debug information about a particular instruction pointer */
+struct eipdebuginfo {
+    const char *eip_file;                   // source code filename for eip
+    int eip_line;                           // source code line number for eip
+    const char *eip_fn_name;                // name of function containing eip
+    int eip_fn_namelen;                     // length of function's name
+    uintptr_t eip_fn_addr;                  // start address of function
+    int eip_fn_narg;                        // number of function arguments
+};
+
+/* *
+ * stab_binsearch - according to the input, the initial value of
+ * range [*@region_left, *@region_right], find a single stab entry
+ * that includes the address @addr and matches the type @type,
+ * and then save its boundary to the locations that pointed
+ * by @region_left and @region_right.
+ *
+ * Some stab types are arranged in increasing order by instruction address.
+ * For example, N_FUN stabs (stab entries with n_type == N_FUN), which
+ * mark functions, and N_SO stabs, which mark source files.
+ *
+ * Given an instruction address, this function finds the single stab entry
+ * of type @type that contains that address.
+ *
+ * The search takes place within the range [*@region_left, *@region_right].
+ * Thus, to search an entire set of N stabs, you might do:
+ *
+ *      left = 0;
+ *      right = N - 1;    (rightmost stab)
+ *      stab_binsearch(stabs, &left, &right, type, addr);
+ *
+ * The search modifies *region_left and *region_right to bracket the @addr.
+ * *@region_left points to the matching stab that contains @addr,
+ * and *@region_right points just before the next stab.
+ * If *@region_left > *region_right, then @addr is not contained in any
+ * matching stab.
+ *
+ * For example, given these N_SO stabs:
+ *      Index  Type   Address
+ *      0      SO     f0100000
+ *      13     SO     f0100040
+ *      117    SO     f0100176
+ *      118    SO     f0100178
+ *      555    SO     f0100652
+ *      556    SO     f0100654
+ *      657    SO     f0100849
+ * this code:
+ *      left = 0, right = 657;
+ *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+ * will exit setting left = 118, right = 554.
+ * */
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+        int true_m = (l + r) / 2, m = true_m;
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+            m --;
+        }
+        if (m < l) {    // no match in [l, m]
+            l = true_m + 1;
+            continue;
+        }
+
+        // actual binary search
+        any_matches = 1;
+        if (stabs[m].n_value < addr) {
+            *region_left = m;
+            l = true_m + 1;
+        } else if (stabs[m].n_value > addr) {
+            *region_right = m - 1;
+            r = m - 1;
+        } else {
+            // exact match for 'addr', but continue loop to find
+            // *region_right
+            *region_left = m;
+            l = m;
+            addr ++;
+        }
+    }
+
+    if (!any_matches) {
+        *region_right = *region_left - 1;
+    }
+    else {
+        // find rightmost region containing 'addr'
+        l = *region_right;
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+            /* do nothing */;
+        *region_left = l;
+    }
+}
+
+/* *
+ * debuginfo_eip - Fill in the @info structure with information about
+ * the specified instruction address, @addr.  Returns 0 if information
+ * was found, and negative if not.  But even if it returns negative it
+ * has stored some information into '*info'.
+ * */
+int
+debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
+    const struct stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+
+    info->eip_file = "<unknown>";
+    info->eip_line = 0;
+    info->eip_fn_name = "<unknown>";
+    info->eip_fn_namelen = 9;
+    info->eip_fn_addr = addr;
+    info->eip_fn_narg = 0;
+
+    stabs = __STAB_BEGIN__;
+    stab_end = __STAB_END__;
+    stabstr = __STABSTR_BEGIN__;
+    stabstr_end = __STABSTR_END__;
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
+        return -1;
+    }
+
+    // Now we find the right stabs that define the function containing
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    int lfile = 0, rfile = (stab_end - stabs) - 1;
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+    if (lfile == 0)
+        return -1;
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    int lfun = lfile, rfun = rfile;
+    int lline, rline;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+
+    if (lfun <= rfun) {
+        // stabs[lfun] points to the function name
+        // in the string table, but check bounds just in case.
+        if (stabs[lfun].n_strx < stabstr_end - stabstr) {
+            info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+        }
+        info->eip_fn_addr = stabs[lfun].n_value;
+        addr -= info->eip_fn_addr;
+        // Search within the function definition for the line number.
+        lline = lfun;
+        rline = rfun;
+    } else {
+        // Couldn't find function stab!  Maybe we're in an assembly
+        // file.  Search the whole file for the line number.
+        info->eip_fn_addr = addr;
+        lline = lfile;
+        rline = rfile;
+    }
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) {
+        info->eip_line = stabs[rline].n_desc;
+    } else {
+        return -1;
+    }
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+           && stabs[lline].n_type != N_SOL
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+        lline --;
+    }
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
+        info->eip_file = stabstr + stabs[lline].n_strx;
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+            info->eip_fn_narg ++;
+        }
+    }
+    return 0;
+}
+
+/* *
+ * print_kerninfo - print the information about kernel, including the location
+ * of kernel entry, the start addresses of data and text segements, the start
+ * address of free memory and how many memory that kernel has used.
+ * */
+void
+print_kerninfo(void) {
+    extern char etext[], edata[], end[], kern_init[];
+    cprintf("Special kernel symbols:\n");
+    cprintf("  entry  0x%08x (phys)\n", kern_init);
+    cprintf("  etext  0x%08x (phys)\n", etext);
+    cprintf("  edata  0x%08x (phys)\n", edata);
+    cprintf("  end    0x%08x (phys)\n", end);
+    cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
+}
+
+/* *
+ * print_debuginfo - read and print the stat information for the address @eip,
+ * and info.eip_fn_addr should be the first address of the related function.
+ * */
+void
+print_debuginfo(uintptr_t eip) {
+    struct eipdebuginfo info;
+    if (debuginfo_eip(eip, &info) != 0) {
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+    }
+    else{ 
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+    }
+}
+
+static __noinline uint32_t
+read_eip(void) {
+    uint32_t eip;
+    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
+    return eip;
+}
+
+/* *
+ * print_stackframe - print a list of the saved eip values from the nested 'call'
+ * instructions that led to the current point of execution
+ *
+ * The x86 stack pointer, namely esp, points to the lowest location on the stack
+ * that is currently in use. Everything below that location in stack is free. Pushing
+ * a value onto the stack will invole decreasing the stack pointer and then writing
+ * the value to the place that stack pointer pointes to. And popping a value do the
+ * opposite.
+ *
+ * The ebp (base pointer) register, in contrast, is associated with the stack
+ * primarily by software convention. On entry to a C function, the function's
+ * prologue code normally saves the previous function's base pointer by pushing
+ * it onto the stack, and then copies the current esp value into ebp for the duration
+ * of the function. If all the functions in a program obey this convention,
+ * then at any given point during the program's execution, it is possible to trace
+ * back through the stack by following the chain of saved ebp pointers and determining
+ * exactly what nested sequence of function calls caused this particular point in the
+ * program to be reached. This capability can be particularly useful, for example,
+ * when a particular function causes an assert failure or panic because bad arguments
+ * were passed to it, but you aren't sure who passed the bad arguments. A stack
+ * backtrace lets you find the offending function.
+ *
+ * The inline function read_ebp() can tell us the value of current ebp. And the
+ * non-inline function read_eip() is useful, it can read the value of current eip,
+ * since while calling this function, read_eip() can read the caller's eip from
+ * stack easily.
+ *
+ * In print_debuginfo(), the function debuginfo_eip() can get enough information about
+ * calling-chain. Finally print_stackframe() will trace and print them for debugging.
+ *
+ * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
+ * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
+ * */
+void
+print_stackframe(void) {
+     /* LAB1 YOUR CODE : STEP 1 */
+     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
+      * (2) call read_eip() to get the value of eip. the type is (uint32_t);
+      * (3) from 0 .. STACKFRAME_DEPTH
+      *    (3.1) printf value of ebp, eip
+      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]
+      *    (3.3) cprintf("\n");
+      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
+      *    (3.5) popup a calling stackframe
+      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+	uint32_t ebp = read_ebp();
+	uint32_t eip = read_eip();
+	int i,j;
+	for(i=0;i<STACKFRAME_DEPTH;i++){
+		cprintf("ebp:0x%08x eip:0x%08x args:",ebp,eip);
+		uint32_t *args = (uint32_t *)ebp +2;
+		for(j=0;j<4;j++){
+			cprintf("0x%08x ",args[j]);
+		}
+		cprintf("\n");
+		print_debuginfo(eip-1);
+		eip = ((uint32_t *)ebp)[1];
+		ebp = ((uint32_t *)ebp)[0];
+	}
+}
+
diff -r -u -P lab2_origin/kern/debug/kdebug.c~ lab2/kern/debug/kdebug.c~
--- lab2_origin/kern/debug/kdebug.c~	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/debug/kdebug.c~	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,309 @@
+#include <defs.h>
+#include <x86.h>
+#include <stab.h>
+#include <stdio.h>
+#include <string.h>
+#include <sync.h>
+#include <kdebug.h>
+#include <kmonitor.h>
+#include <assert.h>
+
+#define STACKFRAME_DEPTH 20
+
+extern const struct stab __STAB_BEGIN__[];  // beginning of stabs table
+extern const struct stab __STAB_END__[];    // end of stabs table
+extern const char __STABSTR_BEGIN__[];      // beginning of string table
+extern const char __STABSTR_END__[];        // end of string table
+
+/* debug information about a particular instruction pointer */
+struct eipdebuginfo {
+    const char *eip_file;                   // source code filename for eip
+    int eip_line;                           // source code line number for eip
+    const char *eip_fn_name;                // name of function containing eip
+    int eip_fn_namelen;                     // length of function's name
+    uintptr_t eip_fn_addr;                  // start address of function
+    int eip_fn_narg;                        // number of function arguments
+};
+
+/* *
+ * stab_binsearch - according to the input, the initial value of
+ * range [*@region_left, *@region_right], find a single stab entry
+ * that includes the address @addr and matches the type @type,
+ * and then save its boundary to the locations that pointed
+ * by @region_left and @region_right.
+ *
+ * Some stab types are arranged in increasing order by instruction address.
+ * For example, N_FUN stabs (stab entries with n_type == N_FUN), which
+ * mark functions, and N_SO stabs, which mark source files.
+ *
+ * Given an instruction address, this function finds the single stab entry
+ * of type @type that contains that address.
+ *
+ * The search takes place within the range [*@region_left, *@region_right].
+ * Thus, to search an entire set of N stabs, you might do:
+ *
+ *      left = 0;
+ *      right = N - 1;    (rightmost stab)
+ *      stab_binsearch(stabs, &left, &right, type, addr);
+ *
+ * The search modifies *region_left and *region_right to bracket the @addr.
+ * *@region_left points to the matching stab that contains @addr,
+ * and *@region_right points just before the next stab.
+ * If *@region_left > *region_right, then @addr is not contained in any
+ * matching stab.
+ *
+ * For example, given these N_SO stabs:
+ *      Index  Type   Address
+ *      0      SO     f0100000
+ *      13     SO     f0100040
+ *      117    SO     f0100176
+ *      118    SO     f0100178
+ *      555    SO     f0100652
+ *      556    SO     f0100654
+ *      657    SO     f0100849
+ * this code:
+ *      left = 0, right = 657;
+ *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+ * will exit setting left = 118, right = 554.
+ * */
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+        int true_m = (l + r) / 2, m = true_m;
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+            m --;
+        }
+        if (m < l) {    // no match in [l, m]
+            l = true_m + 1;
+            continue;
+        }
+
+        // actual binary search
+        any_matches = 1;
+        if (stabs[m].n_value < addr) {
+            *region_left = m;
+            l = true_m + 1;
+        } else if (stabs[m].n_value > addr) {
+            *region_right = m - 1;
+            r = m - 1;
+        } else {
+            // exact match for 'addr', but continue loop to find
+            // *region_right
+            *region_left = m;
+            l = m;
+            addr ++;
+        }
+    }
+
+    if (!any_matches) {
+        *region_right = *region_left - 1;
+    }
+    else {
+        // find rightmost region containing 'addr'
+        l = *region_right;
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+            /* do nothing */;
+        *region_left = l;
+    }
+}
+
+/* *
+ * debuginfo_eip - Fill in the @info structure with information about
+ * the specified instruction address, @addr.  Returns 0 if information
+ * was found, and negative if not.  But even if it returns negative it
+ * has stored some information into '*info'.
+ * */
+int
+debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
+    const struct stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+
+    info->eip_file = "<unknown>";
+    info->eip_line = 0;
+    info->eip_fn_name = "<unknown>";
+    info->eip_fn_namelen = 9;
+    info->eip_fn_addr = addr;
+    info->eip_fn_narg = 0;
+
+    stabs = __STAB_BEGIN__;
+    stab_end = __STAB_END__;
+    stabstr = __STABSTR_BEGIN__;
+    stabstr_end = __STABSTR_END__;
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
+        return -1;
+    }
+
+    // Now we find the right stabs that define the function containing
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    int lfile = 0, rfile = (stab_end - stabs) - 1;
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+    if (lfile == 0)
+        return -1;
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    int lfun = lfile, rfun = rfile;
+    int lline, rline;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+
+    if (lfun <= rfun) {
+        // stabs[lfun] points to the function name
+        // in the string table, but check bounds just in case.
+        if (stabs[lfun].n_strx < stabstr_end - stabstr) {
+            info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+        }
+        info->eip_fn_addr = stabs[lfun].n_value;
+        addr -= info->eip_fn_addr;
+        // Search within the function definition for the line number.
+        lline = lfun;
+        rline = rfun;
+    } else {
+        // Couldn't find function stab!  Maybe we're in an assembly
+        // file.  Search the whole file for the line number.
+        info->eip_fn_addr = addr;
+        lline = lfile;
+        rline = rfile;
+    }
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) {
+        info->eip_line = stabs[rline].n_desc;
+    } else {
+        return -1;
+    }
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+           && stabs[lline].n_type != N_SOL
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+        lline --;
+    }
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
+        info->eip_file = stabstr + stabs[lline].n_strx;
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+            info->eip_fn_narg ++;
+        }
+    }
+    return 0;
+}
+
+/* *
+ * print_kerninfo - print the information about kernel, including the location
+ * of kernel entry, the start addresses of data and text segements, the start
+ * address of free memory and how many memory that kernel has used.
+ * */
+void
+print_kerninfo(void) {
+    extern char etext[], edata[], end[], kern_init[];
+    cprintf("Special kernel symbols:\n");
+    cprintf("  entry  0x%08x (phys)\n", kern_init);
+    cprintf("  etext  0x%08x (phys)\n", etext);
+    cprintf("  edata  0x%08x (phys)\n", edata);
+    cprintf("  end    0x%08x (phys)\n", end);
+    cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
+}
+
+/* *
+ * print_debuginfo - read and print the stat information for the address @eip,
+ * and info.eip_fn_addr should be the first address of the related function.
+ * */
+void
+print_debuginfo(uintptr_t eip) {
+    struct eipdebuginfo info;
+    if (debuginfo_eip(eip, &info) != 0) {
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+    }
+    else {
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+    }
+}
+
+static __noinline uint32_t
+read_eip(void) {
+    uint32_t eip;
+    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
+    return eip;
+}
+
+/* *
+ * print_stackframe - print a list of the saved eip values from the nested 'call'
+ * instructions that led to the current point of execution
+ *
+ * The x86 stack pointer, namely esp, points to the lowest location on the stack
+ * that is currently in use. Everything below that location in stack is free. Pushing
+ * a value onto the stack will invole decreasing the stack pointer and then writing
+ * the value to the place that stack pointer pointes to. And popping a value do the
+ * opposite.
+ *
+ * The ebp (base pointer) register, in contrast, is associated with the stack
+ * primarily by software convention. On entry to a C function, the function's
+ * prologue code normally saves the previous function's base pointer by pushing
+ * it onto the stack, and then copies the current esp value into ebp for the duration
+ * of the function. If all the functions in a program obey this convention,
+ * then at any given point during the program's execution, it is possible to trace
+ * back through the stack by following the chain of saved ebp pointers and determining
+ * exactly what nested sequence of function calls caused this particular point in the
+ * program to be reached. This capability can be particularly useful, for example,
+ * when a particular function causes an assert failure or panic because bad arguments
+ * were passed to it, but you aren't sure who passed the bad arguments. A stack
+ * backtrace lets you find the offending function.
+ *
+ * The inline function read_ebp() can tell us the value of current ebp. And the
+ * non-inline function read_eip() is useful, it can read the value of current eip,
+ * since while calling this function, read_eip() can read the caller's eip from
+ * stack easily.
+ *
+ * In print_debuginfo(), the function debuginfo_eip() can get enough information about
+ * calling-chain. Finally print_stackframe() will trace and print them for debugging.
+ *
+ * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
+ * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
+ * */
+void
+print_stackframe(void) {
+     /* LAB1 YOUR CODE : STEP 1 */
+     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
+      * (2) call read_eip() to get the value of eip. the type is (uint32_t);
+      * (3) from 0 .. STACKFRAME_DEPTH
+      *    (3.1) printf value of ebp, eip
+      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]
+      *    (3.3) cprintf("\n");
+      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
+      *    (3.5) popup a calling stackframe
+      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+}
+
diff -r -u -P lab2_origin/kern/debug/kdebug.h lab2/kern/debug/kdebug.h
--- lab2_origin/kern/debug/kdebug.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/debug/kdebug.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,12 @@
+#ifndef __KERN_DEBUG_KDEBUG_H__
+#define __KERN_DEBUG_KDEBUG_H__
+
+#include <defs.h>
+#include <trap.h>
+
+void print_kerninfo(void);
+void print_stackframe(void);
+void print_debuginfo(uintptr_t eip);
+
+#endif /* !__KERN_DEBUG_KDEBUG_H__ */
+
diff -r -u -P lab2_origin/kern/debug/kmonitor.c lab2/kern/debug/kmonitor.c
--- lab2_origin/kern/debug/kmonitor.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/debug/kmonitor.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,132 @@
+#include <stdio.h>
+#include <string.h>
+#include <mmu.h>
+#include <trap.h>
+#include <kmonitor.h>
+#include <kdebug.h>
+
+/* *
+ * Simple command-line kernel monitor useful for controlling the
+ * kernel and exploring the system interactively.
+ * */
+
+struct command {
+    const char *name;
+    const char *desc;
+    // return -1 to force monitor to exit
+    int(*func)(int argc, char **argv, struct trapframe *tf);
+};
+
+static struct command commands[] = {
+    {"help", "Display this list of commands.", mon_help},
+    {"kerninfo", "Display information about the kernel.", mon_kerninfo},
+    {"backtrace", "Print backtrace of stack frame.", mon_backtrace},
+};
+
+/* return if kernel is panic, in kern/debug/panic.c */
+bool is_kernel_panic(void);
+
+#define NCOMMANDS (sizeof(commands)/sizeof(struct command))
+
+/***** Kernel monitor command interpreter *****/
+
+#define MAXARGS         16
+#define WHITESPACE      " \t\n\r"
+
+/* parse - parse the command buffer into whitespace-separated arguments */
+static int
+parse(char *buf, char **argv) {
+    int argc = 0;
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+            *buf ++ = '\0';
+        }
+        if (*buf == '\0') {
+            break;
+        }
+
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+        }
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+            buf ++;
+        }
+    }
+    return argc;
+}
+
+/* *
+ * runcmd - parse the input string, split it into separated arguments
+ * and then lookup and invoke some related commands/
+ * */
+static int
+runcmd(char *buf, struct trapframe *tf) {
+    char *argv[MAXARGS];
+    int argc = parse(buf, argv);
+    if (argc == 0) {
+        return 0;
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+            return commands[i].func(argc - 1, argv + 1, tf);
+        }
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+    return 0;
+}
+
+/***** Implementations of basic kernel monitor commands *****/
+
+void
+kmonitor(struct trapframe *tf) {
+    cprintf("Welcome to the kernel debug monitor!!\n");
+    cprintf("Type 'help' for a list of commands.\n");
+
+    if (tf != NULL) {
+        print_trapframe(tf);
+    }
+
+    char *buf;
+    while (1) {
+        if ((buf = readline("K> ")) != NULL) {
+            if (runcmd(buf, tf) < 0) {
+                break;
+            }
+        }
+    }
+}
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+    }
+    return 0;
+}
+
+/* *
+ * mon_kerninfo - call print_kerninfo in kern/debug/kdebug.c to
+ * print the memory occupancy in kernel.
+ * */
+int
+mon_kerninfo(int argc, char **argv, struct trapframe *tf) {
+    print_kerninfo();
+    return 0;
+}
+
+/* *
+ * mon_backtrace - call print_stackframe in kern/debug/kdebug.c to
+ * print a backtrace of the stack.
+ * */
+int
+mon_backtrace(int argc, char **argv, struct trapframe *tf) {
+    print_stackframe();
+    return 0;
+}
+
diff -r -u -P lab2_origin/kern/debug/kmonitor.h lab2/kern/debug/kmonitor.h
--- lab2_origin/kern/debug/kmonitor.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/debug/kmonitor.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,19 @@
+#ifndef __KERN_DEBUG_MONITOR_H__
+#define __KERN_DEBUG_MONITOR_H__
+
+#include <trap.h>
+
+void kmonitor(struct trapframe *tf);
+
+int mon_help(int argc, char **argv, struct trapframe *tf);
+int mon_kerninfo(int argc, char **argv, struct trapframe *tf);
+int mon_backtrace(int argc, char **argv, struct trapframe *tf);
+int mon_continue(int argc, char **argv, struct trapframe *tf);
+int mon_step(int argc, char **argv, struct trapframe *tf);
+int mon_breakpoint(int argc, char **argv, struct trapframe *tf);
+int mon_watchpoint(int argc, char **argv, struct trapframe *tf);
+int mon_delete_dr(int argc, char **argv, struct trapframe *tf);
+int mon_list_dr(int argc, char **argv, struct trapframe *tf);
+
+#endif /* !__KERN_DEBUG_MONITOR_H__ */
+
diff -r -u -P lab2_origin/kern/debug/panic.c lab2/kern/debug/panic.c
--- lab2_origin/kern/debug/panic.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/debug/panic.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,49 @@
+#include <defs.h>
+#include <stdio.h>
+#include <intr.h>
+#include <kmonitor.h>
+
+static bool is_panic = 0;
+
+/* *
+ * __panic - __panic is called on unresolvable fatal errors. it prints
+ * "panic: 'message'", and then enters the kernel monitor.
+ * */
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+    if (is_panic) {
+        goto panic_dead;
+    }
+    is_panic = 1;
+
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+    cprintf("kernel panic at %s:%d:\n    ", file, line);
+    vcprintf(fmt, ap);
+    cprintf("\n");
+    va_end(ap);
+
+panic_dead:
+    intr_disable();
+    while (1) {
+        kmonitor(NULL);
+    }
+}
+
+/* __warn - like panic, but don't */
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+    va_list ap;
+    va_start(ap, fmt);
+    cprintf("kernel warning at %s:%d:\n    ", file, line);
+    vcprintf(fmt, ap);
+    cprintf("\n");
+    va_end(ap);
+}
+
+bool
+is_kernel_panic(void) {
+    return is_panic;
+}
+
diff -r -u -P lab2_origin/kern/debug/stab.h lab2/kern/debug/stab.h
--- lab2_origin/kern/debug/stab.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/debug/stab.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,54 @@
+#ifndef __KERN_DEBUG_STAB_H__
+#define __KERN_DEBUG_STAB_H__
+
+#include <defs.h>
+
+/* *
+ * STABS debugging info
+ *
+ * The kernel debugger can understand some debugging information in
+ * the STABS format.  For more information on this format, see
+ * http://sources.redhat.com/gdb/onlinedocs/stabs_toc.html
+ *
+ * The constants below define some symbol types used by various debuggers
+ * and compilers.  Kernel uses the N_SO, N_SOL, N_FUN, and N_SLINE types.
+ * */
+
+#define N_GSYM      0x20    // global symbol
+#define N_FNAME     0x22    // F77 function name
+#define N_FUN       0x24    // procedure name
+#define N_STSYM     0x26    // data segment variable
+#define N_LCSYM     0x28    // bss segment variable
+#define N_MAIN      0x2a    // main function name
+#define N_PC        0x30    // global Pascal symbol
+#define N_RSYM      0x40    // register variable
+#define N_SLINE     0x44    // text segment line number
+#define N_DSLINE    0x46    // data segment line number
+#define N_BSLINE    0x48    // bss segment line number
+#define N_SSYM      0x60    // structure/union element
+#define N_SO        0x64    // main source file name
+#define N_LSYM      0x80    // stack variable
+#define N_BINCL     0x82    // include file beginning
+#define N_SOL       0x84    // included source file name
+#define N_PSYM      0xa0    // parameter variable
+#define N_EINCL     0xa2    // include file end
+#define N_ENTRY     0xa4    // alternate entry point
+#define N_LBRAC     0xc0    // left bracket
+#define N_EXCL      0xc2    // deleted include file
+#define N_RBRAC     0xe0    // right bracket
+#define N_BCOMM     0xe2    // begin common
+#define N_ECOMM     0xe4    // end common
+#define N_ECOML     0xe8    // end common (local name)
+#define N_LENG      0xfe    // length of preceding entry
+
+/* Entries in the STABS table are formatted as follows. */
+struct stab {
+    uint32_t n_strx;        // index into string table of name
+    uint8_t n_type;         // type of symbol
+    uint8_t n_other;        // misc info (usually empty)
+    uint16_t n_desc;        // description field
+    uintptr_t n_value;      // value of symbol
+};
+
+#endif /* !__KERN_DEBUG_STAB_H__ */
+
diff -r -u -P lab2_origin/kern/driver/clock.c lab2/kern/driver/clock.c
--- lab2_origin/kern/driver/clock.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/clock.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,45 @@
+#include <x86.h>
+#include <trap.h>
+#include <stdio.h>
+#include <picirq.h>
+
+/* *
+ * Support for time-related hardware gadgets - the 8253 timer,
+ * which generates interruptes on IRQ-0.
+ * */
+
+#define IO_TIMER1           0x040               // 8253 Timer #1
+
+/* *
+ * Frequency of all three count-down timers; (TIMER_FREQ/freq)
+ * is the appropriate count to generate a frequency of freq Hz.
+ * */
+
+#define TIMER_FREQ      1193182
+#define TIMER_DIV(x)    ((TIMER_FREQ + (x) / 2) / (x))
+
+#define TIMER_MODE      (IO_TIMER1 + 3)         // timer mode port
+#define TIMER_SEL0      0x00                    // select counter 0
+#define TIMER_RATEGEN   0x04                    // mode 2, rate generator
+#define TIMER_16BIT     0x30                    // r/w counter 16 bits, LSB first
+
+volatile size_t ticks;
+
+/* *
+ * clock_init - initialize 8253 clock to interrupt 100 times per second,
+ * and then enable IRQ_TIMER.
+ * */
+void
+clock_init(void) {
+    // set 8253 timer-chip
+    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+    outb(IO_TIMER1, TIMER_DIV(100) % 256);
+    outb(IO_TIMER1, TIMER_DIV(100) / 256);
+
+    // initialize time counter 'ticks' to zero
+    ticks = 0;
+
+    cprintf("++ setup timer interrupts\n");
+    pic_enable(IRQ_TIMER);
+}
+
diff -r -u -P lab2_origin/kern/driver/clock.h lab2/kern/driver/clock.h
--- lab2_origin/kern/driver/clock.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/clock.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,11 @@
+#ifndef __KERN_DRIVER_CLOCK_H__
+#define __KERN_DRIVER_CLOCK_H__
+
+#include <defs.h>
+
+extern volatile size_t ticks;
+
+void clock_init(void);
+
+#endif /* !__KERN_DRIVER_CLOCK_H__ */
+
diff -r -u -P lab2_origin/kern/driver/console.c lab2/kern/driver/console.c
--- lab2_origin/kern/driver/console.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/console.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,465 @@
+#include <defs.h>
+#include <x86.h>
+#include <stdio.h>
+#include <string.h>
+#include <kbdreg.h>
+#include <picirq.h>
+#include <trap.h>
+#include <memlayout.h>
+#include <sync.h>
+
+/* stupid I/O delay routine necessitated by historical PC design flaws */
+static void
+delay(void) {
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+}
+
+/***** Serial I/O code *****/
+#define COM1            0x3F8
+
+#define COM_RX          0       // In:  Receive buffer (DLAB=0)
+#define COM_TX          0       // Out: Transmit buffer (DLAB=0)
+#define COM_DLL         0       // Out: Divisor Latch Low (DLAB=1)
+#define COM_DLM         1       // Out: Divisor Latch High (DLAB=1)
+#define COM_IER         1       // Out: Interrupt Enable Register
+#define COM_IER_RDI     0x01    // Enable receiver data interrupt
+#define COM_IIR         2       // In:  Interrupt ID Register
+#define COM_FCR         2       // Out: FIFO Control Register
+#define COM_LCR         3       // Out: Line Control Register
+#define COM_LCR_DLAB    0x80    // Divisor latch access bit
+#define COM_LCR_WLEN8   0x03    // Wordlength: 8 bits
+#define COM_MCR         4       // Out: Modem Control Register
+#define COM_MCR_RTS     0x02    // RTS complement
+#define COM_MCR_DTR     0x01    // DTR complement
+#define COM_MCR_OUT2    0x08    // Out2 complement
+#define COM_LSR         5       // In:  Line Status Register
+#define COM_LSR_DATA    0x01    // Data available
+#define COM_LSR_TXRDY   0x20    // Transmit buffer avail
+#define COM_LSR_TSRE    0x40    // Transmitter off
+
+#define MONO_BASE       0x3B4
+#define MONO_BUF        0xB0000
+#define CGA_BASE        0x3D4
+#define CGA_BUF         0xB8000
+#define CRT_ROWS        25
+#define CRT_COLS        80
+#define CRT_SIZE        (CRT_ROWS * CRT_COLS)
+
+#define LPTPORT         0x378
+
+static uint16_t *crt_buf;
+static uint16_t crt_pos;
+static uint16_t addr_6845;
+
+/* TEXT-mode CGA/VGA display output */
+
+static void
+cga_init(void) {
+    volatile uint16_t *cp = (uint16_t *)(CGA_BUF + KERNBASE);
+    uint16_t was = *cp;
+    *cp = (uint16_t) 0xA55A;
+    if (*cp != 0xA55A) {
+        cp = (uint16_t*)(MONO_BUF + KERNBASE);
+        addr_6845 = MONO_BASE;
+    } else {
+        *cp = was;
+        addr_6845 = CGA_BASE;
+    }
+
+    // Extract cursor location
+    uint32_t pos;
+    outb(addr_6845, 14);
+    pos = inb(addr_6845 + 1) << 8;
+    outb(addr_6845, 15);
+    pos |= inb(addr_6845 + 1);
+
+    crt_buf = (uint16_t*) cp;
+    crt_pos = pos;
+}
+
+static bool serial_exists = 0;
+
+static void
+serial_init(void) {
+    // Turn off the FIFO
+    outb(COM1 + COM_FCR, 0);
+
+    // Set speed; requires DLAB latch
+    outb(COM1 + COM_LCR, COM_LCR_DLAB);
+    outb(COM1 + COM_DLL, (uint8_t) (115200 / 9600));
+    outb(COM1 + COM_DLM, 0);
+
+    // 8 data bits, 1 stop bit, parity off; turn off DLAB latch
+    outb(COM1 + COM_LCR, COM_LCR_WLEN8 & ~COM_LCR_DLAB);
+
+    // No modem controls
+    outb(COM1 + COM_MCR, 0);
+    // Enable rcv interrupts
+    outb(COM1 + COM_IER, COM_IER_RDI);
+
+    // Clear any preexisting overrun indications and interrupts
+    // Serial port doesn't exist if COM_LSR returns 0xFF
+    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
+    (void) inb(COM1+COM_IIR);
+    (void) inb(COM1+COM_RX);
+
+    if (serial_exists) {
+        pic_enable(IRQ_COM1);
+    }
+}
+
+static void
+lpt_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+        delay();
+    }
+    outb(LPTPORT + 0, c);
+    outb(LPTPORT + 2, 0x08 | 0x04 | 0x01);
+    outb(LPTPORT + 2, 0x08);
+}
+
+/* lpt_putc - copy console output to parallel port */
+static void
+lpt_putc(int c) {
+    if (c != '\b') {
+        lpt_putc_sub(c);
+    }
+    else {
+        lpt_putc_sub('\b');
+        lpt_putc_sub(' ');
+        lpt_putc_sub('\b');
+    }
+}
+
+/* cga_putc - print character to console */
+static void
+cga_putc(int c) {
+    // set black on white
+    if (!(c & ~0xFF)) {
+        c |= 0x0700;
+    }
+
+    switch (c & 0xff) {
+    case '\b':
+        if (crt_pos > 0) {
+            crt_pos --;
+            crt_buf[crt_pos] = (c & ~0xff) | ' ';
+        }
+        break;
+    case '\n':
+        crt_pos += CRT_COLS;
+    case '\r':
+        crt_pos -= (crt_pos % CRT_COLS);
+        break;
+    default:
+        crt_buf[crt_pos ++] = c;     // write the character
+        break;
+    }
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+            crt_buf[i] = 0x0700 | ' ';
+        }
+        crt_pos -= CRT_COLS;
+    }
+
+    // move that little blinky thing
+    outb(addr_6845, 14);
+    outb(addr_6845 + 1, crt_pos >> 8);
+    outb(addr_6845, 15);
+    outb(addr_6845 + 1, crt_pos);
+}
+
+static void
+serial_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+        delay();
+    }
+    outb(COM1 + COM_TX, c);
+}
+
+/* serial_putc - print character to serial port */
+static void
+serial_putc(int c) {
+    if (c != '\b') {
+        serial_putc_sub(c);
+    }
+    else {
+        serial_putc_sub('\b');
+        serial_putc_sub(' ');
+        serial_putc_sub('\b');
+    }
+}
+
+/* *
+ * Here we manage the console input buffer, where we stash characters
+ * received from the keyboard or serial port whenever the corresponding
+ * interrupt occurs.
+ * */
+
+#define CONSBUFSIZE 512
+
+static struct {
+    uint8_t buf[CONSBUFSIZE];
+    uint32_t rpos;
+    uint32_t wpos;
+} cons;
+
+/* *
+ * cons_intr - called by device interrupt routines to feed input
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+    int c;
+    while ((c = (*proc)()) != -1) {
+        if (c != 0) {
+            cons.buf[cons.wpos ++] = c;
+            if (cons.wpos == CONSBUFSIZE) {
+                cons.wpos = 0;
+            }
+        }
+    }
+}
+
+/* serial_proc_data - get data from serial port */
+static int
+serial_proc_data(void) {
+    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {
+        return -1;
+    }
+    int c = inb(COM1 + COM_RX);
+    if (c == 127) {
+        c = '\b';
+    }
+    return c;
+}
+
+/* serial_intr - try to feed input characters from serial port */
+void
+serial_intr(void) {
+    if (serial_exists) {
+        cons_intr(serial_proc_data);
+    }
+}
+
+/***** Keyboard input code *****/
+
+#define NO              0
+
+#define SHIFT           (1<<0)
+#define CTL             (1<<1)
+#define ALT             (1<<2)
+
+#define CAPSLOCK        (1<<3)
+#define NUMLOCK         (1<<4)
+#define SCROLLLOCK      (1<<5)
+
+#define E0ESC           (1<<6)
+
+static uint8_t shiftcode[256] = {
+    [0x1D] CTL,
+    [0x2A] SHIFT,
+    [0x36] SHIFT,
+    [0x38] ALT,
+    [0x9D] CTL,
+    [0xB8] ALT
+};
+
+static uint8_t togglecode[256] = {
+    [0x3A] CAPSLOCK,
+    [0x45] NUMLOCK,
+    [0x46] SCROLLLOCK
+};
+
+static uint8_t normalmap[256] = {
+    NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
+    '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
+    'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
+    'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
+    'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
+    '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
+    'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
+    NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+    NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+    '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+    '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+    [0xC7] KEY_HOME,    [0x9C] '\n' /*KP_Enter*/,
+    [0xB5] '/' /*KP_Div*/,  [0xC8] KEY_UP,
+    [0xC9] KEY_PGUP,    [0xCB] KEY_LF,
+    [0xCD] KEY_RT,      [0xCF] KEY_END,
+    [0xD0] KEY_DN,      [0xD1] KEY_PGDN,
+    [0xD2] KEY_INS,     [0xD3] KEY_DEL
+};
+
+static uint8_t shiftmap[256] = {
+    NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
+    '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
+    'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
+    'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
+    'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
+    '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
+    'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
+    NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+    NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+    '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+    '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+    [0xC7] KEY_HOME,    [0x9C] '\n' /*KP_Enter*/,
+    [0xB5] '/' /*KP_Div*/,  [0xC8] KEY_UP,
+    [0xC9] KEY_PGUP,    [0xCB] KEY_LF,
+    [0xCD] KEY_RT,      [0xCF] KEY_END,
+    [0xD0] KEY_DN,      [0xD1] KEY_PGDN,
+    [0xD2] KEY_INS,     [0xD3] KEY_DEL
+};
+
+#define C(x) (x - '@')
+
+static uint8_t ctlmap[256] = {
+    NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+    NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+    C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
+    C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
+    C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
+    NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
+    C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
+    [0x97] KEY_HOME,
+    [0xB5] C('/'),      [0xC8] KEY_UP,
+    [0xC9] KEY_PGUP,    [0xCB] KEY_LF,
+    [0xCD] KEY_RT,      [0xCF] KEY_END,
+    [0xD0] KEY_DN,      [0xD1] KEY_PGDN,
+    [0xD2] KEY_INS,     [0xD3] KEY_DEL
+};
+
+static uint8_t *charcode[4] = {
+    normalmap,
+    shiftmap,
+    ctlmap,
+    ctlmap
+};
+
+/* *
+ * kbd_proc_data - get data from keyboard
+ *
+ * The kbd_proc_data() function gets data from the keyboard.
+ * If we finish a character, return it, else 0. And return -1 if no data.
+ * */
+static int
+kbd_proc_data(void) {
+    int c;
+    uint8_t data;
+    static uint32_t shift;
+
+    if ((inb(KBSTATP) & KBS_DIB) == 0) {
+        return -1;
+    }
+
+    data = inb(KBDATAP);
+
+    if (data == 0xE0) {
+        // E0 escape character
+        shift |= E0ESC;
+        return 0;
+    } else if (data & 0x80) {
+        // Key released
+        data = (shift & E0ESC ? data : data & 0x7F);
+        shift &= ~(shiftcode[data] | E0ESC);
+        return 0;
+    } else if (shift & E0ESC) {
+        // Last character was an E0 escape; or with 0x80
+        data |= 0x80;
+        shift &= ~E0ESC;
+    }
+
+    shift |= shiftcode[data];
+    shift ^= togglecode[data];
+
+    c = charcode[shift & (CTL | SHIFT)][data];
+    if (shift & CAPSLOCK) {
+        if ('a' <= c && c <= 'z')
+            c += 'A' - 'a';
+        else if ('A' <= c && c <= 'Z')
+            c += 'a' - 'A';
+    }
+
+    // Process special keys
+    // Ctrl-Alt-Del: reboot
+    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+        cprintf("Rebooting!\n");
+        outb(0x92, 0x3); // courtesy of Chris Frost
+    }
+    return c;
+}
+
+/* kbd_intr - try to feed input characters from keyboard */
+static void
+kbd_intr(void) {
+    cons_intr(kbd_proc_data);
+}
+
+static void
+kbd_init(void) {
+    // drain the kbd buffer
+    kbd_intr();
+    pic_enable(IRQ_KBD);
+}
+
+/* cons_init - initializes the console devices */
+void
+cons_init(void) {
+    cga_init();
+    serial_init();
+    kbd_init();
+    if (!serial_exists) {
+        cprintf("serial port does not exist!!\n");
+    }
+}
+
+/* cons_putc - print a single character @c to console devices */
+void
+cons_putc(int c) {
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        lpt_putc(c);
+        cga_putc(c);
+        serial_putc(c);
+    }
+    local_intr_restore(intr_flag);
+}
+
+/* *
+ * cons_getc - return the next input character from console,
+ * or 0 if none waiting.
+ * */
+int
+cons_getc(void) {
+    int c = 0;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        // poll for any pending input characters,
+        // so that this function works even when interrupts are disabled
+        // (e.g., when called from the kernel monitor).
+        serial_intr();
+        kbd_intr();
+
+        // grab the next character from the input buffer.
+        if (cons.rpos != cons.wpos) {
+            c = cons.buf[cons.rpos ++];
+            if (cons.rpos == CONSBUFSIZE) {
+                cons.rpos = 0;
+            }
+        }
+    }
+    local_intr_restore(intr_flag);
+    return c;
+}
+
diff -r -u -P lab2_origin/kern/driver/console.h lab2/kern/driver/console.h
--- lab2_origin/kern/driver/console.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/console.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,11 @@
+#ifndef __KERN_DRIVER_CONSOLE_H__
+#define __KERN_DRIVER_CONSOLE_H__
+
+void cons_init(void);
+void cons_putc(int c);
+int cons_getc(void);
+void serial_intr(void);
+void kbd_intr(void);
+
+#endif /* !__KERN_DRIVER_CONSOLE_H__ */
+
diff -r -u -P lab2_origin/kern/driver/intr.c lab2/kern/driver/intr.c
--- lab2_origin/kern/driver/intr.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/intr.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,15 @@
+#include <x86.h>
+#include <intr.h>
+
+/* intr_enable - enable irq interrupt */
+void
+intr_enable(void) {
+    sti();
+}
+
+/* intr_disable - disable irq interrupt */
+void
+intr_disable(void) {
+    cli();
+}
+
diff -r -u -P lab2_origin/kern/driver/intr.h lab2/kern/driver/intr.h
--- lab2_origin/kern/driver/intr.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/intr.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,8 @@
+#ifndef __KERN_DRIVER_INTR_H__
+#define __KERN_DRIVER_INTR_H__
+
+void intr_enable(void);
+void intr_disable(void);
+
+#endif /* !__KERN_DRIVER_INTR_H__ */
+
diff -r -u -P lab2_origin/kern/driver/kbdreg.h lab2/kern/driver/kbdreg.h
--- lab2_origin/kern/driver/kbdreg.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/kbdreg.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,84 @@
+#ifndef __KERN_DRIVER_KBDREG_H__
+#define __KERN_DRIVER_KBDREG_H__
+
+// Special keycodes
+#define KEY_HOME            0xE0
+#define KEY_END             0xE1
+#define KEY_UP              0xE2
+#define KEY_DN              0xE3
+#define KEY_LF              0xE4
+#define KEY_RT              0xE5
+#define KEY_PGUP            0xE6
+#define KEY_PGDN            0xE7
+#define KEY_INS             0xE8
+#define KEY_DEL             0xE9
+
+
+/* This is i8042reg.h + kbdreg.h from NetBSD. */
+
+#define KBSTATP             0x64    // kbd controller status port(I)
+#define KBS_DIB             0x01    // kbd data in buffer
+#define KBS_IBF             0x02    // kbd input buffer low
+#define KBS_WARM            0x04    // kbd input buffer low
+#define BS_OCMD             0x08    // kbd output buffer has command
+#define KBS_NOSEC           0x10    // kbd security lock not engaged
+#define KBS_TERR            0x20    // kbd transmission error
+#define KBS_RERR            0x40    // kbd receive error
+#define KBS_PERR            0x80    // kbd parity error
+
+#define KBCMDP              0x64    // kbd controller port(O)
+#define KBC_RAMREAD         0x20    // read from RAM
+#define KBC_RAMWRITE        0x60    // write to RAM
+#define KBC_AUXDISABLE      0xa7    // disable auxiliary port
+#define KBC_AUXENABLE       0xa8    // enable auxiliary port
+#define KBC_AUXTEST         0xa9    // test auxiliary port
+#define KBC_KBDECHO         0xd2    // echo to keyboard port
+#define KBC_AUXECHO         0xd3    // echo to auxiliary port
+#define KBC_AUXWRITE        0xd4    // write to auxiliary port
+#define KBC_SELFTEST        0xaa    // start self-test
+#define KBC_KBDTEST         0xab    // test keyboard port
+#define KBC_KBDDISABLE      0xad    // disable keyboard port
+#define KBC_KBDENABLE       0xae    // enable keyboard port
+#define KBC_PULSE0          0xfe    // pulse output bit 0
+#define KBC_PULSE1          0xfd    // pulse output bit 1
+#define KBC_PULSE2          0xfb    // pulse output bit 2
+#define KBC_PULSE3          0xf7    // pulse output bit 3
+
+#define KBDATAP             0x60    // kbd data port(I)
+#define KBOUTP              0x60    // kbd data port(O)
+
+#define K_RDCMDBYTE         0x20
+#define K_LDCMDBYTE         0x60
+
+#define KC8_TRANS           0x40    // convert to old scan codes
+#define KC8_MDISABLE        0x20    // disable mouse
+#define KC8_KDISABLE        0x10    // disable keyboard
+#define KC8_IGNSEC          0x08    // ignore security lock
+#define KC8_CPU             0x04    // exit from protected mode reset
+#define KC8_MENABLE         0x02    // enable mouse interrupt
+#define KC8_KENABLE         0x01    // enable keyboard interrupt
+#define CMDBYTE             (KC8_TRANS|KC8_CPU|KC8_MENABLE|KC8_KENABLE)
+
+/* keyboard commands */
+#define KBC_RESET           0xFF    // reset the keyboard
+#define KBC_RESEND          0xFE    // request the keyboard resend the last byte
+#define KBC_SETDEFAULT      0xF6    // resets keyboard to its power-on defaults
+#define KBC_DISABLE         0xF5    // as per KBC_SETDEFAULT, but also disable key scanning
+#define KBC_ENABLE          0xF4    // enable key scanning
+#define KBC_TYPEMATIC       0xF3    // set typematic rate and delay
+#define KBC_SETTABLE        0xF0    // set scancode translation table
+#define KBC_MODEIND         0xED    // set mode indicators(i.e. LEDs)
+#define KBC_ECHO            0xEE    // request an echo from the keyboard
+
+/* keyboard responses */
+#define KBR_EXTENDED        0xE0    // extended key sequence
+#define KBR_RESEND          0xFE    // needs resend of command
+#define KBR_ACK             0xFA    // received a valid command
+#define KBR_OVERRUN         0x00    // flooded
+#define KBR_FAILURE         0xFD    // diagnosic failure
+#define KBR_BREAK           0xF0    // break code prefix - sent on key release
+#define KBR_RSTDONE         0xAA    // reset complete
+#define KBR_ECHO            0xEE    // echo response
+
+#endif /* !__KERN_DRIVER_KBDREG_H__ */
+
diff -r -u -P lab2_origin/kern/driver/picirq.c lab2/kern/driver/picirq.c
--- lab2_origin/kern/driver/picirq.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/picirq.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,86 @@
+#include <defs.h>
+#include <x86.h>
+#include <picirq.h>
+
+// I/O Addresses of the two programmable interrupt controllers
+#define IO_PIC1             0x20    // Master (IRQs 0-7)
+#define IO_PIC2             0xA0    // Slave (IRQs 8-15)
+
+#define IRQ_SLAVE           2       // IRQ at which slave connects to master
+
+// Current IRQ mask.
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static uint16_t irq_mask = 0xFFFF & ~(1 << IRQ_SLAVE);
+static bool did_init = 0;
+
+static void
+pic_setmask(uint16_t mask) {
+    irq_mask = mask;
+    if (did_init) {
+        outb(IO_PIC1 + 1, mask);
+        outb(IO_PIC2 + 1, mask >> 8);
+    }
+}
+
+void
+pic_enable(unsigned int irq) {
+    pic_setmask(irq_mask & ~(1 << irq));
+}
+
+/* pic_init - initialize the 8259A interrupt controllers */
+void
+pic_init(void) {
+    did_init = 1;
+
+    // mask all interrupts
+    outb(IO_PIC1 + 1, 0xFF);
+    outb(IO_PIC2 + 1, 0xFF);
+
+    // Set up master (8259A-1)
+
+    // ICW1:  0001g0hi
+    //    g:  0 = edge triggering, 1 = level triggering
+    //    h:  0 = cascaded PICs, 1 = master only
+    //    i:  0 = no ICW4, 1 = ICW4 required
+    outb(IO_PIC1, 0x11);
+
+    // ICW2:  Vector offset
+    outb(IO_PIC1 + 1, IRQ_OFFSET);
+
+    // ICW3:  (master PIC) bit mask of IR lines connected to slaves
+    //        (slave PIC) 3-bit # of slave's connection to master
+    outb(IO_PIC1 + 1, 1 << IRQ_SLAVE);
+
+    // ICW4:  000nbmap
+    //    n:  1 = special fully nested mode
+    //    b:  1 = buffered mode
+    //    m:  0 = slave PIC, 1 = master PIC
+    //        (ignored when b is 0, as the master/slave role
+    //         can be hardwired).
+    //    a:  1 = Automatic EOI mode
+    //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
+    outb(IO_PIC1 + 1, 0x3);
+
+    // Set up slave (8259A-2)
+    outb(IO_PIC2, 0x11);    // ICW1
+    outb(IO_PIC2 + 1, IRQ_OFFSET + 8);  // ICW2
+    outb(IO_PIC2 + 1, IRQ_SLAVE);       // ICW3
+    // NB Automatic EOI mode doesn't tend to work on the slave.
+    // Linux source code says it's "to be investigated".
+    outb(IO_PIC2 + 1, 0x3);             // ICW4
+
+    // OCW3:  0ef01prs
+    //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
+    //    p:  0 = no polling, 1 = polling mode
+    //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
+    outb(IO_PIC1, 0x68);    // clear specific mask
+    outb(IO_PIC1, 0x0a);    // read IRR by default
+
+    outb(IO_PIC2, 0x68);    // OCW3
+    outb(IO_PIC2, 0x0a);    // OCW3
+
+    if (irq_mask != 0xFFFF) {
+        pic_setmask(irq_mask);
+    }
+}
+
diff -r -u -P lab2_origin/kern/driver/picirq.h lab2/kern/driver/picirq.h
--- lab2_origin/kern/driver/picirq.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/driver/picirq.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,10 @@
+#ifndef __KERN_DRIVER_PICIRQ_H__
+#define __KERN_DRIVER_PICIRQ_H__
+
+void pic_init(void);
+void pic_enable(unsigned int irq);
+
+#define IRQ_OFFSET      32
+
+#endif /* !__KERN_DRIVER_PICIRQ_H__ */
+
diff -r -u -P lab2_origin/kern/init/entry.S lab2/kern/init/entry.S
--- lab2_origin/kern/init/entry.S	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/init/entry.S	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,49 @@
+#include <mmu.h>
+#include <memlayout.h>
+
+#define REALLOC(x) (x - KERNBASE)
+
+.text
+.globl kern_entry
+kern_entry:
+    # reload temperate gdt (second time) to remap all physical memory
+    # virtual_addr 0~4G=linear_addr&physical_addr -KERNBASE~4G-KERNBASE 
+    lgdt REALLOC(__gdtdesc)
+    movl $KERNEL_DS, %eax
+    movw %ax, %ds
+    movw %ax, %es
+    movw %ax, %ss
+
+    ljmp $KERNEL_CS, $relocated
+
+relocated:
+
+    # set ebp, esp
+    movl $0x0, %ebp
+    # the kernel stack region is from bootstack -- bootstacktop,
+    # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h
+    movl $bootstacktop, %esp
+    # now kernel stack is ready , call the first C function
+    call kern_init
+
+# should never get here
+spin:
+    jmp spin
+
+.data
+.align PGSIZE
+    .globl bootstack
+bootstack:
+    .space KSTACKSIZE
+    .globl bootstacktop
+bootstacktop:
+
+.align 4
+__gdt:
+    SEG_NULL
+    SEG_ASM(STA_X | STA_R, - KERNBASE, 0xFFFFFFFF)      # code segment
+    SEG_ASM(STA_W, - KERNBASE, 0xFFFFFFFF)              # data segment
+__gdtdesc:
+    .word 0x17                                          # sizeof(__gdt) - 1
+    .long REALLOC(__gdt)
+
diff -r -u -P lab2_origin/kern/init/init.c lab2/kern/init/init.c
--- lab2_origin/kern/init/init.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/init/init.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,105 @@
+#include <defs.h>
+#include <stdio.h>
+#include <string.h>
+#include <console.h>
+#include <kdebug.h>
+#include <picirq.h>
+#include <trap.h>
+#include <clock.h>
+#include <intr.h>
+#include <pmm.h>
+#include <kmonitor.h>
+
+int kern_init(void) __attribute__((noreturn));
+void grade_backtrace(void);
+static void lab1_switch_test(void);
+
+int
+kern_init(void) {
+    extern char edata[], end[];
+    memset(edata, 0, end - edata);
+
+    cons_init();                // init the console
+
+    const char *message = "(THU.CST) os is loading ...";
+    cprintf("%s\n\n", message);
+
+    print_kerninfo();
+
+    grade_backtrace();
+
+    pmm_init();                 // init physical memory management
+
+    pic_init();                 // init interrupt controller
+    idt_init();                 // init interrupt descriptor table
+
+    clock_init();               // init clock interrupt
+    intr_enable();              // enable irq interrupt
+
+    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
+    // user/kernel mode switch test
+    //lab1_switch_test();
+
+    /* do nothing */
+    while (1);
+}
+
+void __attribute__((noinline))
+grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
+    mon_backtrace(0, NULL, NULL);
+}
+
+void __attribute__((noinline))
+grade_backtrace1(int arg0, int arg1) {
+    grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
+}
+
+void __attribute__((noinline))
+grade_backtrace0(int arg0, int arg1, int arg2) {
+    grade_backtrace1(arg0, arg2);
+}
+
+void
+grade_backtrace(void) {
+    grade_backtrace0(0, (int)kern_init, 0xffff0000);
+}
+
+static void
+lab1_print_cur_status(void) {
+    static int round = 0;
+    uint16_t reg1, reg2, reg3, reg4;
+    asm volatile (
+            "mov %%cs, %0;"
+            "mov %%ds, %1;"
+            "mov %%es, %2;"
+            "mov %%ss, %3;"
+            : "=m"(reg1), "=m"(reg2), "=m"(reg3), "=m"(reg4));
+    cprintf("%d: @ring %d\n", round, reg1 & 3);
+    cprintf("%d:  cs = %x\n", round, reg1);
+    cprintf("%d:  ds = %x\n", round, reg2);
+    cprintf("%d:  es = %x\n", round, reg3);
+    cprintf("%d:  ss = %x\n", round, reg4);
+    round ++;
+}
+
+static void
+lab1_switch_to_user(void) {
+    //LAB1 CHALLENGE 1 : TODO
+}
+
+static void
+lab1_switch_to_kernel(void) {
+    //LAB1 CHALLENGE 1 :  TODO
+}
+
+static void
+lab1_switch_test(void) {
+    lab1_print_cur_status();
+    cprintf("+++ switch to  user  mode +++\n");
+    lab1_switch_to_user();
+    lab1_print_cur_status();
+    cprintf("+++ switch to kernel mode +++\n");
+    lab1_switch_to_kernel();
+    lab1_print_cur_status();
+}
+
diff -r -u -P lab2_origin/kern/libs/readline.c lab2/kern/libs/readline.c
--- lab2_origin/kern/libs/readline.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/libs/readline.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,50 @@
+#include <stdio.h>
+
+#define BUFSIZE 1024
+static char buf[BUFSIZE];
+
+/* *
+ * readline - get a line from stdin
+ * @prompt:     the string to be written to stdout
+ *
+ * The readline() function will write the input string @prompt to
+ * stdout first. If the @prompt is NULL or the empty string,
+ * no prompt is issued.
+ *
+ * This function will keep on reading characters and saving them to buffer
+ * 'buf' until '\n' or '\r' is encountered.
+ *
+ * Note that, if the length of string that will be read is longer than
+ * buffer size, the end of string will be discarded.
+ *
+ * The readline() function returns the text of the line read. If some errors
+ * are happened, NULL is returned. The return value is a global variable,
+ * thus it should be copied before it is used.
+ * */
+char *
+readline(const char *prompt) {
+    if (prompt != NULL) {
+        cprintf("%s", prompt);
+    }
+    int i = 0, c;
+    while (1) {
+        c = getchar();
+        if (c < 0) {
+            return NULL;
+        }
+        else if (c >= ' ' && i < BUFSIZE - 1) {
+            cputchar(c);
+            buf[i ++] = c;
+        }
+        else if (c == '\b' && i > 0) {
+            cputchar(c);
+            i --;
+        }
+        else if (c == '\n' || c == '\r') {
+            cputchar(c);
+            buf[i] = '\0';
+            return buf;
+        }
+    }
+}
+
diff -r -u -P lab2_origin/kern/libs/stdio.c lab2/kern/libs/stdio.c
--- lab2_origin/kern/libs/stdio.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/libs/stdio.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,78 @@
+#include <defs.h>
+#include <stdio.h>
+#include <console.h>
+
+/* HIGH level console I/O */
+
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+    cons_putc(c);
+    (*cnt) ++;
+}
+
+/* *
+ * vcprintf - format a string and writes it to stdout
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+    int cnt = 0;
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+    return cnt;
+}
+
+/* *
+ * cprintf - formats a string and writes it to stdout
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+    cnt = vcprintf(fmt, ap);
+    va_end(ap);
+    return cnt;
+}
+
+/* cputchar - writes a single character to stdout */
+void
+cputchar(int c) {
+    cons_putc(c);
+}
+
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+    return cnt;
+}
+
+/* getchar - reads a single non-zero character from stdin */
+int
+getchar(void) {
+    int c;
+    while ((c = cons_getc()) == 0)
+        /* do nothing */;
+    return c;
+}
+
diff -r -u -P lab2_origin/kern/mm/default_pmm.c lab2/kern/mm/default_pmm.c
--- lab2_origin/kern/mm/default_pmm.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/mm/default_pmm.c	2021-08-29 20:49:44.818621681 +0800
@@ -0,0 +1,293 @@
+#include <pmm.h>
+#include <list.h>
+#include <string.h>
+#include <default_pmm.h>
+
+/* In the first fit algorithm, the allocator keeps a list of free blocks (known as the free list) and,
+   on receiving a request for memory, scans along the list for the first block that is large enough to
+   satisfy the request. If the chosen block is significantly larger than that requested, then it is 
+   usually split, and the remainder added to the list as another free block.
+   Please see Page 196~198, Section 8.2 of Yan Wei Ming's chinese book "Data Structure -- C programming language"
+*/
+// LAB2 EXERCISE 1: YOUR CODE
+// you should rewrite functions: default_init,default_init_memmap,default_alloc_pages, default_free_pages.
+/*
+ * Details of FFMA
+ * (1) Prepare: In order to implement the First-Fit Mem Alloc (FFMA), we should manage the free mem block use some list.
+ *              The struct free_area_t is used for the management of free mem blocks. At first you should
+ *              be familiar to the struct list in list.h. struct list is a simple doubly linked list implementation.
+ *              You should know howto USE: list_init, list_add(list_add_after), list_add_before, list_del, list_next, list_prev
+ *              Another tricky method is to transform a general list struct to a special struct (such as struct page):
+ *              you can find some MACRO: le2page (in memlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in proc.h),etc.)
+ * (2) default_init: you can reuse the  demo default_init fun to init the free_list and set nr_free to 0.
+ *              free_list is used to record the free mem blocks. nr_free is the total number for free mem blocks.
+ * (3) default_init_memmap:  CALL GRAPH: kern_init --> pmm_init-->page_init-->init_memmap--> pmm_manager->init_memmap
+ *              This fun is used to init a free block (with parameter: addr_base, page_number).
+ *              First you should init each page (in memlayout.h) in this free block, include:
+ *                  p->flags should be set bit PG_property (means this page is valid. In pmm_init fun (in pmm.c),
+ *                  the bit PG_reserved is setted in p->flags)
+ *                  if this page  is free and is not the first page of free block, p->property should be set to 0.
+ *                  if this page  is free and is the first page of free block, p->property should be set to total num of block.
+ *                  p->ref should be 0, because now p is free and no reference.
+ *                  We can use p->page_link to link this page to free_list, (such as: list_add_before(&free_list, &(p->page_link)); )
+ *              Finally, we should sum the number of free mem block: nr_free+=n
+ * (4) default_alloc_pages: search find a first free block (block size >=n) in free list and reszie the free block, return the addr
+ *              of malloced block.
+ *              (4.1) So you should search freelist like this:
+ *                       list_entry_t le = &free_list;
+ *                       while((le=list_next(le)) != &free_list) {
+ *                       ....
+ *                 (4.1.1) In while loop, get the struct page and check the p->property (record the num of free block) >=n?
+ *                       struct Page *p = le2page(le, page_link);
+ *                       if(p->property >= n){ ...
+ *                 (4.1.2) If we find this p, then it' means we find a free block(block size >=n), and the first n pages can be malloced.
+ *                     Some flag bits of this page should be setted: PG_reserved =1, PG_property =0
+ *                     unlink the pages from free_list
+ *                     (4.1.2.1) If (p->property >n), we should re-caluclate number of the the rest of this free block,
+ *                           (such as: le2page(le,page_link))->property = p->property - n;)
+ *                 (4.1.3)  re-caluclate nr_free (number of the the rest of all free block)
+ *                 (4.1.4)  return p
+ *               (4.2) If we can not find a free block (block size >=n), then return NULL
+ * (5) default_free_pages: relink the pages into  free list, maybe merge small free blocks into big free blocks.
+ *               (5.1) according the base addr of withdrawed blocks, search free list, find the correct position
+ *                     (from low to high addr), and insert the pages. (may use list_next, le2page, list_add_before)
+ *               (5.2) reset the fields of pages, such as p->ref, p->flags (PageProperty)
+ *               (5.3) try to merge low addr or high addr blocks. Notice: should change some pages's p->property correctly.
+ */
+free_area_t free_area;
+
+#define free_list (free_area.free_list)
+#define nr_free (free_area.nr_free)
+
+static void
+default_init(void) {
+    list_init(&free_list);
+    nr_free = 0;
+}
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+    assert(n > 0);
+    struct Page *p = base;
+    for (; p != base + n; p ++) {
+        assert(PageReserved(p));
+        p->flags = p->property = 0;
+	SetPageProperty(p); //#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
+        set_page_ref(p, 0);
+	list_add_before(&free_list, &(p->page_link));
+    }
+    base->property = n;
+    //SetPageProperty(base);
+    nr_free += n;
+    //list_add(&free_list, &(base->page_link));
+}
+
+static struct Page *
+default_alloc_pages(size_t n) {
+    assert(n > 0);
+    if (n > nr_free) {
+        return NULL;
+    }
+    list_entry_t *le = &free_list;
+    list_entry_t *len;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        if (p->property >= n) {
+		int i;
+		for(i=0;i<n;i++){
+		  len = list_next(le);
+		  struct Page *pp = le2page(le, page_link);
+		  SetPageReserved(pp);
+		  ClearPageProperty(pp);
+		  list_del(le);
+		  le = len;
+		}
+		if(p->property>n){
+		  (le2page(le,page_link))->property = p->property - n;
+		}
+		ClearPageProperty(p);
+		SetPageReserved(p);
+		nr_free -= n;
+		return p;
+        }
+    }
+    return	NULL;
+}
+
+static void
+default_free_pages(struct Page *base, size_t n) {
+    assert(n > 0);
+    assert(PageReserved(base));
+
+    list_entry_t *le = &free_list;
+    struct Page * p;
+    while((le=list_next(le)) != &free_list) {
+      p = le2page(le, page_link);
+      if(p>base){
+        break;
+      }
+    }
+    //list_add_before(le, base->page_link);
+    for(p=base;p<base+n;p++){
+      list_add_before(le, &(p->page_link));
+    }
+    base->flags = 0;
+    set_page_ref(base, 0);
+    ClearPageProperty(base);
+    SetPageProperty(base);
+    base->property = n;
+
+    p = le2page(le,page_link) ;
+    if( base+n == p ){
+      base->property += p->property;
+      p->property = 0;
+    }
+    le = list_prev(&(base->page_link));
+    p = le2page(le, page_link);
+    if(le!=&free_list && p==base-1){
+      while(le!=&free_list){
+        if(p->property){
+          p->property += base->property;
+          base->property = 0;
+          break;
+        }
+        le = list_prev(le);
+        p = le2page(le,page_link);
+      }
+    }
+
+    nr_free += n;
+    return ;
+}
+
+static size_t
+default_nr_free_pages(void) {
+    return nr_free;
+}
+
+static void
+basic_check(void) {
+    struct Page *p0, *p1, *p2;
+    p0 = p1 = p2 = NULL;
+    assert((p0 = alloc_page()) != NULL);
+    assert((p1 = alloc_page()) != NULL);
+    assert((p2 = alloc_page()) != NULL);
+
+    assert(p0 != p1 && p0 != p2 && p1 != p2);
+    assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
+
+    assert(page2pa(p0) < npage * PGSIZE);
+    assert(page2pa(p1) < npage * PGSIZE);
+    assert(page2pa(p2) < npage * PGSIZE);
+
+    list_entry_t free_list_store = free_list;
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+
+    unsigned int nr_free_store = nr_free;
+    nr_free = 0;
+
+    assert(alloc_page() == NULL);
+
+    free_page(p0);
+    free_page(p1);
+    free_page(p2);
+    assert(nr_free == 3);
+
+    assert((p0 = alloc_page()) != NULL);
+    assert((p1 = alloc_page()) != NULL);
+    assert((p2 = alloc_page()) != NULL);
+
+    assert(alloc_page() == NULL);
+
+    free_page(p0);
+    assert(!list_empty(&free_list));
+
+    struct Page *p;
+    assert((p = alloc_page()) == p0);
+    assert(alloc_page() == NULL);
+
+    assert(nr_free == 0);
+    free_list = free_list_store;
+    nr_free = nr_free_store;
+
+    free_page(p);
+    free_page(p1);
+    free_page(p2);
+}
+
+// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+    int count = 0, total = 0;
+    list_entry_t *le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        assert(PageProperty(p));
+        count ++, total += p->property;
+    }
+    assert(total == nr_free_pages());
+
+    basic_check();
+
+    struct Page *p0 = alloc_pages(5), *p1, *p2;
+    assert(p0 != NULL);
+    assert(!PageProperty(p0));
+
+    list_entry_t free_list_store = free_list;
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+    assert(alloc_page() == NULL);
+
+    unsigned int nr_free_store = nr_free;
+    nr_free = 0;
+
+    free_pages(p0 + 2, 3);
+    assert(alloc_pages(4) == NULL);
+    assert(PageProperty(p0 + 2) && p0[2].property == 3);
+    assert((p1 = alloc_pages(3)) != NULL);
+    assert(alloc_page() == NULL);
+    assert(p0 + 2 == p1);
+
+    p2 = p0 + 1;
+    free_page(p0);
+    free_pages(p1, 3);
+    assert(PageProperty(p0) && p0->property == 1);
+    assert(PageProperty(p1) && p1->property == 3);
+
+    assert((p0 = alloc_page()) == p2 - 1);
+    free_page(p0);
+    assert((p0 = alloc_pages(2)) == p2 + 1);
+
+    free_pages(p0, 2);
+    free_page(p2);
+
+    assert((p0 = alloc_pages(5)) != NULL);
+    assert(alloc_page() == NULL);
+
+    assert(nr_free == 0);
+    nr_free = nr_free_store;
+
+    free_list = free_list_store;
+    free_pages(p0, 5);
+
+    le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        count --, total -= p->property;
+    }
+    assert(count == 0);
+    assert(total == 0);
+}
+
+const struct pmm_manager default_pmm_manager = {
+    .name = "default_pmm_manager",
+    .init = default_init,
+    .init_memmap = default_init_memmap,
+    .alloc_pages = default_alloc_pages,
+    .free_pages = default_free_pages,
+    .nr_free_pages = default_nr_free_pages,
+    .check = default_check,
+};
+
diff -r -u -P lab2_origin/kern/mm/default_pmm.c~ lab2/kern/mm/default_pmm.c~
--- lab2_origin/kern/mm/default_pmm.c~	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/mm/default_pmm.c~	2021-08-29 20:47:42.786622427 +0800
@@ -0,0 +1,293 @@
+#include <pmm.h>
+#include <list.h>
+#include <string.h>
+#include <default_pmm.h>
+
+/* In the first fit algorithm, the allocator keeps a list of free blocks (known as the free list) and,
+   on receiving a request for memory, scans along the list for the first block that is large enough to
+   satisfy the request. If the chosen block is significantly larger than that requested, then it is 
+   usually split, and the remainder added to the list as another free block.
+   Please see Page 196~198, Section 8.2 of Yan Wei Ming's chinese book "Data Structure -- C programming language"
+*/
+// LAB2 EXERCISE 1: YOUR CODE
+// you should rewrite functions: default_init,default_init_memmap,default_alloc_pages, default_free_pages.
+/*
+ * Details of FFMA
+ * (1) Prepare: In order to implement the First-Fit Mem Alloc (FFMA), we should manage the free mem block use some list.
+ *              The struct free_area_t is used for the management of free mem blocks. At first you should
+ *              be familiar to the struct list in list.h. struct list is a simple doubly linked list implementation.
+ *              You should know howto USE: list_init, list_add(list_add_after), list_add_before, list_del, list_next, list_prev
+ *              Another tricky method is to transform a general list struct to a special struct (such as struct page):
+ *              you can find some MACRO: le2page (in memlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in proc.h),etc.)
+ * (2) default_init: you can reuse the  demo default_init fun to init the free_list and set nr_free to 0.
+ *              free_list is used to record the free mem blocks. nr_free is the total number for free mem blocks.
+ * (3) default_init_memmap:  CALL GRAPH: kern_init --> pmm_init-->page_init-->init_memmap--> pmm_manager->init_memmap
+ *              This fun is used to init a free block (with parameter: addr_base, page_number).
+ *              First you should init each page (in memlayout.h) in this free block, include:
+ *                  p->flags should be set bit PG_property (means this page is valid. In pmm_init fun (in pmm.c),
+ *                  the bit PG_reserved is setted in p->flags)
+ *                  if this page  is free and is not the first page of free block, p->property should be set to 0.
+ *                  if this page  is free and is the first page of free block, p->property should be set to total num of block.
+ *                  p->ref should be 0, because now p is free and no reference.
+ *                  We can use p->page_link to link this page to free_list, (such as: list_add_before(&free_list, &(p->page_link)); )
+ *              Finally, we should sum the number of free mem block: nr_free+=n
+ * (4) default_alloc_pages: search find a first free block (block size >=n) in free list and reszie the free block, return the addr
+ *              of malloced block.
+ *              (4.1) So you should search freelist like this:
+ *                       list_entry_t le = &free_list;
+ *                       while((le=list_next(le)) != &free_list) {
+ *                       ....
+ *                 (4.1.1) In while loop, get the struct page and check the p->property (record the num of free block) >=n?
+ *                       struct Page *p = le2page(le, page_link);
+ *                       if(p->property >= n){ ...
+ *                 (4.1.2) If we find this p, then it' means we find a free block(block size >=n), and the first n pages can be malloced.
+ *                     Some flag bits of this page should be setted: PG_reserved =1, PG_property =0
+ *                     unlink the pages from free_list
+ *                     (4.1.2.1) If (p->property >n), we should re-caluclate number of the the rest of this free block,
+ *                           (such as: le2page(le,page_link))->property = p->property - n;)
+ *                 (4.1.3)  re-caluclate nr_free (number of the the rest of all free block)
+ *                 (4.1.4)  return p
+ *               (4.2) If we can not find a free block (block size >=n), then return NULL
+ * (5) default_free_pages: relink the pages into  free list, maybe merge small free blocks into big free blocks.
+ *               (5.1) according the base addr of withdrawed blocks, search free list, find the correct position
+ *                     (from low to high addr), and insert the pages. (may use list_next, le2page, list_add_before)
+ *               (5.2) reset the fields of pages, such as p->ref, p->flags (PageProperty)
+ *               (5.3) try to merge low addr or high addr blocks. Notice: should change some pages's p->property correctly.
+ */
+free_area_t free_area;
+
+#define free_list (free_area.free_list)
+#define nr_free (free_area.nr_free)
+
+static void
+default_init(void) {
+    list_init(&free_list);
+    nr_free = 0;
+}
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+    assert(n > 0);
+    struct Page *p = base;
+    for (; p != base + n; p ++) {
+        assert(PageReserved(p));
+        p->flags = p->property = 0;
+	SetPageProperty(p); //#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
+        set_page_ref(p, 0);
+	list_add_before(&free_list, &(p->page_link));
+    }
+    base->property = n;
+    //SetPageProperty(base);
+    nr_free += n;
+    //list_add(&free_list, &(base->page_link));
+}
+
+static struct Page *
+default_alloc_pages(size_t n) {
+    assert(n > 0);
+    if (n > nr_free) {
+        return NULL;
+    }
+    struct Page *page = NULL;
+    list_entry_t *le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        if (p->property >= n) {
+		int i;
+		for(i=0;i<n;i++){
+		  len = list_next(le);
+		  struct Page *pp = le2page(le, page_link);
+		  SetPageReserved(pp);
+		  ClearPageProperty(pp);
+		  list_del(le);
+		  le = len;
+		}
+		if(p->property>n){
+		  (le2page(le,page_link))->property = p->property - n;
+		}
+		ClearPageProperty(p);
+		SetPageReserved(p);
+		nr_free -= n;
+		return p;
+        }
+    }
+    return	NULL;
+}
+
+static void
+default_free_pages(struct Page *base, size_t n) {
+    assert(n > 0);
+    assert(PageReserved(base));
+
+    list_entry_t *le = &free_list;
+    struct Page * p;
+    while((le=list_next(le)) != &free_list) {
+      p = le2page(le, page_link);
+      if(p>base){
+        break;
+      }
+    }
+    //list_add_before(le, base->page_link);
+    for(p=base;p<base+n;p++){
+      list_add_before(le, &(p->page_link));
+    }
+    base->flags = 0;
+    set_page_ref(base, 0);
+    ClearPageProperty(base);
+    SetPageProperty(base);
+    base->property = n;
+
+    p = le2page(le,page_link) ;
+    if( base+n == p ){
+      base->property += p->property;
+      p->property = 0;
+    }
+    le = list_prev(&(base->page_link));
+    p = le2page(le, page_link);
+    if(le!=&free_list && p==base-1){
+      while(le!=&free_list){
+        if(p->property){
+          p->property += base->property;
+          base->property = 0;
+          break;
+        }
+        le = list_prev(le);
+        p = le2page(le,page_link);
+      }
+    }
+
+    nr_free += n;
+    return ;
+}
+
+static size_t
+default_nr_free_pages(void) {
+    return nr_free;
+}
+
+static void
+basic_check(void) {
+    struct Page *p0, *p1, *p2;
+    p0 = p1 = p2 = NULL;
+    assert((p0 = alloc_page()) != NULL);
+    assert((p1 = alloc_page()) != NULL);
+    assert((p2 = alloc_page()) != NULL);
+
+    assert(p0 != p1 && p0 != p2 && p1 != p2);
+    assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
+
+    assert(page2pa(p0) < npage * PGSIZE);
+    assert(page2pa(p1) < npage * PGSIZE);
+    assert(page2pa(p2) < npage * PGSIZE);
+
+    list_entry_t free_list_store = free_list;
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+
+    unsigned int nr_free_store = nr_free;
+    nr_free = 0;
+
+    assert(alloc_page() == NULL);
+
+    free_page(p0);
+    free_page(p1);
+    free_page(p2);
+    assert(nr_free == 3);
+
+    assert((p0 = alloc_page()) != NULL);
+    assert((p1 = alloc_page()) != NULL);
+    assert((p2 = alloc_page()) != NULL);
+
+    assert(alloc_page() == NULL);
+
+    free_page(p0);
+    assert(!list_empty(&free_list));
+
+    struct Page *p;
+    assert((p = alloc_page()) == p0);
+    assert(alloc_page() == NULL);
+
+    assert(nr_free == 0);
+    free_list = free_list_store;
+    nr_free = nr_free_store;
+
+    free_page(p);
+    free_page(p1);
+    free_page(p2);
+}
+
+// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+    int count = 0, total = 0;
+    list_entry_t *le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        assert(PageProperty(p));
+        count ++, total += p->property;
+    }
+    assert(total == nr_free_pages());
+
+    basic_check();
+
+    struct Page *p0 = alloc_pages(5), *p1, *p2;
+    assert(p0 != NULL);
+    assert(!PageProperty(p0));
+
+    list_entry_t free_list_store = free_list;
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+    assert(alloc_page() == NULL);
+
+    unsigned int nr_free_store = nr_free;
+    nr_free = 0;
+
+    free_pages(p0 + 2, 3);
+    assert(alloc_pages(4) == NULL);
+    assert(PageProperty(p0 + 2) && p0[2].property == 3);
+    assert((p1 = alloc_pages(3)) != NULL);
+    assert(alloc_page() == NULL);
+    assert(p0 + 2 == p1);
+
+    p2 = p0 + 1;
+    free_page(p0);
+    free_pages(p1, 3);
+    assert(PageProperty(p0) && p0->property == 1);
+    assert(PageProperty(p1) && p1->property == 3);
+
+    assert((p0 = alloc_page()) == p2 - 1);
+    free_page(p0);
+    assert((p0 = alloc_pages(2)) == p2 + 1);
+
+    free_pages(p0, 2);
+    free_page(p2);
+
+    assert((p0 = alloc_pages(5)) != NULL);
+    assert(alloc_page() == NULL);
+
+    assert(nr_free == 0);
+    nr_free = nr_free_store;
+
+    free_list = free_list_store;
+    free_pages(p0, 5);
+
+    le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        count --, total -= p->property;
+    }
+    assert(count == 0);
+    assert(total == 0);
+}
+
+const struct pmm_manager default_pmm_manager = {
+    .name = "default_pmm_manager",
+    .init = default_init,
+    .init_memmap = default_init_memmap,
+    .alloc_pages = default_alloc_pages,
+    .free_pages = default_free_pages,
+    .nr_free_pages = default_nr_free_pages,
+    .check = default_check,
+};
+
diff -r -u -P lab2_origin/kern/mm/default_pmm.h lab2/kern/mm/default_pmm.h
--- lab2_origin/kern/mm/default_pmm.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/mm/default_pmm.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,9 @@
+#ifndef __KERN_MM_DEFAULT_PMM_H__
+#define  __KERN_MM_DEFAULT_PMM_H__
+
+#include <pmm.h>
+
+extern const struct pmm_manager default_pmm_manager;
+
+#endif /* ! __KERN_MM_DEFAULT_PMM_H__ */
+
diff -r -u -P lab2_origin/kern/mm/memlayout.h lab2/kern/mm/memlayout.h
--- lab2_origin/kern/mm/memlayout.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/mm/memlayout.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,130 @@
+#ifndef __KERN_MM_MEMLAYOUT_H__
+#define __KERN_MM_MEMLAYOUT_H__
+
+/* This file contains the definitions for memory management in our OS. */
+
+/* global segment number */
+#define SEG_KTEXT   1
+#define SEG_KDATA   2
+#define SEG_UTEXT   3
+#define SEG_UDATA   4
+#define SEG_TSS     5
+
+/* global descrptor numbers */
+#define GD_KTEXT    ((SEG_KTEXT) << 3)      // kernel text
+#define GD_KDATA    ((SEG_KDATA) << 3)      // kernel data
+#define GD_UTEXT    ((SEG_UTEXT) << 3)      // user text
+#define GD_UDATA    ((SEG_UDATA) << 3)      // user data
+#define GD_TSS      ((SEG_TSS) << 3)        // task segment selector
+
+#define DPL_KERNEL  (0)
+#define DPL_USER    (3)
+
+#define KERNEL_CS   ((GD_KTEXT) | DPL_KERNEL)
+#define KERNEL_DS   ((GD_KDATA) | DPL_KERNEL)
+#define USER_CS     ((GD_UTEXT) | DPL_USER)
+#define USER_DS     ((GD_UDATA) | DPL_USER)
+
+/* *
+ * Virtual memory map:                                          Permissions
+ *                                                              kernel/user
+ *
+ *     4G ------------------> +---------------------------------+
+ *                            |                                 |
+ *                            |         Empty Memory (*)        |
+ *                            |                                 |
+ *                            +---------------------------------+ 0xFB000000
+ *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE
+ *     VPT -----------------> +---------------------------------+ 0xFAC00000
+ *                            |        Invalid Memory (*)       | --/--
+ *     KERNTOP -------------> +---------------------------------+ 0xF8000000
+ *                            |                                 |
+ *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE
+ *                            |                                 |
+ *     KERNBASE ------------> +---------------------------------+ 0xC0000000
+ *                            |                                 |
+ *                            |                                 |
+ *                            |                                 |
+ *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
+ *     "Empty Memory" is normally unmapped, but user programs may map pages
+ *     there if desired.
+ *
+ * */
+
+/* All physical memory mapped at this address */
+#define KERNBASE            0xC0000000
+#define KMEMSIZE            0x38000000                  // the maximum amount of physical memory
+#define KERNTOP             (KERNBASE + KMEMSIZE)
+
+/* *
+ * Virtual page table. Entry PDX[VPT] in the PD (Page Directory) contains
+ * a pointer to the page directory itself, thereby turning the PD into a page
+ * table, which maps all the PTEs (Page Table Entry) containing the page mappings
+ * for the entire virtual address space into that 4 Meg region starting at VPT.
+ * */
+#define VPT                 0xFAC00000
+
+#define KSTACKPAGE          2                           // # of pages in kernel stack
+#define KSTACKSIZE          (KSTACKPAGE * PGSIZE)       // sizeof kernel stack
+
+#ifndef __ASSEMBLER__
+
+#include <defs.h>
+#include <atomic.h>
+#include <list.h>
+
+typedef uintptr_t pte_t;
+typedef uintptr_t pde_t;
+
+// some constants for bios interrupt 15h AX = 0xE820
+#define E820MAX             20      // number of entries in E820MAP
+#define E820_ARM            1       // address range memory
+#define E820_ARR            2       // address range reserved
+
+struct e820map {
+    int nr_map;
+    struct {
+        uint64_t addr;
+        uint64_t size;
+        uint32_t type;
+    } __attribute__((packed)) map[E820MAX];
+};
+
+/* *
+ * struct Page - Page descriptor structures. Each Page describes one
+ * physical page. In kern/mm/pmm.h, you can find lots of useful functions
+ * that convert Page to other data types, such as phyical address.
+ * */
+struct Page {
+    int ref;                        // page frame's reference counter
+    uint32_t flags;                 // array of flags that describe the status of the page frame
+    unsigned int property;          // the num of free block, used in first fit pm manager
+    list_entry_t page_link;         // free list link
+};
+
+/* Flags describing the status of a page frame */
+#define PG_reserved                 0       // if this bit=1: the Page is reserved for kernel, cannot be used in alloc/free_pages; otherwise, this bit=0 
+#define PG_property                 1       // if this bit=1: the Page is the head page of a free memory block(contains some continuous_addrress pages), and can be used in alloc_pages; if this bit=0: if the Page is the the head page of a free memory block, then this Page and the memory block is alloced. Or this Page isn't the head page.
+
+#define SetPageReserved(page)       set_bit(PG_reserved, &((page)->flags))
+#define ClearPageReserved(page)     clear_bit(PG_reserved, &((page)->flags))
+#define PageReserved(page)          test_bit(PG_reserved, &((page)->flags))
+#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
+#define ClearPageProperty(page)     clear_bit(PG_property, &((page)->flags))
+#define PageProperty(page)          test_bit(PG_property, &((page)->flags))
+
+// convert list entry to page
+#define le2page(le, member)                 \
+    to_struct((le), struct Page, member)
+
+/* free_area_t - maintains a doubly linked list to record free (unused) pages */
+typedef struct {
+    list_entry_t free_list;         // the list header
+    unsigned int nr_free;           // # of free pages in this free list
+} free_area_t;
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* !__KERN_MM_MEMLAYOUT_H__ */
+
diff -r -u -P lab2_origin/kern/mm/mmu.h lab2/kern/mm/mmu.h
--- lab2_origin/kern/mm/mmu.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/mm/mmu.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,272 @@
+#ifndef __KERN_MM_MMU_H__
+#define __KERN_MM_MMU_H__
+
+/* Eflags register */
+#define FL_CF           0x00000001  // Carry Flag
+#define FL_PF           0x00000004  // Parity Flag
+#define FL_AF           0x00000010  // Auxiliary carry Flag
+#define FL_ZF           0x00000040  // Zero Flag
+#define FL_SF           0x00000080  // Sign Flag
+#define FL_TF           0x00000100  // Trap Flag
+#define FL_IF           0x00000200  // Interrupt Flag
+#define FL_DF           0x00000400  // Direction Flag
+#define FL_OF           0x00000800  // Overflow Flag
+#define FL_IOPL_MASK    0x00003000  // I/O Privilege Level bitmask
+#define FL_IOPL_0       0x00000000  //   IOPL == 0
+#define FL_IOPL_1       0x00001000  //   IOPL == 1
+#define FL_IOPL_2       0x00002000  //   IOPL == 2
+#define FL_IOPL_3       0x00003000  //   IOPL == 3
+#define FL_NT           0x00004000  // Nested Task
+#define FL_RF           0x00010000  // Resume Flag
+#define FL_VM           0x00020000  // Virtual 8086 mode
+#define FL_AC           0x00040000  // Alignment Check
+#define FL_VIF          0x00080000  // Virtual Interrupt Flag
+#define FL_VIP          0x00100000  // Virtual Interrupt Pending
+#define FL_ID           0x00200000  // ID flag
+
+/* Application segment type bits */
+#define STA_X           0x8         // Executable segment
+#define STA_E           0x4         // Expand down (non-executable segments)
+#define STA_C           0x4         // Conforming code segment (executable only)
+#define STA_W           0x2         // Writeable (non-executable segments)
+#define STA_R           0x2         // Readable (executable segments)
+#define STA_A           0x1         // Accessed
+
+/* System segment type bits */
+#define STS_T16A        0x1         // Available 16-bit TSS
+#define STS_LDT         0x2         // Local Descriptor Table
+#define STS_T16B        0x3         // Busy 16-bit TSS
+#define STS_CG16        0x4         // 16-bit Call Gate
+#define STS_TG          0x5         // Task Gate / Coum Transmitions
+#define STS_IG16        0x6         // 16-bit Interrupt Gate
+#define STS_TG16        0x7         // 16-bit Trap Gate
+#define STS_T32A        0x9         // Available 32-bit TSS
+#define STS_T32B        0xB         // Busy 32-bit TSS
+#define STS_CG32        0xC         // 32-bit Call Gate
+#define STS_IG32        0xE         // 32-bit Interrupt Gate
+#define STS_TG32        0xF         // 32-bit Trap Gate
+
+#ifdef __ASSEMBLER__
+
+#define SEG_NULL                                                \
+    .word 0, 0;                                                 \
+    .byte 0, 0, 0, 0
+
+#define SEG_ASM(type,base,lim)                                  \
+    .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);          \
+    .byte (((base) >> 16) & 0xff), (0x90 | (type)),             \
+        (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+
+#else /* not __ASSEMBLER__ */
+
+#include <defs.h>
+
+/* Gate descriptors for interrupts and traps */
+struct gatedesc {
+    unsigned gd_off_15_0 : 16;      // low 16 bits of offset in segment
+    unsigned gd_ss : 16;            // segment selector
+    unsigned gd_args : 5;           // # args, 0 for interrupt/trap gates
+    unsigned gd_rsv1 : 3;           // reserved(should be zero I guess)
+    unsigned gd_type : 4;           // type(STS_{TG,IG32,TG32})
+    unsigned gd_s : 1;              // must be 0 (system)
+    unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level
+    unsigned gd_p : 1;              // Present
+    unsigned gd_off_31_16 : 16;     // high bits of offset in segment
+};
+
+/* *
+ * Set up a normal interrupt/trap gate descriptor
+ *   - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate
+ *   - sel: Code segment selector for interrupt/trap handler
+ *   - off: Offset in code segment for interrupt/trap handler
+ *   - dpl: Descriptor Privilege Level - the privilege level required
+ *          for software to invoke this interrupt/trap gate explicitly
+ *          using an int instruction.
+ * */
+#define SETGATE(gate, istrap, sel, off, dpl) {               \
+        (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
+        (gate).gd_ss = (sel);                                \
+        (gate).gd_args = 0;                                 \
+        (gate).gd_rsv1 = 0;                                 \
+        (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \
+        (gate).gd_s = 0;                                    \
+        (gate).gd_dpl = (dpl);                              \
+        (gate).gd_p = 1;                                    \
+        (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
+    }
+
+/* Set up a call gate descriptor */
+#define SETCALLGATE(gate, ss, off, dpl) {                   \
+        (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
+        (gate).gd_ss = (ss);                                \
+        (gate).gd_args = 0;                                 \
+        (gate).gd_rsv1 = 0;                                 \
+        (gate).gd_type = STS_CG32;                          \
+        (gate).gd_s = 0;                                    \
+        (gate).gd_dpl = (dpl);                              \
+        (gate).gd_p = 1;                                    \
+        (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
+    }
+
+/* segment descriptors */
+struct segdesc {
+    unsigned sd_lim_15_0 : 16;      // low bits of segment limit
+    unsigned sd_base_15_0 : 16;     // low bits of segment base address
+    unsigned sd_base_23_16 : 8;     // middle bits of segment base address
+    unsigned sd_type : 4;           // segment type (see STS_ constants)
+    unsigned sd_s : 1;              // 0 = system, 1 = application
+    unsigned sd_dpl : 2;            // descriptor Privilege Level
+    unsigned sd_p : 1;              // present
+    unsigned sd_lim_19_16 : 4;      // high bits of segment limit
+    unsigned sd_avl : 1;            // unused (available for software use)
+    unsigned sd_rsv1 : 1;           // reserved
+    unsigned sd_db : 1;             // 0 = 16-bit segment, 1 = 32-bit segment
+    unsigned sd_g : 1;              // granularity: limit scaled by 4K when set
+    unsigned sd_base_31_24 : 8;     // high bits of segment base address
+};
+
+#define SEG_NULL                                            \
+    (struct segdesc) {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+
+#define SEG(type, base, lim, dpl)                           \
+    (struct segdesc) {                                      \
+        ((lim) >> 12) & 0xffff, (base) & 0xffff,            \
+        ((base) >> 16) & 0xff, type, 1, dpl, 1,             \
+        (unsigned)(lim) >> 28, 0, 0, 1, 1,                  \
+        (unsigned) (base) >> 24                             \
+    }
+
+#define SEGTSS(type, base, lim, dpl)                        \
+    (struct segdesc) {                                      \
+        (lim) & 0xffff, (base) & 0xffff,                    \
+        ((base) >> 16) & 0xff, type, 0, dpl, 1,             \
+        (unsigned) (lim) >> 16, 0, 0, 1, 0,                 \
+        (unsigned) (base) >> 24                             \
+    }
+
+/* task state segment format (as described by the Pentium architecture book) */
+struct taskstate {
+    uint32_t ts_link;       // old ts selector
+    uintptr_t ts_esp0;      // stack pointers and segment selectors
+    uint16_t ts_ss0;        // after an increase in privilege level
+    uint16_t ts_padding1;
+    uintptr_t ts_esp1;
+    uint16_t ts_ss1;
+    uint16_t ts_padding2;
+    uintptr_t ts_esp2;
+    uint16_t ts_ss2;
+    uint16_t ts_padding3;
+    uintptr_t ts_cr3;       // page directory base
+    uintptr_t ts_eip;       // saved state from last task switch
+    uint32_t ts_eflags;
+    uint32_t ts_eax;        // more saved state (registers)
+    uint32_t ts_ecx;
+    uint32_t ts_edx;
+    uint32_t ts_ebx;
+    uintptr_t ts_esp;
+    uintptr_t ts_ebp;
+    uint32_t ts_esi;
+    uint32_t ts_edi;
+    uint16_t ts_es;         // even more saved state (segment selectors)
+    uint16_t ts_padding4;
+    uint16_t ts_cs;
+    uint16_t ts_padding5;
+    uint16_t ts_ss;
+    uint16_t ts_padding6;
+    uint16_t ts_ds;
+    uint16_t ts_padding7;
+    uint16_t ts_fs;
+    uint16_t ts_padding8;
+    uint16_t ts_gs;
+    uint16_t ts_padding9;
+    uint16_t ts_ldt;
+    uint16_t ts_padding10;
+    uint16_t ts_t;          // trap on task switch
+    uint16_t ts_iomb;       // i/o map base address
+} __attribute__((packed));
+
+#endif /* !__ASSEMBLER__ */
+
+// A linear address 'la' has a three-part structure as follows:
+//
+// +--------10------+-------10-------+---------12----------+
+// | Page Directory |   Page Table   | Offset within Page  |
+// |      Index     |     Index      |                     |
+// +----------------+----------------+---------------------+
+//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
+//  \----------- PPN(la) -----------/
+//
+// The PDX, PTX, PGOFF, and PPN macros decompose linear addresses as shown.
+// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),
+// use PGADDR(PDX(la), PTX(la), PGOFF(la)).
+
+// page directory index
+#define PDX(la) ((((uintptr_t)(la)) >> PDXSHIFT) & 0x3FF)
+
+// page table index
+#define PTX(la) ((((uintptr_t)(la)) >> PTXSHIFT) & 0x3FF)
+
+// page number field of address
+#define PPN(la) (((uintptr_t)(la)) >> PTXSHIFT)
+
+// offset in page
+#define PGOFF(la) (((uintptr_t)(la)) & 0xFFF)
+
+// construct linear address from indexes and offset
+#define PGADDR(d, t, o) ((uintptr_t)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
+
+// address in page table or page directory entry
+#define PTE_ADDR(pte)   ((uintptr_t)(pte) & ~0xFFF)
+#define PDE_ADDR(pde)   PTE_ADDR(pde)
+
+/* page directory and page table constants */
+#define NPDEENTRY       1024                    // page directory entries per page directory
+#define NPTEENTRY       1024                    // page table entries per page table
+
+#define PGSIZE          4096                    // bytes mapped by a page
+#define PGSHIFT         12                      // log2(PGSIZE)
+#define PTSIZE          (PGSIZE * NPTEENTRY)    // bytes mapped by a page directory entry
+#define PTSHIFT         22                      // log2(PTSIZE)
+
+#define PTXSHIFT        12                      // offset of PTX in a linear address
+#define PDXSHIFT        22                      // offset of PDX in a linear address
+
+/* page table/directory entry flags */
+#define PTE_P           0x001                   // Present
+#define PTE_W           0x002                   // Writeable
+#define PTE_U           0x004                   // User
+#define PTE_PWT         0x008                   // Write-Through
+#define PTE_PCD         0x010                   // Cache-Disable
+#define PTE_A           0x020                   // Accessed
+#define PTE_D           0x040                   // Dirty
+#define PTE_PS          0x080                   // Page Size
+#define PTE_MBZ         0x180                   // Bits must be zero
+#define PTE_AVAIL       0xE00                   // Available for software use
+                                                // The PTE_AVAIL bits aren't used by the kernel or interpreted by the
+                                                // hardware, so user processes are allowed to set them arbitrarily.
+
+#define PTE_USER        (PTE_U | PTE_W | PTE_P)
+
+/* Control Register flags */
+#define CR0_PE          0x00000001              // Protection Enable
+#define CR0_MP          0x00000002              // Monitor coProcessor
+#define CR0_EM          0x00000004              // Emulation
+#define CR0_TS          0x00000008              // Task Switched
+#define CR0_ET          0x00000010              // Extension Type
+#define CR0_NE          0x00000020              // Numeric Errror
+#define CR0_WP          0x00010000              // Write Protect
+#define CR0_AM          0x00040000              // Alignment Mask
+#define CR0_NW          0x20000000              // Not Writethrough
+#define CR0_CD          0x40000000              // Cache Disable
+#define CR0_PG          0x80000000              // Paging
+
+#define CR4_PCE         0x00000100              // Performance counter enable
+#define CR4_MCE         0x00000040              // Machine Check Enable
+#define CR4_PSE         0x00000010              // Page Size Extensions
+#define CR4_DE          0x00000008              // Debugging Extensions
+#define CR4_TSD         0x00000004              // Time Stamp Disable
+#define CR4_PVI         0x00000002              // Protected-Mode Virtual Interrupts
+#define CR4_VME         0x00000001              // V86 Mode Extensions
+
+#endif /* !__KERN_MM_MMU_H__ */
+
diff -r -u -P lab2_origin/kern/mm/pmm.c lab2/kern/mm/pmm.c
--- lab2_origin/kern/mm/pmm.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/mm/pmm.c	2021-08-30 16:06:32.416911096 +0800
@@ -0,0 +1,627 @@
+#include <defs.h>
+#include <x86.h>
+#include <stdio.h>
+#include <string.h>
+#include <mmu.h>
+#include <memlayout.h>
+#include <pmm.h>
+#include <default_pmm.h>
+#include <sync.h>
+#include <error.h>
+
+/* *
+ * Task State Segment:
+ *
+ * The TSS may reside anywhere in memory. A special segment register called
+ * the Task Register (TR) holds a segment selector that points a valid TSS
+ * segment descriptor which resides in the GDT. Therefore, to use a TSS
+ * the following must be done in function gdt_init:
+ *   - create a TSS descriptor entry in GDT
+ *   - add enough information to the TSS in memory as needed
+ *   - load the TR register with a segment selector for that segment
+ *
+ * There are several fileds in TSS for specifying the new stack pointer when a
+ * privilege level change happens. But only the fields SS0 and ESP0 are useful
+ * in our os kernel.
+ *
+ * The field SS0 contains the stack segment selector for CPL = 0, and the ESP0
+ * contains the new ESP value for CPL = 0. When an interrupt happens in protected
+ * mode, the x86 CPU will look in the TSS for SS0 and ESP0 and load their value
+ * into SS and ESP respectively.
+ * */
+static struct taskstate ts = {0};
+
+// virtual address of physicall page array
+struct Page *pages;
+// amount of physical memory (in pages)
+size_t npage = 0;
+
+// virtual address of boot-time page directory
+pde_t *boot_pgdir = NULL;
+// physical address of boot-time page directory
+uintptr_t boot_cr3;
+
+// physical memory management
+const struct pmm_manager *pmm_manager;
+
+/* *
+ * The page directory entry corresponding to the virtual address range
+ * [VPT, VPT + PTSIZE) points to the page directory itself. Thus, the page
+ * directory is treated as a page table as well as a page directory.
+ *
+ * One result of treating the page directory as a page table is that all PTEs
+ * can be accessed though a "virtual page table" at virtual address VPT. And the
+ * PTE for number n is stored in vpt[n].
+ *
+ * A second consequence is that the contents of the current page directory will
+ * always available at virtual address PGADDR(PDX(VPT), PDX(VPT), 0), to which
+ * vpd is set bellow.
+ * */
+pte_t * const vpt = (pte_t *)VPT;
+pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
+
+/* *
+ * Global Descriptor Table:
+ *
+ * The kernel and user segments are identical (except for the DPL). To load
+ * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the
+ * segments for the user and the kernel. Defined as follows:
+ *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)
+ *   - 0x8 :  kernel code segment
+ *   - 0x10:  kernel data segment
+ *   - 0x18:  user code segment
+ *   - 0x20:  user data segment
+ *   - 0x28:  defined for tss, initialized in gdt_init
+ * */
+static struct segdesc gdt[] = {
+    SEG_NULL,
+    [SEG_KTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL),
+    [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
+    [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
+    [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
+    [SEG_TSS]   = SEG_NULL,
+};
+
+static struct pseudodesc gdt_pd = {
+    sizeof(gdt) - 1, (uintptr_t)gdt
+};
+
+static void check_alloc_page(void);
+static void check_pgdir(void);
+static void check_boot_pgdir(void);
+
+/* *
+ * lgdt - load the global descriptor table register and reset the
+ * data/code segement registers for kernel.
+ * */
+static inline void
+lgdt(struct pseudodesc *pd) {
+    asm volatile ("lgdt (%0)" :: "r" (pd));
+    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
+    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
+    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
+    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
+    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+    // reload cs
+    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+}
+
+/* *
+ * load_esp0 - change the ESP0 in default task state segment,
+ * so that we can use different kernel stack when we trap frame
+ * user to kernel.
+ * */
+void
+load_esp0(uintptr_t esp0) {
+    ts.ts_esp0 = esp0;
+}
+
+/* gdt_init - initialize the default GDT and TSS */
+static void
+gdt_init(void) {
+    // set boot kernel stack and default SS0
+    load_esp0((uintptr_t)bootstacktop);
+    ts.ts_ss0 = KERNEL_DS;
+
+    // initialize the TSS filed of the gdt
+    gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
+
+    // reload all segment registers
+    lgdt(&gdt_pd);
+
+    // load the TSS
+    ltr(GD_TSS);
+}
+
+//init_pmm_manager - initialize a pmm_manager instance
+static void
+init_pmm_manager(void) {
+    pmm_manager = &default_pmm_manager;
+    cprintf("memory management: %s\n", pmm_manager->name);
+    pmm_manager->init();
+}
+
+//init_memmap - call pmm->init_memmap to build Page struct for free memory  
+static void
+init_memmap(struct Page *base, size_t n) {
+    pmm_manager->init_memmap(base, n);
+}
+
+//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
+struct Page *
+alloc_pages(size_t n) {
+    struct Page *page=NULL;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        page = pmm_manager->alloc_pages(n);
+    }
+    local_intr_restore(intr_flag);
+    return page;
+}
+
+//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
+void
+free_pages(struct Page *base, size_t n) {
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        pmm_manager->free_pages(base, n);
+    }
+    local_intr_restore(intr_flag);
+}
+
+//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
+//of current free memory
+size_t
+nr_free_pages(void) {
+    size_t ret;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        ret = pmm_manager->nr_free_pages();
+    }
+    local_intr_restore(intr_flag);
+    return ret;
+}
+
+/* pmm_init - initialize the physical memory management */
+static void
+page_init(void) {
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+    uint64_t maxpa = 0;
+
+    cprintf("e820map:\n");
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+        cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
+                memmap->map[i].size, begin, end - 1, memmap->map[i].type);
+        if (memmap->map[i].type == E820_ARM) {
+            if (maxpa < end && begin < KMEMSIZE) {
+                maxpa = end;
+            }
+        }
+    }
+    if (maxpa > KMEMSIZE) {
+        maxpa = KMEMSIZE;
+    }
+
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+
+    for (i = 0; i < npage; i ++) {
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+        if (memmap->map[i].type == E820_ARM) {
+            if (begin < freemem) {
+                begin = freemem;
+            }
+            if (end > KMEMSIZE) {
+                end = KMEMSIZE;
+            }
+            if (begin < end) {
+                begin = ROUNDUP(begin, PGSIZE);
+                end = ROUNDDOWN(end, PGSIZE);
+                if (begin < end) {
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+                }
+            }
+        }
+    }
+}
+
+static void
+enable_paging(void) {
+    lcr3(boot_cr3);
+
+    // turn on paging
+    uint32_t cr0 = rcr0();
+    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP;
+    cr0 &= ~(CR0_TS | CR0_EM);
+    lcr0(cr0);
+}
+
+//boot_map_segment - setup&enable the paging mechanism
+// parameters
+//  la:   linear address of this memory need to map (after x86 segment map)
+//  size: memory size
+//  pa:   physical address of this memory
+//  perm: permission of this memory  
+static void
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+    assert(PGOFF(la) == PGOFF(pa));
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+    la = ROUNDDOWN(la, PGSIZE);
+    pa = ROUNDDOWN(pa, PGSIZE);
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+        pte_t *ptep = get_pte(pgdir, la, 1);
+        assert(ptep != NULL);
+        *ptep = pa | PTE_P | perm;
+    }
+}
+
+//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
+// return value: the kernel virtual address of this allocated page
+//note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
+static void *
+boot_alloc_page(void) {
+    struct Page *p = alloc_page();
+    if (p == NULL) {
+        panic("boot_alloc_page failed.\n");
+    }
+    return page2kva(p);
+}
+
+//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
+//         - check the correctness of pmm & paging mechanism, print PDT&PT
+void
+pmm_init(void) {
+    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
+    //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
+    //First we should init a physical memory manager(pmm) based on the framework.
+    //Then pmm can alloc/free the physical memory. 
+    //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
+    init_pmm_manager();
+
+    // detect physical memory space, reserve already used memory,
+    // then use pmm->init_memmap to create free page list
+    page_init();
+
+    //use pmm->check to verify the correctness of the alloc/free function in a pmm
+    check_alloc_page();
+
+    // create boot_pgdir, an initial page directory(Page Directory Table, PDT)
+    boot_pgdir = boot_alloc_page();
+    memset(boot_pgdir, 0, PGSIZE);
+    boot_cr3 = PADDR(boot_pgdir);
+
+    check_pgdir();
+
+    static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
+
+    // recursively insert boot_pgdir in itself
+    // to form a virtual page table at virtual address VPT
+    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
+
+    // map all physical memory to linear memory with base linear addr KERNBASE
+    //linear_addr KERNBASE~KERNBASE+KMEMSIZE = phy_addr 0~KMEMSIZE
+    //But shouldn't use this map until enable_paging() & gdt_init() finished.
+    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
+
+    //temporary map: 
+    //virtual_addr 3G~3G+4M = linear_addr 0~4M = linear_addr 3G~3G+4M = phy_addr 0~4M     
+    boot_pgdir[0] = boot_pgdir[PDX(KERNBASE)];
+
+    enable_paging();
+
+    //reload gdt(third time,the last time) to map all physical memory
+    //virtual_addr 0~4G=liear_addr 0~4G
+    //then set kernel stack(ss:esp) in TSS, setup TSS in gdt, load TSS
+    gdt_init();
+
+    //disable the map of virtual_addr 0~4M
+    boot_pgdir[0] = 0;
+
+    //now the basic virtual memory map(see memalyout.h) is established.
+    //check the correctness of the basic virtual memory map.
+    check_boot_pgdir();
+
+    print_pgdir();
+
+}
+
+//get_pte - get pte and return the kernel virtual address of this pte for la
+//        - if the PT contians this pte didn't exist, alloc a page for PT
+// parameter:
+//  pgdir:  the kernel virtual base address of PDT
+//  la:     the linear address need to map
+//  create: a logical value to decide if alloc a page for PT
+// return vaule: the kernel virtual address of this pte
+pte_t *
+get_pte(pde_t *pgdir, uintptr_t la, bool create) {
+    /* LAB2 EXERCISE 2: YOUR CODE
+     *
+     * If you need to visit a physical address, please use KADDR()
+     * please read pmm.h for useful macros
+     *
+     * Maybe you want help comment, BELOW comments can help you finish the code
+     *
+     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+     * MACROs or Functions:
+     *   PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la.
+     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.
+     *   set_page_ref(page,1) : means the page be referenced by one time
+     *   page2pa(page): get the physical address of memory which this (struct Page *) page  manages
+     *   struct Page * alloc_page() : allocation a page
+     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s
+     *                                       to the specified value c.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
+     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+     */
+#if 0
+    pde_t *pdep = NULL;   // (1) find page directory entry
+    if (0) {              // (2) check if entry is not present
+                          // (3) check if creating is needed, then alloc page for page table
+                          // CAUTION: this page is used for page table, not for common data page
+                          // (4) set page reference
+        uintptr_t pa = 0; // (5) get linear address of page
+                          // (6) clear page content using memset
+                          // (7) set page directory entry's permission
+    }
+    return NULL;          // (8) return page table entry
+#endif
+}
+
+//get_page - get related Page struct for linear address la using PDT pgdir
+struct Page *
+get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
+    pte_t *ptep = get_pte(pgdir, la, 0);
+    if (ptep_store != NULL) {
+        *ptep_store = ptep;
+    }
+    if (ptep != NULL && *ptep & PTE_P) {
+        return pa2page(*ptep);
+    }
+    return NULL;
+}
+
+//page_remove_pte - free an Page sturct which is related linear address la
+//                - and clean(invalidate) pte which is related linear address la
+//note: PT is changed, so the TLB need to be invalidate 
+static inline void
+page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
+    /* LAB2 EXERCISE 3: YOUR CODE
+     *
+     * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
+     *
+     * Maybe you want help comment, BELOW comments can help you finish the code
+     *
+     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+     * MACROs or Functions:
+     *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep
+     *   free_page : free a page
+     *   page_ref_dec(page) : decrease page->ref. NOTICE: ff page->ref == 0 , then this page should be free.
+     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being
+     *                        edited are the ones currently in use by the processor.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     */
+#if 0
+    if (0) {                      //(1) check if this page table entry is present
+        struct Page *page = NULL; //(2) find corresponding page to pte
+                                  //(3) decrease page reference
+                                  //(4) and free this page when page reference reachs 0
+                                  //(5) clear second page table entry
+                                  //(6) flush tlb
+    }
+#endif
+}
+
+//page_remove - free an Page which is related linear address la and has an validated pte
+void
+page_remove(pde_t *pgdir, uintptr_t la) {
+    pte_t *ptep = get_pte(pgdir, la, 0);
+    if (ptep != NULL) {
+        page_remove_pte(pgdir, la, ptep);
+    }
+}
+
+//page_insert - build the map of phy addr of an Page with the linear addr la
+// paramemters:
+//  pgdir: the kernel virtual base address of PDT
+//  page:  the Page which need to map
+//  la:    the linear address need to map
+//  perm:  the permission of this Page which is setted in related pte
+// return value: always 0
+//note: PT is changed, so the TLB need to be invalidate 
+int
+page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
+    pte_t *ptep = get_pte(pgdir, la, 1);
+    if (ptep == NULL) {
+        return -E_NO_MEM;
+    }
+    page_ref_inc(page);
+    if (*ptep & PTE_P) {
+        struct Page *p = pte2page(*ptep);
+        if (p == page) {
+            page_ref_dec(page);
+        }
+        else {
+            page_remove_pte(pgdir, la, ptep);
+        }
+    }
+    *ptep = page2pa(page) | PTE_P | perm;
+    tlb_invalidate(pgdir, la);
+    return 0;
+}
+
+// invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+void
+tlb_invalidate(pde_t *pgdir, uintptr_t la) {
+    if (rcr3() == PADDR(pgdir)) {
+        invlpg((void *)la);
+    }
+}
+
+static void
+check_alloc_page(void) {
+    pmm_manager->check();
+    cprintf("check_alloc_page() succeeded!\n");
+}
+
+static void
+check_pgdir(void) {
+    assert(npage <= KMEMSIZE / PGSIZE);
+    assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
+    assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
+
+    struct Page *p1, *p2;
+    p1 = alloc_page();
+    assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
+
+    pte_t *ptep;
+    assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
+    assert(pa2page(*ptep) == p1);
+    assert(page_ref(p1) == 1);
+
+    ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
+    assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
+
+    p2 = alloc_page();
+    assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+    assert(*ptep & PTE_U);
+    assert(*ptep & PTE_W);
+    assert(boot_pgdir[0] & PTE_U);
+    assert(page_ref(p2) == 1);
+
+    assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
+    assert(page_ref(p1) == 2);
+    assert(page_ref(p2) == 0);
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+    assert(pa2page(*ptep) == p1);
+    assert((*ptep & PTE_U) == 0);
+
+    page_remove(boot_pgdir, 0x0);
+    assert(page_ref(p1) == 1);
+    assert(page_ref(p2) == 0);
+
+    page_remove(boot_pgdir, PGSIZE);
+    assert(page_ref(p1) == 0);
+    assert(page_ref(p2) == 0);
+
+    assert(page_ref(pa2page(boot_pgdir[0])) == 1);
+    free_page(pa2page(boot_pgdir[0]));
+    boot_pgdir[0] = 0;
+
+    cprintf("check_pgdir() succeeded!\n");
+}
+
+static void
+check_boot_pgdir(void) {
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+        assert(PTE_ADDR(*ptep) == i);
+    }
+
+    assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
+
+    assert(boot_pgdir[0] == 0);
+
+    struct Page *p;
+    p = alloc_page();
+    assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
+    assert(page_ref(p) == 1);
+    assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
+    assert(page_ref(p) == 2);
+
+    const char *str = "ucore: Hello world!!";
+    strcpy((void *)0x100, str);
+    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
+
+    *(char *)(page2kva(p) + 0x100) = '\0';
+    assert(strlen((const char *)0x100) == 0);
+
+    free_page(p);
+    free_page(pa2page(PDE_ADDR(boot_pgdir[0])));
+    boot_pgdir[0] = 0;
+
+    cprintf("check_boot_pgdir() succeeded!\n");
+}
+
+//perm2str - use string 'u,r,w,-' to present the permission
+static const char *
+perm2str(int perm) {
+    static char str[4];
+    str[0] = (perm & PTE_U) ? 'u' : '-';
+    str[1] = 'r';
+    str[2] = (perm & PTE_W) ? 'w' : '-';
+    str[3] = '\0';
+    return str;
+}
+
+//get_pgtable_items - In [left, right] range of PDT or PT, find a continuous linear addr space
+//                  - (left_store*X_SIZE~right_store*X_SIZE) for PDT or PT
+//                  - X_SIZE=PTSIZE=4M, if PDT; X_SIZE=PGSIZE=4K, if PT
+// paramemters:
+//  left:        no use ???
+//  right:       the high side of table's range
+//  start:       the low side of table's range
+//  table:       the beginning addr of table
+//  left_store:  the pointer of the high side of table's next range
+//  right_store: the pointer of the low side of table's next range
+// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+    if (start >= right) {
+        return 0;
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+        start ++;
+    }
+    if (start < right) {
+        if (left_store != NULL) {
+            *left_store = start;
+        }
+        int perm = (table[start ++] & PTE_USER);
+        while (start < right && (table[start] & PTE_USER) == perm) {
+            start ++;
+        }
+        if (right_store != NULL) {
+            *right_store = start;
+        }
+        return perm;
+    }
+    return 0;
+}
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+        }
+    }
+    cprintf("--------------------- END ---------------------\n");
+}
+
diff -r -u -P lab2_origin/kern/mm/pmm.c~ lab2/kern/mm/pmm.c~
--- lab2_origin/kern/mm/pmm.c~	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/mm/pmm.c~	2021-08-29 21:34:23.450605308 +0800
@@ -0,0 +1,635 @@
+#include <defs.h>
+#include <x86.h>
+#include <stdio.h>
+#include <string.h>
+#include <mmu.h>
+#include <memlayout.h>
+#include <pmm.h>
+#include <default_pmm.h>
+#include <sync.h>
+#include <error.h>
+
+/* *
+ * Task State Segment:
+ *
+ * The TSS may reside anywhere in memory. A special segment register called
+ * the Task Register (TR) holds a segment selector that points a valid TSS
+ * segment descriptor which resides in the GDT. Therefore, to use a TSS
+ * the following must be done in function gdt_init:
+ *   - create a TSS descriptor entry in GDT
+ *   - add enough information to the TSS in memory as needed
+ *   - load the TR register with a segment selector for that segment
+ *
+ * There are several fileds in TSS for specifying the new stack pointer when a
+ * privilege level change happens. But only the fields SS0 and ESP0 are useful
+ * in our os kernel.
+ *
+ * The field SS0 contains the stack segment selector for CPL = 0, and the ESP0
+ * contains the new ESP value for CPL = 0. When an interrupt happens in protected
+ * mode, the x86 CPU will look in the TSS for SS0 and ESP0 and load their value
+ * into SS and ESP respectively.
+ * */
+static struct taskstate ts = {0};
+
+// virtual address of physicall page array
+struct Page *pages;
+// amount of physical memory (in pages)
+size_t npage = 0;
+
+// virtual address of boot-time page directory
+pde_t *boot_pgdir = NULL;
+// physical address of boot-time page directory
+uintptr_t boot_cr3;
+
+// physical memory management
+const struct pmm_manager *pmm_manager;
+
+/* *
+ * The page directory entry corresponding to the virtual address range
+ * [VPT, VPT + PTSIZE) points to the page directory itself. Thus, the page
+ * directory is treated as a page table as well as a page directory.
+ *
+ * One result of treating the page directory as a page table is that all PTEs
+ * can be accessed though a "virtual page table" at virtual address VPT. And the
+ * PTE for number n is stored in vpt[n].
+ *
+ * A second consequence is that the contents of the current page directory will
+ * always available at virtual address PGADDR(PDX(VPT), PDX(VPT), 0), to which
+ * vpd is set bellow.
+ * */
+pte_t * const vpt = (pte_t *)VPT;
+pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
+
+/* *
+ * Global Descriptor Table:
+ *
+ * The kernel and user segments are identical (except for the DPL). To load
+ * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the
+ * segments for the user and the kernel. Defined as follows:
+ *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)
+ *   - 0x8 :  kernel code segment
+ *   - 0x10:  kernel data segment
+ *   - 0x18:  user code segment
+ *   - 0x20:  user data segment
+ *   - 0x28:  defined for tss, initialized in gdt_init
+ * */
+static struct segdesc gdt[] = {
+    SEG_NULL,
+    [SEG_KTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL),
+    [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
+    [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
+    [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
+    [SEG_TSS]   = SEG_NULL,
+};
+
+static struct pseudodesc gdt_pd = {
+    sizeof(gdt) - 1, (uintptr_t)gdt
+};
+
+static void check_alloc_page(void);
+static void check_pgdir(void);
+static void check_boot_pgdir(void);
+
+/* *
+ * lgdt - load the global descriptor table register and reset the
+ * data/code segement registers for kernel.
+ * */
+static inline void
+lgdt(struct pseudodesc *pd) {
+    asm volatile ("lgdt (%0)" :: "r" (pd));
+    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
+    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
+    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
+    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
+    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+    // reload cs
+    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+}
+
+/* *
+ * load_esp0 - change the ESP0 in default task state segment,
+ * so that we can use different kernel stack when we trap frame
+ * user to kernel.
+ * */
+void
+load_esp0(uintptr_t esp0) {
+    ts.ts_esp0 = esp0;
+}
+
+/* gdt_init - initialize the default GDT and TSS */
+static void
+gdt_init(void) {
+    // set boot kernel stack and default SS0
+    load_esp0((uintptr_t)bootstacktop);
+    ts.ts_ss0 = KERNEL_DS;
+
+    // initialize the TSS filed of the gdt
+    gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
+
+    // reload all segment registers
+    lgdt(&gdt_pd);
+
+    // load the TSS
+    ltr(GD_TSS);
+}
+
+//init_pmm_manager - initialize a pmm_manager instance
+static void
+init_pmm_manager(void) {
+    pmm_manager = &default_pmm_manager;
+    cprintf("memory management: %s\n", pmm_manager->name);
+    pmm_manager->init();
+}
+
+//init_memmap - call pmm->init_memmap to build Page struct for free memory  
+static void
+init_memmap(struct Page *base, size_t n) {
+    pmm_manager->init_memmap(base, n);
+}
+
+//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
+struct Page *
+alloc_pages(size_t n) {
+    struct Page *page=NULL;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        page = pmm_manager->alloc_pages(n);
+    }
+    local_intr_restore(intr_flag);
+    return page;
+}
+
+//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
+void
+free_pages(struct Page *base, size_t n) {
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        pmm_manager->free_pages(base, n);
+    }
+    local_intr_restore(intr_flag);
+}
+
+//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
+//of current free memory
+size_t
+nr_free_pages(void) {
+    size_t ret;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+    {
+        ret = pmm_manager->nr_free_pages();
+    }
+    local_intr_restore(intr_flag);
+    return ret;
+}
+
+/* pmm_init - initialize the physical memory management */
+static void
+page_init(void) {
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+    uint64_t maxpa = 0;
+
+    cprintf("e820map:\n");
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+        cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
+                memmap->map[i].size, begin, end - 1, memmap->map[i].type);
+        if (memmap->map[i].type == E820_ARM) {
+            if (maxpa < end && begin < KMEMSIZE) {
+                maxpa = end;
+            }
+        }
+    }
+    if (maxpa > KMEMSIZE) {
+        maxpa = KMEMSIZE;
+    }
+
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+
+    for (i = 0; i < npage; i ++) {
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+        if (memmap->map[i].type == E820_ARM) {
+            if (begin < freemem) {
+                begin = freemem;
+            }
+            if (end > KMEMSIZE) {
+                end = KMEMSIZE;
+            }
+            if (begin < end) {
+                begin = ROUNDUP(begin, PGSIZE);
+                end = ROUNDDOWN(end, PGSIZE);
+                if (begin < end) {
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+                }
+            }
+        }
+    }
+}
+
+static void
+enable_paging(void) {
+    lcr3(boot_cr3);
+
+    // turn on paging
+    uint32_t cr0 = rcr0();
+    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP;
+    cr0 &= ~(CR0_TS | CR0_EM);
+    lcr0(cr0);
+}
+
+//boot_map_segment - setup&enable the paging mechanism
+// parameters
+//  la:   linear address of this memory need to map (after x86 segment map)
+//  size: memory size
+//  pa:   physical address of this memory
+//  perm: permission of this memory  
+static void
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+    assert(PGOFF(la) == PGOFF(pa));
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+    la = ROUNDDOWN(la, PGSIZE);
+    pa = ROUNDDOWN(pa, PGSIZE);
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+        pte_t *ptep = get_pte(pgdir, la, 1);
+        assert(ptep != NULL);
+        *ptep = pa | PTE_P | perm;
+    }
+}
+
+//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
+// return value: the kernel virtual address of this allocated page
+//note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
+static void *
+boot_alloc_page(void) {
+    struct Page *p = alloc_page();
+    if (p == NULL) {
+        panic("boot_alloc_page failed.\n");
+    }
+    return page2kva(p);
+}
+
+//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
+//         - check the correctness of pmm & paging mechanism, print PDT&PT
+void
+pmm_init(void) {
+    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
+    //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
+    //First we should init a physical memory manager(pmm) based on the framework.
+    //Then pmm can alloc/free the physical memory. 
+    //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
+    init_pmm_manager();
+
+    // detect physical memory space, reserve already used memory,
+    // then use pmm->init_memmap to create free page list
+    page_init();
+
+    //use pmm->check to verify the correctness of the alloc/free function in a pmm
+    check_alloc_page();
+
+    // create boot_pgdir, an initial page directory(Page Directory Table, PDT)
+    boot_pgdir = boot_alloc_page();
+    memset(boot_pgdir, 0, PGSIZE);
+    boot_cr3 = PADDR(boot_pgdir);
+
+    check_pgdir();
+
+    static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
+
+    // recursively insert boot_pgdir in itself
+    // to form a virtual page table at virtual address VPT
+    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
+
+    // map all physical memory to linear memory with base linear addr KERNBASE
+    //linear_addr KERNBASE~KERNBASE+KMEMSIZE = phy_addr 0~KMEMSIZE
+    //But shouldn't use this map until enable_paging() & gdt_init() finished.
+    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
+
+    //temporary map: 
+    //virtual_addr 3G~3G+4M = linear_addr 0~4M = linear_addr 3G~3G+4M = phy_addr 0~4M     
+    boot_pgdir[0] = boot_pgdir[PDX(KERNBASE)];
+
+    enable_paging();
+
+    //reload gdt(third time,the last time) to map all physical memory
+    //virtual_addr 0~4G=liear_addr 0~4G
+    //then set kernel stack(ss:esp) in TSS, setup TSS in gdt, load TSS
+    gdt_init();
+
+    //disable the map of virtual_addr 0~4M
+    boot_pgdir[0] = 0;
+
+    //now the basic virtual memory map(see memalyout.h) is established.
+    //check the correctness of the basic virtual memory map.
+    check_boot_pgdir();
+
+    print_pgdir();
+
+}
+
+//get_pte - get pte and return the kernel virtual address of this pte for la
+//        - if the PT contians this pte didn't exist, alloc a page for PT
+// parameter:
+//  pgdir:  the kernel virtual base address of PDT
+//  la:     the linear address need to map
+//  create: a logical value to decide if alloc a page for PT
+// return vaule: the kernel virtual address of this pte
+pte_t *
+get_pte(pde_t *pgdir, uintptr_t la, bool create) {
+    /* LAB2 EXERCISE 2: YOUR CODE
+     *
+     * If you need to visit a physical address, please use KADDR()
+     * please read pmm.h for useful macros
+     *
+     * Maybe you want help comment, BELOW comments can help you finish the code
+     *
+     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+     * MACROs or Functions:
+     *   PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la.
+     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.
+     *   set_page_ref(page,1) : means the page be referenced by one time
+     *   page2pa(page): get the physical address of memory which this (struct Page *) page  manages
+     *   struct Page * alloc_page() : allocation a page
+     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s
+     *                                       to the specified value c.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
+     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+     */
+
+    pde_t *pdep = &pgdir[PDX(la)];   // (1) find page directory entry
+    if (!(*pdep & PTE_P)) {              // (2) check if entry is not present
+	struct Page* page;                    // (3) check if creating is needed, then alloc page for page table
+                          // CAUTION: this page is used for page table, not for common data page
+	if (!create || (page = alloc_page()) == NULL) {
+            return NULL;
+        }                          
+	set_page_ref(page, 1);		  // (4) set page reference
+        uintptr_t pa = page2pa(page); // (5) get linear address of page
+        memset(KADDR(pa),0,PGSIZE);                  // (6) clear page content using memset
+        *pdep = pa | PTE_U | PTE_W | PTE_P;                // (7) set page directory entry's permission
+    }
+    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];          // (8) return page table entry
+
+}
+
+//get_page - get related Page struct for linear address la using PDT pgdir
+struct Page *
+get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
+    pte_t *ptep = get_pte(pgdir, la, 0);
+    if (ptep_store != NULL) {
+        *ptep_store = ptep;
+    }
+    if (ptep != NULL && *ptep & PTE_P) {
+        return pa2page(*ptep);
+    }
+    return NULL;
+}
+
+//page_remove_pte - free an Page sturct which is related linear address la
+//                - and clean(invalidate) pte which is related linear address la
+//note: PT is changed, so the TLB need to be invalidate 
+static inline void
+page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
+    /* LAB2 EXERCISE 3: YOUR CODE
+     *
+     * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
+     *
+     * Maybe you want help comment, BELOW comments can help you finish the code
+     *
+     * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+     * MACROs or Functions:
+     *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep
+     *   free_page : free a page
+     *   page_ref_dec(page) : decrease page->ref. NOTICE: ff page->ref == 0 , then this page should be free.
+     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being
+     *                        edited are the ones currently in use by the processor.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     */
+
+    if (*pdep & PTE_P) {                      //(1) check if this page table entry is present
+        struct Page *page = pte2page(*ptep); //(2) find corresponding page to pte
+        if (page_ref_dec(page) == 0) {
+            free_page(page);
+        }
+        *ptep = 0;
+        tlb_invalidate(pgdir, la);
+                                  //(3) decrease page reference
+                                  //(4) and free this page when page reference reachs 0
+                                  //(5) clear second page table entry
+                                  //(6) flush tlb
+    }
+
+}
+
+//page_remove - free an Page which is related linear address la and has an validated pte
+void
+page_remove(pde_t *pgdir, uintptr_t la) {
+    pte_t *ptep = get_pte(pgdir, la, 0);
+    if (ptep != NULL) {
+        page_remove_pte(pgdir, la, ptep);
+    }
+}
+
+//page_insert - build the map of phy addr of an Page with the linear addr la
+// paramemters:
+//  pgdir: the kernel virtual base address of PDT
+//  page:  the Page which need to map
+//  la:    the linear address need to map
+//  perm:  the permission of this Page which is setted in related pte
+// return value: always 0
+//note: PT is changed, so the TLB need to be invalidate 
+int
+page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
+    pte_t *ptep = get_pte(pgdir, la, 1);
+    if (ptep == NULL) {
+        return -E_NO_MEM;
+    }
+    page_ref_inc(page);
+    if (*ptep & PTE_P) {
+        struct Page *p = pte2page(*ptep);
+        if (p == page) {
+            page_ref_dec(page);
+        }
+        else {
+            page_remove_pte(pgdir, la, ptep);
+        }
+    }
+    *ptep = page2pa(page) | PTE_P | perm;
+    tlb_invalidate(pgdir, la);
+    return 0;
+}
+
+// invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+void
+tlb_invalidate(pde_t *pgdir, uintptr_t la) {
+    if (rcr3() == PADDR(pgdir)) {
+        invlpg((void *)la);
+    }
+}
+
+static void
+check_alloc_page(void) {
+    pmm_manager->check();
+    cprintf("check_alloc_page() succeeded!\n");
+}
+
+static void
+check_pgdir(void) {
+    assert(npage <= KMEMSIZE / PGSIZE);
+    assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
+    assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
+
+    struct Page *p1, *p2;
+    p1 = alloc_page();
+    assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
+
+    pte_t *ptep;
+    assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
+    assert(pa2page(*ptep) == p1);
+    assert(page_ref(p1) == 1);
+
+    ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
+    assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
+
+    p2 = alloc_page();
+    assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+    assert(*ptep & PTE_U);
+    assert(*ptep & PTE_W);
+    assert(boot_pgdir[0] & PTE_U);
+    assert(page_ref(p2) == 1);
+
+    assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
+    assert(page_ref(p1) == 2);
+    assert(page_ref(p2) == 0);
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+    assert(pa2page(*ptep) == p1);
+    assert((*ptep & PTE_U) == 0);
+
+    page_remove(boot_pgdir, 0x0);
+    assert(page_ref(p1) == 1);
+    assert(page_ref(p2) == 0);
+
+    page_remove(boot_pgdir, PGSIZE);
+    assert(page_ref(p1) == 0);
+    assert(page_ref(p2) == 0);
+
+    assert(page_ref(pa2page(boot_pgdir[0])) == 1);
+    free_page(pa2page(boot_pgdir[0]));
+    boot_pgdir[0] = 0;
+
+    cprintf("check_pgdir() succeeded!\n");
+}
+
+static void
+check_boot_pgdir(void) {
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+        assert(PTE_ADDR(*ptep) == i);
+    }
+
+    assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
+
+    assert(boot_pgdir[0] == 0);
+
+    struct Page *p;
+    p = alloc_page();
+    assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
+    assert(page_ref(p) == 1);
+    assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
+    assert(page_ref(p) == 2);
+
+    const char *str = "ucore: Hello world!!";
+    strcpy((void *)0x100, str);
+    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
+
+    *(char *)(page2kva(p) + 0x100) = '\0';
+    assert(strlen((const char *)0x100) == 0);
+
+    free_page(p);
+    free_page(pa2page(PDE_ADDR(boot_pgdir[0])));
+    boot_pgdir[0] = 0;
+
+    cprintf("check_boot_pgdir() succeeded!\n");
+}
+
+//perm2str - use string 'u,r,w,-' to present the permission
+static const char *
+perm2str(int perm) {
+    static char str[4];
+    str[0] = (perm & PTE_U) ? 'u' : '-';
+    str[1] = 'r';
+    str[2] = (perm & PTE_W) ? 'w' : '-';
+    str[3] = '\0';
+    return str;
+}
+
+//get_pgtable_items - In [left, right] range of PDT or PT, find a continuous linear addr space
+//                  - (left_store*X_SIZE~right_store*X_SIZE) for PDT or PT
+//                  - X_SIZE=PTSIZE=4M, if PDT; X_SIZE=PGSIZE=4K, if PT
+// paramemters:
+//  left:        no use ???
+//  right:       the high side of table's range
+//  start:       the low side of table's range
+//  table:       the beginning addr of table
+//  left_store:  the pointer of the high side of table's next range
+//  right_store: the pointer of the low side of table's next range
+// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+    if (start >= right) {
+        return 0;
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+        start ++;
+    }
+    if (start < right) {
+        if (left_store != NULL) {
+            *left_store = start;
+        }
+        int perm = (table[start ++] & PTE_USER);
+        while (start < right && (table[start] & PTE_USER) == perm) {
+            start ++;
+        }
+        if (right_store != NULL) {
+            *right_store = start;
+        }
+        return perm;
+    }
+    return 0;
+}
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+        }
+    }
+    cprintf("--------------------- END ---------------------\n");
+}
+
diff -r -u -P lab2_origin/kern/mm/pmm.h lab2/kern/mm/pmm.h
--- lab2_origin/kern/mm/pmm.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/mm/pmm.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,143 @@
+#ifndef __KERN_MM_PMM_H__
+#define __KERN_MM_PMM_H__
+
+#include <defs.h>
+#include <mmu.h>
+#include <memlayout.h>
+#include <atomic.h>
+#include <assert.h>
+
+// pmm_manager is a physical memory management class. A special pmm manager - XXX_pmm_manager
+// only needs to implement the methods in pmm_manager class, then XXX_pmm_manager can be used
+// by ucore to manage the total physical memory space.
+struct pmm_manager {
+    const char *name;                                 // XXX_pmm_manager's name
+    void (*init)(void);                               // initialize internal description&management data structure
+                                                      // (free block list, number of free block) of XXX_pmm_manager 
+    void (*init_memmap)(struct Page *base, size_t n); // setup description&management data structcure according to
+                                                      // the initial free physical memory space 
+    struct Page *(*alloc_pages)(size_t n);            // allocate >=n pages, depend on the allocation algorithm 
+    void (*free_pages)(struct Page *base, size_t n);  // free >=n pages with "base" addr of Page descriptor structures(memlayout.h)
+    size_t (*nr_free_pages)(void);                    // return the number of free pages 
+    void (*check)(void);                              // check the correctness of XXX_pmm_manager 
+};
+
+extern const struct pmm_manager *pmm_manager;
+extern pde_t *boot_pgdir;
+extern uintptr_t boot_cr3;
+
+void pmm_init(void);
+
+struct Page *alloc_pages(size_t n);
+void free_pages(struct Page *base, size_t n);
+size_t nr_free_pages(void);
+
+#define alloc_page() alloc_pages(1)
+#define free_page(page) free_pages(page, 1)
+
+pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create);
+struct Page *get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store);
+void page_remove(pde_t *pgdir, uintptr_t la);
+int page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm);
+
+void load_esp0(uintptr_t esp0);
+void tlb_invalidate(pde_t *pgdir, uintptr_t la);
+
+void print_pgdir(void);
+
+/* *
+ * PADDR - takes a kernel virtual address (an address that points above KERNBASE),
+ * where the machine's maximum 256MB of physical memory is mapped and returns the
+ * corresponding physical address.  It panics if you pass it a non-kernel virtual address.
+ * */
+#define PADDR(kva) ({                                                   \
+            uintptr_t __m_kva = (uintptr_t)(kva);                       \
+            if (__m_kva < KERNBASE) {                                   \
+                panic("PADDR called with invalid kva %08lx", __m_kva);  \
+            }                                                           \
+            __m_kva - KERNBASE;                                         \
+        })
+
+/* *
+ * KADDR - takes a physical address and returns the corresponding kernel virtual
+ * address. It panics if you pass an invalid physical address.
+ * */
+#define KADDR(pa) ({                                                    \
+            uintptr_t __m_pa = (pa);                                    \
+            size_t __m_ppn = PPN(__m_pa);                               \
+            if (__m_ppn >= npage) {                                     \
+                panic("KADDR called with invalid pa %08lx", __m_pa);    \
+            }                                                           \
+            (void *) (__m_pa + KERNBASE);                               \
+        })
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+    return page - pages;
+}
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+    return page2ppn(page) << PGSHIFT;
+}
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+    if (PPN(pa) >= npage) {
+        panic("pa2page called with invalid pa");
+    }
+    return &pages[PPN(pa)];
+}
+
+static inline void *
+page2kva(struct Page *page) {
+    return KADDR(page2pa(page));
+}
+
+static inline struct Page *
+kva2page(void *kva) {
+    return pa2page(PADDR(kva));
+}
+
+static inline struct Page *
+pte2page(pte_t pte) {
+    if (!(pte & PTE_P)) {
+        panic("pte2page called with invalid pte");
+    }
+    return pa2page(PTE_ADDR(pte));
+}
+
+static inline struct Page *
+pde2page(pde_t pde) {
+    return pa2page(PDE_ADDR(pde));
+}
+
+static inline int
+page_ref(struct Page *page) {
+    return page->ref;
+}
+
+static inline void
+set_page_ref(struct Page *page, int val) {
+    page->ref = val;
+}
+
+static inline int
+page_ref_inc(struct Page *page) {
+    page->ref += 1;
+    return page->ref;
+}
+
+static inline int
+page_ref_dec(struct Page *page) {
+    page->ref -= 1;
+    return page->ref;
+}
+
+extern char bootstack[], bootstacktop[];
+
+#endif /* !__KERN_MM_PMM_H__ */
+
diff -r -u -P lab2_origin/kern/sync/sync.h lab2/kern/sync/sync.h
--- lab2_origin/kern/sync/sync.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/sync/sync.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,28 @@
+#ifndef __KERN_SYNC_SYNC_H__
+#define __KERN_SYNC_SYNC_H__
+
+#include <x86.h>
+#include <intr.h>
+#include <mmu.h>
+
+static inline bool
+__intr_save(void) {
+    if (read_eflags() & FL_IF) {
+        intr_disable();
+        return 1;
+    }
+    return 0;
+}
+
+static inline void
+__intr_restore(bool flag) {
+    if (flag) {
+        intr_enable();
+    }
+}
+
+#define local_intr_save(x)      do { x = __intr_save(); } while (0)
+#define local_intr_restore(x)   __intr_restore(x);
+
+#endif /* !__KERN_SYNC_SYNC_H__ */
+
diff -r -u -P lab2_origin/kern/trap/trap.c lab2/kern/trap/trap.c
--- lab2_origin/kern/trap/trap.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/trap/trap.c	2021-08-30 16:06:32.432911097 +0800
@@ -0,0 +1,218 @@
+#include <defs.h>
+#include <mmu.h>
+#include <memlayout.h>
+#include <clock.h>
+#include <trap.h>
+#include <x86.h>
+#include <stdio.h>
+#include <assert.h>
+#include <console.h>
+#include <kdebug.h>
+#include <string.h>
+
+#define TICK_NUM 100
+
+static void print_ticks() {
+    cprintf("%d ticks\n",TICK_NUM);
+#ifdef DEBUG_GRADE
+    cprintf("End of Test.\n");
+    panic("EOT: kernel seems ok.");
+#endif
+}
+
+/* *
+ * Interrupt descriptor table:
+ *
+ * Must be built at run time because shifted function addresses can't
+ * be represented in relocation records.
+ * */
+static struct gatedesc idt[256] = {{0}};
+
+static struct pseudodesc idt_pd = {
+    sizeof(idt) - 1, (uintptr_t)idt
+};
+
+/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
+void
+idt_init(void) {
+     /* LAB1 YOUR CODE : STEP 2 */
+     /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
+      *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
+      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
+      *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)
+      *     You can use  "extern uintptr_t __vectors[];" to define this extern variable which will be used later.
+      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).
+      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT
+      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.
+      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+	extern uintptr_t __vectors[];
+	int i;
+	for(i=0;i<sizeof(idt)/sizeof(struct gatedesc);i++){
+		SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+	}
+	SETGATE(idt[T_SWITCH_TOK],0,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER);
+	lidt(&idt_pd);
+}
+
+static const char *
+trapname(int trapno) {
+    static const char * const excnames[] = {
+        "Divide error",
+        "Debug",
+        "Non-Maskable Interrupt",
+        "Breakpoint",
+        "Overflow",
+        "BOUND Range Exceeded",
+        "Invalid Opcode",
+        "Device Not Available",
+        "Double Fault",
+        "Coprocessor Segment Overrun",
+        "Invalid TSS",
+        "Segment Not Present",
+        "Stack Fault",
+        "General Protection",
+        "Page Fault",
+        "(unknown trap)",
+        "x87 FPU Floating-Point Error",
+        "Alignment Check",
+        "Machine-Check",
+        "SIMD Floating-Point Exception"
+    };
+
+    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+        return excnames[trapno];
+    }
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+        return "Hardware Interrupt";
+    }
+    return "(unknown trap)";
+}
+
+/* trap_in_kernel - test if trap happened in kernel */
+bool
+trap_in_kernel(struct trapframe *tf) {
+    return (tf->tf_cs == (uint16_t)KERNEL_CS);
+}
+
+static const char *IA32flags[] = {
+    "CF", NULL, "PF", NULL, "AF", NULL, "ZF", "SF",
+    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
+    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+};
+
+void
+print_trapframe(struct trapframe *tf) {
+    cprintf("trapframe at %p\n", tf);
+    print_regs(&tf->tf_regs);
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+    cprintf("  fs   0x----%04x\n", tf->tf_fs);
+    cprintf("  gs   0x----%04x\n", tf->tf_gs);
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+    cprintf("  err  0x%08x\n", tf->tf_err);
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+            cprintf("%s,", IA32flags[i]);
+        }
+    }
+    cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
+
+    if (!trap_in_kernel(tf)) {
+        cprintf("  esp  0x%08x\n", tf->tf_esp);
+        cprintf("  ss   0x----%04x\n", tf->tf_ss);
+    }
+}
+
+void
+print_regs(struct pushregs *regs) {
+    cprintf("  edi  0x%08x\n", regs->reg_edi);
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+}
+
+struct trapframe switchk2u, *switchu2k;
+
+/* trap_dispatch - dispatch based on what type of trap occurred */
+static void
+trap_dispatch(struct trapframe *tf) {
+    char c;
+
+    switch (tf->tf_trapno) {
+    case IRQ_OFFSET + IRQ_TIMER:
+        /* LAB1 YOUR CODE : STEP 3 */
+        /* handle the timer interrupt */
+        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+	ticks++;
+	if(ticks%TICK_NUM==0){
+		print_ticks();	
+	}
+        break;
+    case IRQ_OFFSET + IRQ_COM1:
+        c = cons_getc();
+        cprintf("serial [%03d] %c\n", c, c);
+        break;
+    case IRQ_OFFSET + IRQ_KBD:
+        c = cons_getc();
+        cprintf("kbd [%03d] %c\n", c, c);
+	break;
+    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    case T_SWITCH_TOU:
+	if (tf->tf_cs != USER_CS) {
+	        switchk2u = *tf;
+	        switchk2u.tf_cs = USER_CS;
+	        switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;
+	        switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8;
+		switchk2u.tf_eflags |= FL_IOPL_MASK;
+		*((uint32_t *)tf - 1) = (uint32_t)&switchk2u;
+	}
+	break;
+    case T_SWITCH_TOK:
+        if (tf->tf_cs != KERNEL_CS) {
+            tf->tf_cs = KERNEL_CS;
+            tf->tf_ds = tf->tf_es = KERNEL_DS;
+            tf->tf_eflags &= ~FL_IOPL_MASK;
+            switchu2k = (struct trapframe *)(tf->tf_esp - (sizeof(struct trapframe) - 8));
+            memmove(switchu2k, tf, sizeof(struct trapframe) - 8);
+            *((uint32_t *)tf - 1) = (uint32_t)switchu2k;
+        }
+        break;
+
+    case IRQ_OFFSET + IRQ_IDE1:
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+    default:
+        // in kernel, it must be a mistake
+        if ((tf->tf_cs & 3) == 0) {
+            print_trapframe(tf);
+            panic("unexpected trap in kernel.\n");
+        }
+    }
+}
+
+/* *
+ * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
+ * the code in kern/trap/trapentry.S restores the old CPU state saved in the
+ * trapframe and then uses the iret instruction to return from the exception.
+ * */
+void
+trap(struct trapframe *tf) {
+    // dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+}
+
diff -r -u -P lab2_origin/kern/trap/trap.c~ lab2/kern/trap/trap.c~
--- lab2_origin/kern/trap/trap.c~	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/trap/trap.c~	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,187 @@
+#include <defs.h>
+#include <mmu.h>
+#include <memlayout.h>
+#include <clock.h>
+#include <trap.h>
+#include <x86.h>
+#include <stdio.h>
+#include <assert.h>
+#include <console.h>
+#include <kdebug.h>
+
+#define TICK_NUM 100
+
+static void print_ticks() {
+    cprintf("%d ticks\n",TICK_NUM);
+#ifdef DEBUG_GRADE
+    cprintf("End of Test.\n");
+    panic("EOT: kernel seems ok.");
+#endif
+}
+
+/* *
+ * Interrupt descriptor table:
+ *
+ * Must be built at run time because shifted function addresses can't
+ * be represented in relocation records.
+ * */
+static struct gatedesc idt[256] = {{0}};
+
+static struct pseudodesc idt_pd = {
+    sizeof(idt) - 1, (uintptr_t)idt
+};
+
+/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
+void
+idt_init(void) {
+     /* LAB1 YOUR CODE : STEP 2 */
+     /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?
+      *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?
+      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c
+      *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)
+      *     You can use  "extern uintptr_t __vectors[];" to define this extern variable which will be used later.
+      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).
+      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT
+      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.
+      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+}
+
+static const char *
+trapname(int trapno) {
+    static const char * const excnames[] = {
+        "Divide error",
+        "Debug",
+        "Non-Maskable Interrupt",
+        "Breakpoint",
+        "Overflow",
+        "BOUND Range Exceeded",
+        "Invalid Opcode",
+        "Device Not Available",
+        "Double Fault",
+        "Coprocessor Segment Overrun",
+        "Invalid TSS",
+        "Segment Not Present",
+        "Stack Fault",
+        "General Protection",
+        "Page Fault",
+        "(unknown trap)",
+        "x87 FPU Floating-Point Error",
+        "Alignment Check",
+        "Machine-Check",
+        "SIMD Floating-Point Exception"
+    };
+
+    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+        return excnames[trapno];
+    }
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+        return "Hardware Interrupt";
+    }
+    return "(unknown trap)";
+}
+
+/* trap_in_kernel - test if trap happened in kernel */
+bool
+trap_in_kernel(struct trapframe *tf) {
+    return (tf->tf_cs == (uint16_t)KERNEL_CS);
+}
+
+static const char *IA32flags[] = {
+    "CF", NULL, "PF", NULL, "AF", NULL, "ZF", "SF",
+    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
+    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+};
+
+void
+print_trapframe(struct trapframe *tf) {
+    cprintf("trapframe at %p\n", tf);
+    print_regs(&tf->tf_regs);
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+    cprintf("  fs   0x----%04x\n", tf->tf_fs);
+    cprintf("  gs   0x----%04x\n", tf->tf_gs);
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+    cprintf("  err  0x%08x\n", tf->tf_err);
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+            cprintf("%s,", IA32flags[i]);
+        }
+    }
+    cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
+
+    if (!trap_in_kernel(tf)) {
+        cprintf("  esp  0x%08x\n", tf->tf_esp);
+        cprintf("  ss   0x----%04x\n", tf->tf_ss);
+    }
+}
+
+void
+print_regs(struct pushregs *regs) {
+    cprintf("  edi  0x%08x\n", regs->reg_edi);
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+}
+
+/* trap_dispatch - dispatch based on what type of trap occurred */
+static void
+trap_dispatch(struct trapframe *tf) {
+    char c;
+
+    switch (tf->tf_trapno) {
+    case IRQ_OFFSET + IRQ_TIMER:
+        /* LAB1 YOUR CODE : STEP 3 */
+        /* handle the timer interrupt */
+        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+        break;
+    case IRQ_OFFSET + IRQ_COM1:
+        c = cons_getc();
+        cprintf("serial [%03d] %c\n", c, c);
+        break;
+    case IRQ_OFFSET + IRQ_KBD:
+        c = cons_getc();
+        cprintf("kbd [%03d] %c\n", c, c);
+        break;
+    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    case T_SWITCH_TOU:
+    case T_SWITCH_TOK:
+        panic("T_SWITCH_** ??\n");
+        break;
+    case IRQ_OFFSET + IRQ_IDE1:
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+    default:
+        // in kernel, it must be a mistake
+        if ((tf->tf_cs & 3) == 0) {
+            print_trapframe(tf);
+            panic("unexpected trap in kernel.\n");
+        }
+    }
+}
+
+/* *
+ * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
+ * the code in kern/trap/trapentry.S restores the old CPU state saved in the
+ * trapframe and then uses the iret instruction to return from the exception.
+ * */
+void
+trap(struct trapframe *tf) {
+    // dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+}
+
diff -r -u -P lab2_origin/kern/trap/trapentry.S lab2/kern/trap/trapentry.S
--- lab2_origin/kern/trap/trapentry.S	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/trap/trapentry.S	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,44 @@
+#include <memlayout.h>
+
+# vectors.S sends all traps here.
+.text
+.globl __alltraps
+__alltraps:
+    # push registers to build a trap frame
+    # therefore make the stack look like a struct trapframe
+    pushl %ds
+    pushl %es
+    pushl %fs
+    pushl %gs
+    pushal
+
+    # load GD_KDATA into %ds and %es to set up data segments for kernel
+    movl $GD_KDATA, %eax
+    movw %ax, %ds
+    movw %ax, %es
+
+    # push %esp to pass a pointer to the trapframe as an argument to trap()
+    pushl %esp
+
+    # call trap(tf), where tf=%esp
+    call trap
+
+    # pop the pushed stack pointer
+    popl %esp
+
+    # return falls through to trapret...
+.globl __trapret
+__trapret:
+    # restore registers from stack
+    popal
+
+    # restore %ds, %es, %fs and %gs
+    popl %gs
+    popl %fs
+    popl %es
+    popl %ds
+
+    # get rid of the trap number and error code
+    addl $0x8, %esp
+    iret
+
diff -r -u -P lab2_origin/kern/trap/trap.h lab2/kern/trap/trap.h
--- lab2_origin/kern/trap/trap.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/trap/trap.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,91 @@
+#ifndef __KERN_TRAP_TRAP_H__
+#define __KERN_TRAP_TRAP_H__
+
+#include <defs.h>
+
+/* Trap Numbers */
+
+/* Processor-defined: */
+#define T_DIVIDE                0   // divide error
+#define T_DEBUG                 1   // debug exception
+#define T_NMI                   2   // non-maskable interrupt
+#define T_BRKPT                 3   // breakpoint
+#define T_OFLOW                 4   // overflow
+#define T_BOUND                 5   // bounds check
+#define T_ILLOP                 6   // illegal opcode
+#define T_DEVICE                7   // device not available
+#define T_DBLFLT                8   // double fault
+// #define T_COPROC             9   // reserved (not used since 486)
+#define T_TSS                   10  // invalid task switch segment
+#define T_SEGNP                 11  // segment not present
+#define T_STACK                 12  // stack exception
+#define T_GPFLT                 13  // general protection fault
+#define T_PGFLT                 14  // page fault
+// #define T_RES                15  // reserved
+#define T_FPERR                 16  // floating point error
+#define T_ALIGN                 17  // aligment check
+#define T_MCHK                  18  // machine check
+#define T_SIMDERR               19  // SIMD floating point error
+
+#define T_SYSCALL               0x80 // SYSCALL, ONLY FOR THIS PROJ
+
+/* Hardware IRQ numbers. We receive these as (IRQ_OFFSET + IRQ_xx) */
+#define IRQ_OFFSET              32  // IRQ 0 corresponds to int IRQ_OFFSET
+
+#define IRQ_TIMER               0
+#define IRQ_KBD                 1
+#define IRQ_COM1                4
+#define IRQ_IDE1                14
+#define IRQ_IDE2                15
+#define IRQ_ERROR               19
+#define IRQ_SPURIOUS            31
+
+/* *
+ * These are arbitrarily chosen, but with care not to overlap
+ * processor defined exceptions or interrupt vectors.
+ * */
+#define T_SWITCH_TOU                120    // user/kernel switch
+#define T_SWITCH_TOK                121    // user/kernel switch
+
+/* registers as pushed by pushal */
+struct pushregs {
+    uint32_t reg_edi;
+    uint32_t reg_esi;
+    uint32_t reg_ebp;
+    uint32_t reg_oesp;          /* Useless */
+    uint32_t reg_ebx;
+    uint32_t reg_edx;
+    uint32_t reg_ecx;
+    uint32_t reg_eax;
+};
+
+struct trapframe {
+    struct pushregs tf_regs;
+    uint16_t tf_gs;
+    uint16_t tf_padding0;
+    uint16_t tf_fs;
+    uint16_t tf_padding1;
+    uint16_t tf_es;
+    uint16_t tf_padding2;
+    uint16_t tf_ds;
+    uint16_t tf_padding3;
+    uint32_t tf_trapno;
+    /* below here defined by x86 hardware */
+    uint32_t tf_err;
+    uintptr_t tf_eip;
+    uint16_t tf_cs;
+    uint16_t tf_padding4;
+    uint32_t tf_eflags;
+    /* below here only when crossing rings, such as from user to kernel */
+    uintptr_t tf_esp;
+    uint16_t tf_ss;
+    uint16_t tf_padding5;
+} __attribute__((packed));
+
+void idt_init(void);
+void print_trapframe(struct trapframe *tf);
+void print_regs(struct pushregs *regs);
+bool trap_in_kernel(struct trapframe *tf);
+
+#endif /* !__KERN_TRAP_TRAP_H__ */
+
diff -r -u -P lab2_origin/kern/trap/vectors.S lab2/kern/trap/vectors.S
--- lab2_origin/kern/trap/vectors.S	1970-01-01 08:00:00.000000000 +0800
+++ lab2/kern/trap/vectors.S	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,1536 @@
+# handler
+.text
+.globl __alltraps
+.globl vector0
+vector0:
+  pushl $0
+  pushl $0
+  jmp __alltraps
+.globl vector1
+vector1:
+  pushl $0
+  pushl $1
+  jmp __alltraps
+.globl vector2
+vector2:
+  pushl $0
+  pushl $2
+  jmp __alltraps
+.globl vector3
+vector3:
+  pushl $0
+  pushl $3
+  jmp __alltraps
+.globl vector4
+vector4:
+  pushl $0
+  pushl $4
+  jmp __alltraps
+.globl vector5
+vector5:
+  pushl $0
+  pushl $5
+  jmp __alltraps
+.globl vector6
+vector6:
+  pushl $0
+  pushl $6
+  jmp __alltraps
+.globl vector7
+vector7:
+  pushl $0
+  pushl $7
+  jmp __alltraps
+.globl vector8
+vector8:
+  pushl $8
+  jmp __alltraps
+.globl vector9
+vector9:
+  pushl $9
+  jmp __alltraps
+.globl vector10
+vector10:
+  pushl $10
+  jmp __alltraps
+.globl vector11
+vector11:
+  pushl $11
+  jmp __alltraps
+.globl vector12
+vector12:
+  pushl $12
+  jmp __alltraps
+.globl vector13
+vector13:
+  pushl $13
+  jmp __alltraps
+.globl vector14
+vector14:
+  pushl $14
+  jmp __alltraps
+.globl vector15
+vector15:
+  pushl $0
+  pushl $15
+  jmp __alltraps
+.globl vector16
+vector16:
+  pushl $0
+  pushl $16
+  jmp __alltraps
+.globl vector17
+vector17:
+  pushl $17
+  jmp __alltraps
+.globl vector18
+vector18:
+  pushl $0
+  pushl $18
+  jmp __alltraps
+.globl vector19
+vector19:
+  pushl $0
+  pushl $19
+  jmp __alltraps
+.globl vector20
+vector20:
+  pushl $0
+  pushl $20
+  jmp __alltraps
+.globl vector21
+vector21:
+  pushl $0
+  pushl $21
+  jmp __alltraps
+.globl vector22
+vector22:
+  pushl $0
+  pushl $22
+  jmp __alltraps
+.globl vector23
+vector23:
+  pushl $0
+  pushl $23
+  jmp __alltraps
+.globl vector24
+vector24:
+  pushl $0
+  pushl $24
+  jmp __alltraps
+.globl vector25
+vector25:
+  pushl $0
+  pushl $25
+  jmp __alltraps
+.globl vector26
+vector26:
+  pushl $0
+  pushl $26
+  jmp __alltraps
+.globl vector27
+vector27:
+  pushl $0
+  pushl $27
+  jmp __alltraps
+.globl vector28
+vector28:
+  pushl $0
+  pushl $28
+  jmp __alltraps
+.globl vector29
+vector29:
+  pushl $0
+  pushl $29
+  jmp __alltraps
+.globl vector30
+vector30:
+  pushl $0
+  pushl $30
+  jmp __alltraps
+.globl vector31
+vector31:
+  pushl $0
+  pushl $31
+  jmp __alltraps
+.globl vector32
+vector32:
+  pushl $0
+  pushl $32
+  jmp __alltraps
+.globl vector33
+vector33:
+  pushl $0
+  pushl $33
+  jmp __alltraps
+.globl vector34
+vector34:
+  pushl $0
+  pushl $34
+  jmp __alltraps
+.globl vector35
+vector35:
+  pushl $0
+  pushl $35
+  jmp __alltraps
+.globl vector36
+vector36:
+  pushl $0
+  pushl $36
+  jmp __alltraps
+.globl vector37
+vector37:
+  pushl $0
+  pushl $37
+  jmp __alltraps
+.globl vector38
+vector38:
+  pushl $0
+  pushl $38
+  jmp __alltraps
+.globl vector39
+vector39:
+  pushl $0
+  pushl $39
+  jmp __alltraps
+.globl vector40
+vector40:
+  pushl $0
+  pushl $40
+  jmp __alltraps
+.globl vector41
+vector41:
+  pushl $0
+  pushl $41
+  jmp __alltraps
+.globl vector42
+vector42:
+  pushl $0
+  pushl $42
+  jmp __alltraps
+.globl vector43
+vector43:
+  pushl $0
+  pushl $43
+  jmp __alltraps
+.globl vector44
+vector44:
+  pushl $0
+  pushl $44
+  jmp __alltraps
+.globl vector45
+vector45:
+  pushl $0
+  pushl $45
+  jmp __alltraps
+.globl vector46
+vector46:
+  pushl $0
+  pushl $46
+  jmp __alltraps
+.globl vector47
+vector47:
+  pushl $0
+  pushl $47
+  jmp __alltraps
+.globl vector48
+vector48:
+  pushl $0
+  pushl $48
+  jmp __alltraps
+.globl vector49
+vector49:
+  pushl $0
+  pushl $49
+  jmp __alltraps
+.globl vector50
+vector50:
+  pushl $0
+  pushl $50
+  jmp __alltraps
+.globl vector51
+vector51:
+  pushl $0
+  pushl $51
+  jmp __alltraps
+.globl vector52
+vector52:
+  pushl $0
+  pushl $52
+  jmp __alltraps
+.globl vector53
+vector53:
+  pushl $0
+  pushl $53
+  jmp __alltraps
+.globl vector54
+vector54:
+  pushl $0
+  pushl $54
+  jmp __alltraps
+.globl vector55
+vector55:
+  pushl $0
+  pushl $55
+  jmp __alltraps
+.globl vector56
+vector56:
+  pushl $0
+  pushl $56
+  jmp __alltraps
+.globl vector57
+vector57:
+  pushl $0
+  pushl $57
+  jmp __alltraps
+.globl vector58
+vector58:
+  pushl $0
+  pushl $58
+  jmp __alltraps
+.globl vector59
+vector59:
+  pushl $0
+  pushl $59
+  jmp __alltraps
+.globl vector60
+vector60:
+  pushl $0
+  pushl $60
+  jmp __alltraps
+.globl vector61
+vector61:
+  pushl $0
+  pushl $61
+  jmp __alltraps
+.globl vector62
+vector62:
+  pushl $0
+  pushl $62
+  jmp __alltraps
+.globl vector63
+vector63:
+  pushl $0
+  pushl $63
+  jmp __alltraps
+.globl vector64
+vector64:
+  pushl $0
+  pushl $64
+  jmp __alltraps
+.globl vector65
+vector65:
+  pushl $0
+  pushl $65
+  jmp __alltraps
+.globl vector66
+vector66:
+  pushl $0
+  pushl $66
+  jmp __alltraps
+.globl vector67
+vector67:
+  pushl $0
+  pushl $67
+  jmp __alltraps
+.globl vector68
+vector68:
+  pushl $0
+  pushl $68
+  jmp __alltraps
+.globl vector69
+vector69:
+  pushl $0
+  pushl $69
+  jmp __alltraps
+.globl vector70
+vector70:
+  pushl $0
+  pushl $70
+  jmp __alltraps
+.globl vector71
+vector71:
+  pushl $0
+  pushl $71
+  jmp __alltraps
+.globl vector72
+vector72:
+  pushl $0
+  pushl $72
+  jmp __alltraps
+.globl vector73
+vector73:
+  pushl $0
+  pushl $73
+  jmp __alltraps
+.globl vector74
+vector74:
+  pushl $0
+  pushl $74
+  jmp __alltraps
+.globl vector75
+vector75:
+  pushl $0
+  pushl $75
+  jmp __alltraps
+.globl vector76
+vector76:
+  pushl $0
+  pushl $76
+  jmp __alltraps
+.globl vector77
+vector77:
+  pushl $0
+  pushl $77
+  jmp __alltraps
+.globl vector78
+vector78:
+  pushl $0
+  pushl $78
+  jmp __alltraps
+.globl vector79
+vector79:
+  pushl $0
+  pushl $79
+  jmp __alltraps
+.globl vector80
+vector80:
+  pushl $0
+  pushl $80
+  jmp __alltraps
+.globl vector81
+vector81:
+  pushl $0
+  pushl $81
+  jmp __alltraps
+.globl vector82
+vector82:
+  pushl $0
+  pushl $82
+  jmp __alltraps
+.globl vector83
+vector83:
+  pushl $0
+  pushl $83
+  jmp __alltraps
+.globl vector84
+vector84:
+  pushl $0
+  pushl $84
+  jmp __alltraps
+.globl vector85
+vector85:
+  pushl $0
+  pushl $85
+  jmp __alltraps
+.globl vector86
+vector86:
+  pushl $0
+  pushl $86
+  jmp __alltraps
+.globl vector87
+vector87:
+  pushl $0
+  pushl $87
+  jmp __alltraps
+.globl vector88
+vector88:
+  pushl $0
+  pushl $88
+  jmp __alltraps
+.globl vector89
+vector89:
+  pushl $0
+  pushl $89
+  jmp __alltraps
+.globl vector90
+vector90:
+  pushl $0
+  pushl $90
+  jmp __alltraps
+.globl vector91
+vector91:
+  pushl $0
+  pushl $91
+  jmp __alltraps
+.globl vector92
+vector92:
+  pushl $0
+  pushl $92
+  jmp __alltraps
+.globl vector93
+vector93:
+  pushl $0
+  pushl $93
+  jmp __alltraps
+.globl vector94
+vector94:
+  pushl $0
+  pushl $94
+  jmp __alltraps
+.globl vector95
+vector95:
+  pushl $0
+  pushl $95
+  jmp __alltraps
+.globl vector96
+vector96:
+  pushl $0
+  pushl $96
+  jmp __alltraps
+.globl vector97
+vector97:
+  pushl $0
+  pushl $97
+  jmp __alltraps
+.globl vector98
+vector98:
+  pushl $0
+  pushl $98
+  jmp __alltraps
+.globl vector99
+vector99:
+  pushl $0
+  pushl $99
+  jmp __alltraps
+.globl vector100
+vector100:
+  pushl $0
+  pushl $100
+  jmp __alltraps
+.globl vector101
+vector101:
+  pushl $0
+  pushl $101
+  jmp __alltraps
+.globl vector102
+vector102:
+  pushl $0
+  pushl $102
+  jmp __alltraps
+.globl vector103
+vector103:
+  pushl $0
+  pushl $103
+  jmp __alltraps
+.globl vector104
+vector104:
+  pushl $0
+  pushl $104
+  jmp __alltraps
+.globl vector105
+vector105:
+  pushl $0
+  pushl $105
+  jmp __alltraps
+.globl vector106
+vector106:
+  pushl $0
+  pushl $106
+  jmp __alltraps
+.globl vector107
+vector107:
+  pushl $0
+  pushl $107
+  jmp __alltraps
+.globl vector108
+vector108:
+  pushl $0
+  pushl $108
+  jmp __alltraps
+.globl vector109
+vector109:
+  pushl $0
+  pushl $109
+  jmp __alltraps
+.globl vector110
+vector110:
+  pushl $0
+  pushl $110
+  jmp __alltraps
+.globl vector111
+vector111:
+  pushl $0
+  pushl $111
+  jmp __alltraps
+.globl vector112
+vector112:
+  pushl $0
+  pushl $112
+  jmp __alltraps
+.globl vector113
+vector113:
+  pushl $0
+  pushl $113
+  jmp __alltraps
+.globl vector114
+vector114:
+  pushl $0
+  pushl $114
+  jmp __alltraps
+.globl vector115
+vector115:
+  pushl $0
+  pushl $115
+  jmp __alltraps
+.globl vector116
+vector116:
+  pushl $0
+  pushl $116
+  jmp __alltraps
+.globl vector117
+vector117:
+  pushl $0
+  pushl $117
+  jmp __alltraps
+.globl vector118
+vector118:
+  pushl $0
+  pushl $118
+  jmp __alltraps
+.globl vector119
+vector119:
+  pushl $0
+  pushl $119
+  jmp __alltraps
+.globl vector120
+vector120:
+  pushl $0
+  pushl $120
+  jmp __alltraps
+.globl vector121
+vector121:
+  pushl $0
+  pushl $121
+  jmp __alltraps
+.globl vector122
+vector122:
+  pushl $0
+  pushl $122
+  jmp __alltraps
+.globl vector123
+vector123:
+  pushl $0
+  pushl $123
+  jmp __alltraps
+.globl vector124
+vector124:
+  pushl $0
+  pushl $124
+  jmp __alltraps
+.globl vector125
+vector125:
+  pushl $0
+  pushl $125
+  jmp __alltraps
+.globl vector126
+vector126:
+  pushl $0
+  pushl $126
+  jmp __alltraps
+.globl vector127
+vector127:
+  pushl $0
+  pushl $127
+  jmp __alltraps
+.globl vector128
+vector128:
+  pushl $0
+  pushl $128
+  jmp __alltraps
+.globl vector129
+vector129:
+  pushl $0
+  pushl $129
+  jmp __alltraps
+.globl vector130
+vector130:
+  pushl $0
+  pushl $130
+  jmp __alltraps
+.globl vector131
+vector131:
+  pushl $0
+  pushl $131
+  jmp __alltraps
+.globl vector132
+vector132:
+  pushl $0
+  pushl $132
+  jmp __alltraps
+.globl vector133
+vector133:
+  pushl $0
+  pushl $133
+  jmp __alltraps
+.globl vector134
+vector134:
+  pushl $0
+  pushl $134
+  jmp __alltraps
+.globl vector135
+vector135:
+  pushl $0
+  pushl $135
+  jmp __alltraps
+.globl vector136
+vector136:
+  pushl $0
+  pushl $136
+  jmp __alltraps
+.globl vector137
+vector137:
+  pushl $0
+  pushl $137
+  jmp __alltraps
+.globl vector138
+vector138:
+  pushl $0
+  pushl $138
+  jmp __alltraps
+.globl vector139
+vector139:
+  pushl $0
+  pushl $139
+  jmp __alltraps
+.globl vector140
+vector140:
+  pushl $0
+  pushl $140
+  jmp __alltraps
+.globl vector141
+vector141:
+  pushl $0
+  pushl $141
+  jmp __alltraps
+.globl vector142
+vector142:
+  pushl $0
+  pushl $142
+  jmp __alltraps
+.globl vector143
+vector143:
+  pushl $0
+  pushl $143
+  jmp __alltraps
+.globl vector144
+vector144:
+  pushl $0
+  pushl $144
+  jmp __alltraps
+.globl vector145
+vector145:
+  pushl $0
+  pushl $145
+  jmp __alltraps
+.globl vector146
+vector146:
+  pushl $0
+  pushl $146
+  jmp __alltraps
+.globl vector147
+vector147:
+  pushl $0
+  pushl $147
+  jmp __alltraps
+.globl vector148
+vector148:
+  pushl $0
+  pushl $148
+  jmp __alltraps
+.globl vector149
+vector149:
+  pushl $0
+  pushl $149
+  jmp __alltraps
+.globl vector150
+vector150:
+  pushl $0
+  pushl $150
+  jmp __alltraps
+.globl vector151
+vector151:
+  pushl $0
+  pushl $151
+  jmp __alltraps
+.globl vector152
+vector152:
+  pushl $0
+  pushl $152
+  jmp __alltraps
+.globl vector153
+vector153:
+  pushl $0
+  pushl $153
+  jmp __alltraps
+.globl vector154
+vector154:
+  pushl $0
+  pushl $154
+  jmp __alltraps
+.globl vector155
+vector155:
+  pushl $0
+  pushl $155
+  jmp __alltraps
+.globl vector156
+vector156:
+  pushl $0
+  pushl $156
+  jmp __alltraps
+.globl vector157
+vector157:
+  pushl $0
+  pushl $157
+  jmp __alltraps
+.globl vector158
+vector158:
+  pushl $0
+  pushl $158
+  jmp __alltraps
+.globl vector159
+vector159:
+  pushl $0
+  pushl $159
+  jmp __alltraps
+.globl vector160
+vector160:
+  pushl $0
+  pushl $160
+  jmp __alltraps
+.globl vector161
+vector161:
+  pushl $0
+  pushl $161
+  jmp __alltraps
+.globl vector162
+vector162:
+  pushl $0
+  pushl $162
+  jmp __alltraps
+.globl vector163
+vector163:
+  pushl $0
+  pushl $163
+  jmp __alltraps
+.globl vector164
+vector164:
+  pushl $0
+  pushl $164
+  jmp __alltraps
+.globl vector165
+vector165:
+  pushl $0
+  pushl $165
+  jmp __alltraps
+.globl vector166
+vector166:
+  pushl $0
+  pushl $166
+  jmp __alltraps
+.globl vector167
+vector167:
+  pushl $0
+  pushl $167
+  jmp __alltraps
+.globl vector168
+vector168:
+  pushl $0
+  pushl $168
+  jmp __alltraps
+.globl vector169
+vector169:
+  pushl $0
+  pushl $169
+  jmp __alltraps
+.globl vector170
+vector170:
+  pushl $0
+  pushl $170
+  jmp __alltraps
+.globl vector171
+vector171:
+  pushl $0
+  pushl $171
+  jmp __alltraps
+.globl vector172
+vector172:
+  pushl $0
+  pushl $172
+  jmp __alltraps
+.globl vector173
+vector173:
+  pushl $0
+  pushl $173
+  jmp __alltraps
+.globl vector174
+vector174:
+  pushl $0
+  pushl $174
+  jmp __alltraps
+.globl vector175
+vector175:
+  pushl $0
+  pushl $175
+  jmp __alltraps
+.globl vector176
+vector176:
+  pushl $0
+  pushl $176
+  jmp __alltraps
+.globl vector177
+vector177:
+  pushl $0
+  pushl $177
+  jmp __alltraps
+.globl vector178
+vector178:
+  pushl $0
+  pushl $178
+  jmp __alltraps
+.globl vector179
+vector179:
+  pushl $0
+  pushl $179
+  jmp __alltraps
+.globl vector180
+vector180:
+  pushl $0
+  pushl $180
+  jmp __alltraps
+.globl vector181
+vector181:
+  pushl $0
+  pushl $181
+  jmp __alltraps
+.globl vector182
+vector182:
+  pushl $0
+  pushl $182
+  jmp __alltraps
+.globl vector183
+vector183:
+  pushl $0
+  pushl $183
+  jmp __alltraps
+.globl vector184
+vector184:
+  pushl $0
+  pushl $184
+  jmp __alltraps
+.globl vector185
+vector185:
+  pushl $0
+  pushl $185
+  jmp __alltraps
+.globl vector186
+vector186:
+  pushl $0
+  pushl $186
+  jmp __alltraps
+.globl vector187
+vector187:
+  pushl $0
+  pushl $187
+  jmp __alltraps
+.globl vector188
+vector188:
+  pushl $0
+  pushl $188
+  jmp __alltraps
+.globl vector189
+vector189:
+  pushl $0
+  pushl $189
+  jmp __alltraps
+.globl vector190
+vector190:
+  pushl $0
+  pushl $190
+  jmp __alltraps
+.globl vector191
+vector191:
+  pushl $0
+  pushl $191
+  jmp __alltraps
+.globl vector192
+vector192:
+  pushl $0
+  pushl $192
+  jmp __alltraps
+.globl vector193
+vector193:
+  pushl $0
+  pushl $193
+  jmp __alltraps
+.globl vector194
+vector194:
+  pushl $0
+  pushl $194
+  jmp __alltraps
+.globl vector195
+vector195:
+  pushl $0
+  pushl $195
+  jmp __alltraps
+.globl vector196
+vector196:
+  pushl $0
+  pushl $196
+  jmp __alltraps
+.globl vector197
+vector197:
+  pushl $0
+  pushl $197
+  jmp __alltraps
+.globl vector198
+vector198:
+  pushl $0
+  pushl $198
+  jmp __alltraps
+.globl vector199
+vector199:
+  pushl $0
+  pushl $199
+  jmp __alltraps
+.globl vector200
+vector200:
+  pushl $0
+  pushl $200
+  jmp __alltraps
+.globl vector201
+vector201:
+  pushl $0
+  pushl $201
+  jmp __alltraps
+.globl vector202
+vector202:
+  pushl $0
+  pushl $202
+  jmp __alltraps
+.globl vector203
+vector203:
+  pushl $0
+  pushl $203
+  jmp __alltraps
+.globl vector204
+vector204:
+  pushl $0
+  pushl $204
+  jmp __alltraps
+.globl vector205
+vector205:
+  pushl $0
+  pushl $205
+  jmp __alltraps
+.globl vector206
+vector206:
+  pushl $0
+  pushl $206
+  jmp __alltraps
+.globl vector207
+vector207:
+  pushl $0
+  pushl $207
+  jmp __alltraps
+.globl vector208
+vector208:
+  pushl $0
+  pushl $208
+  jmp __alltraps
+.globl vector209
+vector209:
+  pushl $0
+  pushl $209
+  jmp __alltraps
+.globl vector210
+vector210:
+  pushl $0
+  pushl $210
+  jmp __alltraps
+.globl vector211
+vector211:
+  pushl $0
+  pushl $211
+  jmp __alltraps
+.globl vector212
+vector212:
+  pushl $0
+  pushl $212
+  jmp __alltraps
+.globl vector213
+vector213:
+  pushl $0
+  pushl $213
+  jmp __alltraps
+.globl vector214
+vector214:
+  pushl $0
+  pushl $214
+  jmp __alltraps
+.globl vector215
+vector215:
+  pushl $0
+  pushl $215
+  jmp __alltraps
+.globl vector216
+vector216:
+  pushl $0
+  pushl $216
+  jmp __alltraps
+.globl vector217
+vector217:
+  pushl $0
+  pushl $217
+  jmp __alltraps
+.globl vector218
+vector218:
+  pushl $0
+  pushl $218
+  jmp __alltraps
+.globl vector219
+vector219:
+  pushl $0
+  pushl $219
+  jmp __alltraps
+.globl vector220
+vector220:
+  pushl $0
+  pushl $220
+  jmp __alltraps
+.globl vector221
+vector221:
+  pushl $0
+  pushl $221
+  jmp __alltraps
+.globl vector222
+vector222:
+  pushl $0
+  pushl $222
+  jmp __alltraps
+.globl vector223
+vector223:
+  pushl $0
+  pushl $223
+  jmp __alltraps
+.globl vector224
+vector224:
+  pushl $0
+  pushl $224
+  jmp __alltraps
+.globl vector225
+vector225:
+  pushl $0
+  pushl $225
+  jmp __alltraps
+.globl vector226
+vector226:
+  pushl $0
+  pushl $226
+  jmp __alltraps
+.globl vector227
+vector227:
+  pushl $0
+  pushl $227
+  jmp __alltraps
+.globl vector228
+vector228:
+  pushl $0
+  pushl $228
+  jmp __alltraps
+.globl vector229
+vector229:
+  pushl $0
+  pushl $229
+  jmp __alltraps
+.globl vector230
+vector230:
+  pushl $0
+  pushl $230
+  jmp __alltraps
+.globl vector231
+vector231:
+  pushl $0
+  pushl $231
+  jmp __alltraps
+.globl vector232
+vector232:
+  pushl $0
+  pushl $232
+  jmp __alltraps
+.globl vector233
+vector233:
+  pushl $0
+  pushl $233
+  jmp __alltraps
+.globl vector234
+vector234:
+  pushl $0
+  pushl $234
+  jmp __alltraps
+.globl vector235
+vector235:
+  pushl $0
+  pushl $235
+  jmp __alltraps
+.globl vector236
+vector236:
+  pushl $0
+  pushl $236
+  jmp __alltraps
+.globl vector237
+vector237:
+  pushl $0
+  pushl $237
+  jmp __alltraps
+.globl vector238
+vector238:
+  pushl $0
+  pushl $238
+  jmp __alltraps
+.globl vector239
+vector239:
+  pushl $0
+  pushl $239
+  jmp __alltraps
+.globl vector240
+vector240:
+  pushl $0
+  pushl $240
+  jmp __alltraps
+.globl vector241
+vector241:
+  pushl $0
+  pushl $241
+  jmp __alltraps
+.globl vector242
+vector242:
+  pushl $0
+  pushl $242
+  jmp __alltraps
+.globl vector243
+vector243:
+  pushl $0
+  pushl $243
+  jmp __alltraps
+.globl vector244
+vector244:
+  pushl $0
+  pushl $244
+  jmp __alltraps
+.globl vector245
+vector245:
+  pushl $0
+  pushl $245
+  jmp __alltraps
+.globl vector246
+vector246:
+  pushl $0
+  pushl $246
+  jmp __alltraps
+.globl vector247
+vector247:
+  pushl $0
+  pushl $247
+  jmp __alltraps
+.globl vector248
+vector248:
+  pushl $0
+  pushl $248
+  jmp __alltraps
+.globl vector249
+vector249:
+  pushl $0
+  pushl $249
+  jmp __alltraps
+.globl vector250
+vector250:
+  pushl $0
+  pushl $250
+  jmp __alltraps
+.globl vector251
+vector251:
+  pushl $0
+  pushl $251
+  jmp __alltraps
+.globl vector252
+vector252:
+  pushl $0
+  pushl $252
+  jmp __alltraps
+.globl vector253
+vector253:
+  pushl $0
+  pushl $253
+  jmp __alltraps
+.globl vector254
+vector254:
+  pushl $0
+  pushl $254
+  jmp __alltraps
+.globl vector255
+vector255:
+  pushl $0
+  pushl $255
+  jmp __alltraps
+
+# vector table
+.data
+.globl __vectors
+__vectors:
+  .long vector0
+  .long vector1
+  .long vector2
+  .long vector3
+  .long vector4
+  .long vector5
+  .long vector6
+  .long vector7
+  .long vector8
+  .long vector9
+  .long vector10
+  .long vector11
+  .long vector12
+  .long vector13
+  .long vector14
+  .long vector15
+  .long vector16
+  .long vector17
+  .long vector18
+  .long vector19
+  .long vector20
+  .long vector21
+  .long vector22
+  .long vector23
+  .long vector24
+  .long vector25
+  .long vector26
+  .long vector27
+  .long vector28
+  .long vector29
+  .long vector30
+  .long vector31
+  .long vector32
+  .long vector33
+  .long vector34
+  .long vector35
+  .long vector36
+  .long vector37
+  .long vector38
+  .long vector39
+  .long vector40
+  .long vector41
+  .long vector42
+  .long vector43
+  .long vector44
+  .long vector45
+  .long vector46
+  .long vector47
+  .long vector48
+  .long vector49
+  .long vector50
+  .long vector51
+  .long vector52
+  .long vector53
+  .long vector54
+  .long vector55
+  .long vector56
+  .long vector57
+  .long vector58
+  .long vector59
+  .long vector60
+  .long vector61
+  .long vector62
+  .long vector63
+  .long vector64
+  .long vector65
+  .long vector66
+  .long vector67
+  .long vector68
+  .long vector69
+  .long vector70
+  .long vector71
+  .long vector72
+  .long vector73
+  .long vector74
+  .long vector75
+  .long vector76
+  .long vector77
+  .long vector78
+  .long vector79
+  .long vector80
+  .long vector81
+  .long vector82
+  .long vector83
+  .long vector84
+  .long vector85
+  .long vector86
+  .long vector87
+  .long vector88
+  .long vector89
+  .long vector90
+  .long vector91
+  .long vector92
+  .long vector93
+  .long vector94
+  .long vector95
+  .long vector96
+  .long vector97
+  .long vector98
+  .long vector99
+  .long vector100
+  .long vector101
+  .long vector102
+  .long vector103
+  .long vector104
+  .long vector105
+  .long vector106
+  .long vector107
+  .long vector108
+  .long vector109
+  .long vector110
+  .long vector111
+  .long vector112
+  .long vector113
+  .long vector114
+  .long vector115
+  .long vector116
+  .long vector117
+  .long vector118
+  .long vector119
+  .long vector120
+  .long vector121
+  .long vector122
+  .long vector123
+  .long vector124
+  .long vector125
+  .long vector126
+  .long vector127
+  .long vector128
+  .long vector129
+  .long vector130
+  .long vector131
+  .long vector132
+  .long vector133
+  .long vector134
+  .long vector135
+  .long vector136
+  .long vector137
+  .long vector138
+  .long vector139
+  .long vector140
+  .long vector141
+  .long vector142
+  .long vector143
+  .long vector144
+  .long vector145
+  .long vector146
+  .long vector147
+  .long vector148
+  .long vector149
+  .long vector150
+  .long vector151
+  .long vector152
+  .long vector153
+  .long vector154
+  .long vector155
+  .long vector156
+  .long vector157
+  .long vector158
+  .long vector159
+  .long vector160
+  .long vector161
+  .long vector162
+  .long vector163
+  .long vector164
+  .long vector165
+  .long vector166
+  .long vector167
+  .long vector168
+  .long vector169
+  .long vector170
+  .long vector171
+  .long vector172
+  .long vector173
+  .long vector174
+  .long vector175
+  .long vector176
+  .long vector177
+  .long vector178
+  .long vector179
+  .long vector180
+  .long vector181
+  .long vector182
+  .long vector183
+  .long vector184
+  .long vector185
+  .long vector186
+  .long vector187
+  .long vector188
+  .long vector189
+  .long vector190
+  .long vector191
+  .long vector192
+  .long vector193
+  .long vector194
+  .long vector195
+  .long vector196
+  .long vector197
+  .long vector198
+  .long vector199
+  .long vector200
+  .long vector201
+  .long vector202
+  .long vector203
+  .long vector204
+  .long vector205
+  .long vector206
+  .long vector207
+  .long vector208
+  .long vector209
+  .long vector210
+  .long vector211
+  .long vector212
+  .long vector213
+  .long vector214
+  .long vector215
+  .long vector216
+  .long vector217
+  .long vector218
+  .long vector219
+  .long vector220
+  .long vector221
+  .long vector222
+  .long vector223
+  .long vector224
+  .long vector225
+  .long vector226
+  .long vector227
+  .long vector228
+  .long vector229
+  .long vector230
+  .long vector231
+  .long vector232
+  .long vector233
+  .long vector234
+  .long vector235
+  .long vector236
+  .long vector237
+  .long vector238
+  .long vector239
+  .long vector240
+  .long vector241
+  .long vector242
+  .long vector243
+  .long vector244
+  .long vector245
+  .long vector246
+  .long vector247
+  .long vector248
+  .long vector249
+  .long vector250
+  .long vector251
+  .long vector252
+  .long vector253
+  .long vector254
+  .long vector255
diff -r -u -P lab2_origin/libs/atomic.h lab2/libs/atomic.h
--- lab2_origin/libs/atomic.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/atomic.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,57 @@
+#ifndef __LIBS_ATOMIC_H__
+#define __LIBS_ATOMIC_H__
+
+/* Atomic operations that C can't guarantee us. Useful for resource counting etc.. */
+
+static inline void set_bit(int nr, volatile void *addr) __attribute__((always_inline));
+static inline void clear_bit(int nr, volatile void *addr) __attribute__((always_inline));
+static inline void change_bit(int nr, volatile void *addr) __attribute__((always_inline));
+static inline bool test_bit(int nr, volatile void *addr) __attribute__((always_inline));
+
+/* *
+ * set_bit - Atomically set a bit in memory
+ * @nr:     the bit to set
+ * @addr:   the address to start counting from
+ *
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+}
+
+/* *
+ * clear_bit - Atomically clears a bit in memory
+ * @nr:     the bit to clear
+ * @addr:   the address to start counting from
+ * */
+static inline void
+clear_bit(int nr, volatile void *addr) {
+    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+}
+
+/* *
+ * change_bit - Atomically toggle a bit in memory
+ * @nr:     the bit to change
+ * @addr:   the address to start counting from
+ * */
+static inline void
+change_bit(int nr, volatile void *addr) {
+    asm volatile ("btcl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+}
+
+/* *
+ * test_bit - Determine whether a bit is set
+ * @nr:     the bit to test
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+    return oldbit != 0;
+}
+
+#endif /* !__LIBS_ATOMIC_H__ */
+
diff -r -u -P lab2_origin/libs/defs.h lab2/libs/defs.h
--- lab2_origin/libs/defs.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/defs.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,68 @@
+#ifndef __LIBS_DEFS_H__
+#define __LIBS_DEFS_H__
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+#define __always_inline inline __attribute__((always_inline))
+#define __noinline __attribute__((noinline))
+#define __noreturn __attribute__((noreturn))
+
+/* Represents true-or-false values */
+typedef int bool;
+
+/* Explicitly-sized versions of integer types */
+typedef char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef long long int64_t;
+typedef unsigned long long uint64_t;
+
+/* *
+ * Pointers and addresses are 32 bits long.
+ * We use pointer types to represent addresses,
+ * uintptr_t to represent the numerical values of addresses.
+ * */
+typedef int32_t intptr_t;
+typedef uint32_t uintptr_t;
+
+/* size_t is used for memory object sizes */
+typedef uintptr_t size_t;
+
+/* used for page numbers */
+typedef size_t ppn_t;
+
+/* *
+ * Rounding operations (efficient when n is a power of 2)
+ * Round down to the nearest multiple of n
+ * */
+#define ROUNDDOWN(a, n) ({                                          \
+            size_t __a = (size_t)(a);                               \
+            (typeof(a))(__a - __a % (n));                           \
+        })
+
+/* Round up to the nearest multiple of n */
+#define ROUNDUP(a, n) ({                                            \
+            size_t __n = (size_t)(n);                               \
+            (typeof(a))(ROUNDDOWN((size_t)(a) + __n - 1, __n));     \
+        })
+
+/* Return the offset of 'member' relative to the beginning of a struct type */
+#define offsetof(type, member)                                      \
+    ((size_t)(&((type *)0)->member))
+
+/* *
+ * to_struct - get the struct from a ptr
+ * @ptr:    a struct pointer of member
+ * @type:   the type of the struct this is embedded in
+ * @member: the name of the member within the struct
+ * */
+#define to_struct(ptr, type, member)                               \
+    ((type *)((char *)(ptr) - offsetof(type, member)))
+
+#endif /* !__LIBS_DEFS_H__ */
+
diff -r -u -P lab2_origin/libs/elf.h lab2/libs/elf.h
--- lab2_origin/libs/elf.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/elf.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,40 @@
+#ifndef __LIBS_ELF_H__
+#define __LIBS_ELF_H__
+
+#include <defs.h>
+
+#define ELF_MAGIC   0x464C457FU         // "\x7FELF" in little endian
+
+/* file header */
+struct elfhdr {
+    uint32_t e_magic;     // must equal ELF_MAGIC
+    uint8_t e_elf[12];
+    uint16_t e_type;      // 1=relocatable, 2=executable, 3=shared object, 4=core image
+    uint16_t e_machine;   // 3=x86, 4=68K, etc.
+    uint32_t e_version;   // file version, always 1
+    uint32_t e_entry;     // entry point if executable
+    uint32_t e_phoff;     // file position of program header or 0
+    uint32_t e_shoff;     // file position of section header or 0
+    uint32_t e_flags;     // architecture-specific flags, usually 0
+    uint16_t e_ehsize;    // size of this elf header
+    uint16_t e_phentsize; // size of an entry in program header
+    uint16_t e_phnum;     // number of entries in program header or 0
+    uint16_t e_shentsize; // size of an entry in section header
+    uint16_t e_shnum;     // number of entries in section header or 0
+    uint16_t e_shstrndx;  // section number that contains section name strings
+};
+
+/* program section header */
+struct proghdr {
+    uint32_t p_type;   // loadable code or data, dynamic linking info,etc.
+    uint32_t p_offset; // file offset of segment
+    uint32_t p_va;     // virtual address to map segment
+    uint32_t p_pa;     // physical address, not used
+    uint32_t p_filesz; // size of segment in file
+    uint32_t p_memsz;  // size of segment in memory (bigger if contains bss）
+    uint32_t p_flags;  // read/write/execute bits
+    uint32_t p_align;  // required alignment, invariably hardware page size
+};
+
+#endif /* !__LIBS_ELF_H__ */
+
diff -r -u -P lab2_origin/libs/error.h lab2/libs/error.h
--- lab2_origin/libs/error.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/error.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,16 @@
+#ifndef __LIBS_ERROR_H__
+#define __LIBS_ERROR_H__
+
+/* kernel error codes -- keep in sync with list in lib/printfmt.c */
+#define E_UNSPECIFIED       1   // Unspecified or unknown problem
+#define E_BAD_PROC          2   // Process doesn't exist or otherwise
+#define E_INVAL             3   // Invalid parameter
+#define E_NO_MEM            4   // Request failed due to memory shortage
+#define E_NO_FREE_PROC      5   // Attempt to create a new process beyond
+#define E_FAULT             6   // Memory fault
+
+/* the maximum allowed */
+#define MAXERROR            6
+
+#endif /* !__LIBS_ERROR_H__ */
+
diff -r -u -P lab2_origin/libs/list.h lab2/libs/list.h
--- lab2_origin/libs/list.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/list.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,163 @@
+#ifndef __LIBS_LIST_H__
+#define __LIBS_LIST_H__
+
+#ifndef __ASSEMBLER__
+
+#include <defs.h>
+
+/* *
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when manipulating
+ * whole lists rather than single entries, as sometimes we already know
+ * the next/prev entries and we can generate better code by using them
+ * directly rather than using the generic single-entry routines.
+ * */
+
+struct list_entry {
+    struct list_entry *prev, *next;
+};
+
+typedef struct list_entry list_entry_t;
+
+static inline void list_init(list_entry_t *elm) __attribute__((always_inline));
+static inline void list_add(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
+static inline void list_add_before(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
+static inline void list_add_after(list_entry_t *listelm, list_entry_t *elm) __attribute__((always_inline));
+static inline void list_del(list_entry_t *listelm) __attribute__((always_inline));
+static inline void list_del_init(list_entry_t *listelm) __attribute__((always_inline));
+static inline bool list_empty(list_entry_t *list) __attribute__((always_inline));
+static inline list_entry_t *list_next(list_entry_t *listelm) __attribute__((always_inline));
+static inline list_entry_t *list_prev(list_entry_t *listelm) __attribute__((always_inline));
+
+static inline void __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));
+static inline void __list_del(list_entry_t *prev, list_entry_t *next) __attribute__((always_inline));
+
+/* *
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+}
+
+/* *
+ * list_add - add a new entry
+ * @listelm:    list head to add after
+ * @elm:        new entry to be added
+ *
+ * Insert the new element @elm *after* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add(list_entry_t *listelm, list_entry_t *elm) {
+    list_add_after(listelm, elm);
+}
+
+/* *
+ * list_add_before - add a new entry
+ * @listelm:    list head to add before
+ * @elm:        new entry to be added
+ *
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+}
+
+/* *
+ * list_add_after - add a new entry
+ * @listelm:    list head to add after
+ * @elm:        new entry to be added
+ *
+ * Insert the new element @elm *after* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_after(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm, listelm->next);
+}
+
+/* *
+ * list_del - deletes entry from list
+ * @listelm:    the element to delete from the list
+ *
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+}
+
+/* *
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @listelm:    the element to delete from the list.
+ *
+ * Note: list_empty() on @listelm returns true after this.
+ * */
+static inline void
+list_del_init(list_entry_t *listelm) {
+    list_del(listelm);
+    list_init(listelm);
+}
+
+/* *
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+}
+
+/* *
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+}
+
+/* *
+ * list_prev - get the previous entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_prev(list_entry_t *listelm) {
+    return listelm->prev;
+}
+
+/* *
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+    elm->next = next;
+    elm->prev = prev;
+}
+
+/* *
+ * Delete a list entry by making the prev/next entries point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+    next->prev = prev;
+}
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* !__LIBS_LIST_H__ */
+
diff -r -u -P lab2_origin/libs/printfmt.c lab2/libs/printfmt.c
--- lab2_origin/libs/printfmt.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/printfmt.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,340 @@
+#include <defs.h>
+#include <x86.h>
+#include <error.h>
+#include <stdio.h>
+#include <string.h>
+
+/* *
+ * Space or zero padding and a field width are supported for the numeric
+ * formats only.
+ *
+ * The special format %e takes an integer error code
+ * and prints a string describing the error.
+ * The integer may be positive or negative,
+ * so that -E_NO_MEM and E_NO_MEM are equivalent.
+ * */
+
+static const char * const error_string[MAXERROR + 1] = {
+    [0]                     NULL,
+    [E_UNSPECIFIED]         "unspecified error",
+    [E_BAD_PROC]            "bad process",
+    [E_INVAL]               "invalid parameter",
+    [E_NO_MEM]              "out of memory",
+    [E_NO_FREE_PROC]        "out of processes",
+    [E_FAULT]               "segmentation fault",
+};
+
+/* *
+ * printnum - print a number (base <= 16) in reverse order
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @num:        the number will be printed
+ * @base:       base for print, must be in [1, 16]
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+    unsigned long long result = num;
+    unsigned mod = do_div(result, base);
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+}
+
+/* *
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+    if (lflag >= 2) {
+        return va_arg(*ap, unsigned long long);
+    }
+    else if (lflag) {
+        return va_arg(*ap, unsigned long);
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+    }
+}
+
+/* *
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+    if (lflag >= 2) {
+        return va_arg(*ap, long long);
+    }
+    else if (lflag) {
+        return va_arg(*ap, long);
+    }
+    else {
+        return va_arg(*ap, int);
+    }
+}
+
+/* *
+ * printfmt - format a string and print it by using putch
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+    va_list ap;
+
+    va_start(ap, fmt);
+    vprintfmt(putch, putdat, fmt, ap);
+    va_end(ap);
+}
+
+/* *
+ * vprintfmt - format a string and print it by using putch, it's called with a va_list
+ * instead of a variable number of arguments
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * @ap:         arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+    register const char *p;
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+            if (ch == '\0') {
+                return;
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+        width = precision = -1;
+        lflag = altflag = 0;
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+            goto reswitch;
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+            goto process_precision;
+
+        case '*':
+            precision = va_arg(ap, int);
+            goto process_precision;
+
+        case '.':
+            if (width < 0)
+                width = 0;
+            goto reswitch;
+
+        case '#':
+            altflag = 1;
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+                width = precision, precision = -1;
+            goto reswitch;
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+            goto reswitch;
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+            break;
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+            if (err < 0) {
+                err = -err;
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+                if (altflag && (ch < ' ' || ch > '~')) {
+                    putch('?', putdat);
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+                putch(' ', putdat);
+            }
+            break;
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+            if ((long long)num < 0) {
+                putch('-', putdat);
+                num = -(long long)num;
+            }
+            base = 10;
+            goto number;
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+            base = 10;
+            goto number;
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+            base = 8;
+            goto number;
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+            putch('x', putdat);
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+            base = 16;
+            goto number;
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+            base = 16;
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+            break;
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+            break;
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+
+/* sprintbuf is used to save enough information of a buffer */
+struct sprintbuf {
+    char *buf;          // address pointer points to the first unused memory
+    char *ebuf;         // points the end of the buffer
+    int cnt;            // the number of characters that have been placed in this buffer
+};
+
+/* *
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+    b->cnt ++;
+    if (b->buf < b->ebuf) {
+        *b->buf ++ = ch;
+    }
+}
+
+/* *
+ * snprintf - format a string and place it in a buffer
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+    cnt = vsnprintf(str, size, fmt, ap);
+    va_end(ap);
+    return cnt;
+}
+
+/* *
+ * vsnprintf - format a string and place it in a buffer, it's called with a va_list
+ * instead of a variable number of arguments
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * @ap:         arguments for the format string
+ *
+ * The return value is the number of characters which would be generated for the
+ * given input, excluding the trailing '\0'.
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+    struct sprintbuf b = {str, str + size - 1, 0};
+    if (str == NULL || b.buf > b.ebuf) {
+        return -E_INVAL;
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+    // null terminate the buffer
+    *b.buf = '\0';
+    return b.cnt;
+}
+
diff -r -u -P lab2_origin/libs/stdarg.h lab2/libs/stdarg.h
--- lab2_origin/libs/stdarg.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/stdarg.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,12 @@
+#ifndef __LIBS_STDARG_H__
+#define __LIBS_STDARG_H__
+
+/* compiler provides size of save area */
+typedef __builtin_va_list va_list;
+
+#define va_start(ap, last)              (__builtin_va_start(ap, last))
+#define va_arg(ap, type)                (__builtin_va_arg(ap, type))
+#define va_end(ap)                      /*nothing*/
+
+#endif /* !__LIBS_STDARG_H__ */
+
diff -r -u -P lab2_origin/libs/stdio.h lab2/libs/stdio.h
--- lab2_origin/libs/stdio.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/stdio.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,24 @@
+#ifndef __LIBS_STDIO_H__
+#define __LIBS_STDIO_H__
+
+#include <defs.h>
+#include <stdarg.h>
+
+/* kern/libs/stdio.c */
+int cprintf(const char *fmt, ...);
+int vcprintf(const char *fmt, va_list ap);
+void cputchar(int c);
+int cputs(const char *str);
+int getchar(void);
+
+/* kern/libs/readline.c */
+char *readline(const char *prompt);
+
+/* libs/printfmt.c */
+void printfmt(void (*putch)(int, void *), void *putdat, const char *fmt, ...);
+void vprintfmt(void (*putch)(int, void *), void *putdat, const char *fmt, va_list ap);
+int snprintf(char *str, size_t size, const char *fmt, ...);
+int vsnprintf(char *str, size_t size, const char *fmt, va_list ap);
+
+#endif /* !__LIBS_STDIO_H__ */
+
diff -r -u -P lab2_origin/libs/string.c lab2/libs/string.c
--- lab2_origin/libs/string.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/string.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,367 @@
+#include <string.h>
+#include <x86.h>
+
+/* *
+ * strlen - calculate the length of the string @s, not including
+ * the terminating '\0' character.
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+        cnt ++;
+    }
+    return cnt;
+}
+
+/* *
+ * strnlen - calculate the length of the string @s, not including
+ * the terminating '\0' char acter, but at most @len.
+ * @s:      the input string
+ * @len:    the max-length that function will scan
+ *
+ * Note that, this function looks only at the first @len characters
+ * at @s, and never beyond @s + @len.
+ *
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+        cnt ++;
+    }
+    return cnt;
+}
+
+/* *
+ * strcpy - copies the string pointed by @src into the array pointed by @dst,
+ * including the terminating null character.
+ * @dst:    pointer to the destination array where the content is to be copied
+ * @src:    string to be copied
+ *
+ * The return value is @dst.
+ *
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+#ifdef __HAVE_ARCH_STRCPY
+    return __strcpy(dst, src);
+#else
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+
+/* *
+ * strncpy - copies the first @len characters of @src to @dst. If the end of string @src
+ * if found before @len characters have been copied, @dst is padded with '\0' until a
+ * total of @len characters have been written to it.
+ * @dst:    pointer to the destination array where the content is to be copied
+ * @src:    string to be copied
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+}
+
+/* *
+ * strcmp - compares the string @s1 and @s2
+ * @s1:     string to be compared
+ * @s2:     string to be compared
+ *
+ * This function starts comparing the first character of each string. If
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ or until a terminanting null-character is reached.
+ *
+ * Returns an integral value indicating the relationship between the strings:
+ * - A zero value indicates that both strings are equal;
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+#ifdef __HAVE_ARCH_STRCMP
+    return __strcmp(s1, s2);
+#else
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+
+/* *
+ * strncmp - compares up to @n characters of the string @s1 to those of the string @s2
+ * @s1:     string to be compared
+ * @s2:     string to be compared
+ * @n:      maximum number of characters to compare
+ *
+ * This function starts comparing the first character of each string. If
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+}
+
+/* *
+ * strchr - locates first occurrence of character in string
+ * @s:      the input string
+ * @c:      character to be located
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+}
+
+/* *
+ * strfind - locates first occurrence of character in string
+ * @s:      the input string
+ * @c:      character to be located
+ *
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+        if (*s == c) {
+            break;
+        }
+        s ++;
+    }
+    return (char *)s;
+}
+
+/* *
+ * strtol - converts string to long integer
+ * @s:      the input string that contains the representation of an integer number
+ * @endptr: reference to an object of type char *, whose value is set by the
+ *          function to the next character in @s after the numerical value. This
+ *          parameter can also be a null pointer, in which case it is not used.
+ * @base:   x
+ *
+ * The function first discards as many whitespace characters as necessary until
+ * the first non-whitespace character is found. Then, starting from this character,
+ * takes as many characters as possible that are valid following a syntax that
+ * depends on the base parameter, and interprets them as a numerical value. Finally,
+ * a pointer to the first character following the integer representation in @s
+ * is stored in the object pointed by @endptr.
+ *
+ * If the value of base is zero, the syntax expected is similar to that of
+ * integer constants, which is formed by a succession of:
+ * - An optional plus or minus sign;
+ * - An optional prefix indicating octal or hexadecimal base ("0" or "0x" respectively)
+ * - A sequence of decimal digits (if no base prefix was specified) or either octal
+ *   or hexadecimal digits if a specific prefix is present
+ *
+ * If the base value is between 2 and 36, the format expected for the integral number
+ * is a succession of the valid digits and/or letters needed to represent integers of
+ * the specified radix (starting from '0' and up to 'z'/'Z' for radix 36). The
+ * sequence may optionally be preceded by a plus or minus sign and, if base is 16,
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+        s ++;
+    }
+    else if (*s == '-') {
+        s ++, neg = 1;
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+        s += 2, base = 16;
+    }
+    else if (base == 0 && s[0] == '0') {
+        s ++, base = 8;
+    }
+    else if (base == 0) {
+        base = 10;
+    }
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+            dig = *s - '0';
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+            dig = *s - 'a' + 10;
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+            dig = *s - 'A' + 10;
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+            break;
+        }
+        s ++, val = (val * base) + dig;
+        // we don't properly detect overflow!
+    }
+
+    if (endptr) {
+        *endptr = (char *) s;
+    }
+    return (neg ? -val : val);
+}
+
+/* *
+ * memset - sets the first @n bytes of the memory area pointed by @s
+ * to the specified value @c.
+ * @s:      pointer the the memory area to fill
+ * @c:      value to set
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+#else
+    char *p = s;
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+
+/* *
+ * memmove - copies the values of @n bytes from the location pointed by @src to
+ * the memory area pointed by @dst. @src and @dst are allowed to overlap.
+ * @dst     pointer to the destination array where the content is to be copied
+ * @src     pointer to the source of data to by copied
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+#ifdef __HAVE_ARCH_MEMMOVE
+    return __memmove(dst, src, n);
+#else
+    const char *s = src;
+    char *d = dst;
+    if (s < d && s + n > d) {
+        s += n, d += n;
+        while (n -- > 0) {
+            *-- d = *-- s;
+        }
+    } else {
+        while (n -- > 0) {
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+
+/* *
+ * memcpy - copies the value of @n bytes from the location pointed by @src to
+ * the memory area pointed by @dst.
+ * @dst     pointer to the destination array where the content is to be copied
+ * @src     pointer to the source of data to by copied
+ * @n:      number of bytes to copy
+ *
+ * The memcpy() returns @dst.
+ *
+ * Note that, the function does not check any terminating null character in @src,
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+#ifdef __HAVE_ARCH_MEMCPY
+    return __memcpy(dst, src, n);
+#else
+    const char *s = src;
+    char *d = dst;
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+
+/* *
+ * memcmp - compares two blocks of memory
+ * @v1:     pointer to block of memory
+ * @v2:     pointer to block of memory
+ * @n:      number of bytes to compare
+ *
+ * The memcmp() functions returns an integral value indicating the
+ * relationship between the content of the memory blocks:
+ * - A zero value indicates that the contents of both memory blocks are equal;
+ * - A value greater than zero indicates that the first byte that does not
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+}
+
diff -r -u -P lab2_origin/libs/string.h lab2/libs/string.h
--- lab2_origin/libs/string.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/string.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,25 @@
+#ifndef __LIBS_STRING_H__
+#define __LIBS_STRING_H__
+
+#include <defs.h>
+
+size_t strlen(const char *s);
+size_t strnlen(const char *s, size_t len);
+
+char *strcpy(char *dst, const char *src);
+char *strncpy(char *dst, const char *src, size_t len);
+
+int strcmp(const char *s1, const char *s2);
+int strncmp(const char *s1, const char *s2, size_t n);
+
+char *strchr(const char *s, char c);
+char *strfind(const char *s, char c);
+long strtol(const char *s, char **endptr, int base);
+
+void *memset(void *s, char c, size_t n);
+void *memmove(void *dst, const void *src, size_t n);
+void *memcpy(void *dst, const void *src, size_t n);
+int memcmp(const void *v1, const void *v2, size_t n);
+
+#endif /* !__LIBS_STRING_H__ */
+
diff -r -u -P lab2_origin/libs/x86.h lab2/libs/x86.h
--- lab2_origin/libs/x86.h	1970-01-01 08:00:00.000000000 +0800
+++ lab2/libs/x86.h	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,302 @@
+#ifndef __LIBS_X86_H__
+#define __LIBS_X86_H__
+
+#include <defs.h>
+
+#define do_div(n, base) ({                                          \
+            unsigned long __upper, __low, __high, __mod, __base;    \
+            __base = (base);                                        \
+            asm ("" : "=a" (__low), "=d" (__high) : "A" (n));       \
+            __upper = __high;                                       \
+            if (__high != 0) {                                      \
+                __upper = __high % __base;                          \
+                __high = __high / __base;                           \
+            }                                                       \
+            asm ("divl %2" : "=a" (__low), "=d" (__mod)             \
+                : "rm" (__base), "0" (__low), "1" (__upper));       \
+            asm ("" : "=A" (n) : "a" (__low), "d" (__high));        \
+            __mod;                                                  \
+        })
+
+#define barrier() __asm__ __volatile__ ("" ::: "memory")
+
+static inline uint8_t inb(uint16_t port) __attribute__((always_inline));
+static inline void insl(uint32_t port, void *addr, int cnt) __attribute__((always_inline));
+static inline void outb(uint16_t port, uint8_t data) __attribute__((always_inline));
+static inline void outw(uint16_t port, uint16_t data) __attribute__((always_inline));
+static inline void outsl(uint32_t port, const void *addr, int cnt) __attribute__((always_inline));
+static inline uint32_t read_ebp(void) __attribute__((always_inline));
+static inline void breakpoint(void) __attribute__((always_inline));
+static inline uint32_t read_dr(unsigned regnum) __attribute__((always_inline));
+static inline void write_dr(unsigned regnum, uint32_t value) __attribute__((always_inline));
+
+/* Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. */
+struct pseudodesc {
+    uint16_t pd_lim;        // Limit
+    uintptr_t pd_base;      // Base address
+} __attribute__ ((packed));
+
+static inline void lidt(struct pseudodesc *pd) __attribute__((always_inline));
+static inline void sti(void) __attribute__((always_inline));
+static inline void cli(void) __attribute__((always_inline));
+static inline void ltr(uint16_t sel) __attribute__((always_inline));
+static inline uint32_t read_eflags(void) __attribute__((always_inline));
+static inline void write_eflags(uint32_t eflags) __attribute__((always_inline));
+static inline void lcr0(uintptr_t cr0) __attribute__((always_inline));
+static inline void lcr3(uintptr_t cr3) __attribute__((always_inline));
+static inline uintptr_t rcr0(void) __attribute__((always_inline));
+static inline uintptr_t rcr1(void) __attribute__((always_inline));
+static inline uintptr_t rcr2(void) __attribute__((always_inline));
+static inline uintptr_t rcr3(void) __attribute__((always_inline));
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+    return data;
+}
+
+static inline void
+insl(uint32_t port, void *addr, int cnt) {
+    asm volatile (
+        "cld;"
+        "repne; insl;"
+        : "=D" (addr), "=c" (cnt)
+        : "d" (port), "0" (addr), "1" (cnt)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+}
+
+static inline void
+outw(uint16_t port, uint16_t data) {
+    asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
+}
+
+static inline void
+outsl(uint32_t port, const void *addr, int cnt) {
+    asm volatile (
+        "cld;"
+        "repne; outsl;"
+        : "=S" (addr), "=c" (cnt)
+        : "d" (port), "0" (addr), "1" (cnt)
+        : "memory", "cc");
+}
+
+static inline uint32_t
+read_ebp(void) {
+    uint32_t ebp;
+    asm volatile ("movl %%ebp, %0" : "=r" (ebp));
+    return ebp;
+}
+
+static inline void
+breakpoint(void) {
+    asm volatile ("int $3");
+}
+
+static inline uint32_t
+read_dr(unsigned regnum) {
+    uint32_t value = 0;
+    switch (regnum) {
+    case 0: asm volatile ("movl %%db0, %0" : "=r" (value)); break;
+    case 1: asm volatile ("movl %%db1, %0" : "=r" (value)); break;
+    case 2: asm volatile ("movl %%db2, %0" : "=r" (value)); break;
+    case 3: asm volatile ("movl %%db3, %0" : "=r" (value)); break;
+    case 6: asm volatile ("movl %%db6, %0" : "=r" (value)); break;
+    case 7: asm volatile ("movl %%db7, %0" : "=r" (value)); break;
+    }
+    return value;
+}
+
+static void
+write_dr(unsigned regnum, uint32_t value) {
+    switch (regnum) {
+    case 0: asm volatile ("movl %0, %%db0" :: "r" (value)); break;
+    case 1: asm volatile ("movl %0, %%db1" :: "r" (value)); break;
+    case 2: asm volatile ("movl %0, %%db2" :: "r" (value)); break;
+    case 3: asm volatile ("movl %0, %%db3" :: "r" (value)); break;
+    case 6: asm volatile ("movl %0, %%db6" :: "r" (value)); break;
+    case 7: asm volatile ("movl %0, %%db7" :: "r" (value)); break;
+    }
+}
+
+static inline void
+lidt(struct pseudodesc *pd) {
+    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+}
+
+static inline void
+sti(void) {
+    asm volatile ("sti");
+}
+
+static inline void
+cli(void) {
+    asm volatile ("cli" ::: "memory");
+}
+
+static inline void
+ltr(uint16_t sel) {
+    asm volatile ("ltr %0" :: "r" (sel) : "memory");
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+    return eflags;
+}
+
+static inline void
+write_eflags(uint32_t eflags) {
+    asm volatile ("pushl %0; popfl" :: "r" (eflags));
+}
+
+static inline void
+lcr0(uintptr_t cr0) {
+    asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
+}
+
+static inline void
+lcr3(uintptr_t cr3) {
+    asm volatile ("mov %0, %%cr3" :: "r" (cr3) : "memory");
+}
+
+static inline uintptr_t
+rcr0(void) {
+    uintptr_t cr0;
+    asm volatile ("mov %%cr0, %0" : "=r" (cr0) :: "memory");
+    return cr0;
+}
+
+static inline uintptr_t
+rcr1(void) {
+    uintptr_t cr1;
+    asm volatile ("mov %%cr1, %0" : "=r" (cr1) :: "memory");
+    return cr1;
+}
+
+static inline uintptr_t
+rcr2(void) {
+    uintptr_t cr2;
+    asm volatile ("mov %%cr2, %0" : "=r" (cr2) :: "memory");
+    return cr2;
+}
+
+static inline uintptr_t
+rcr3(void) {
+    uintptr_t cr3;
+    asm volatile ("mov %%cr3, %0" : "=r" (cr3) :: "memory");
+    return cr3;
+}
+
+static inline void
+invlpg(void *addr) {
+    asm volatile ("invlpg (%0)" :: "r" (addr) : "memory");
+}
+
+static inline int __strcmp(const char *s1, const char *s2) __attribute__((always_inline));
+static inline char *__strcpy(char *dst, const char *src) __attribute__((always_inline));
+static inline void *__memset(void *s, char c, size_t n) __attribute__((always_inline));
+static inline void *__memmove(void *dst, const void *src, size_t n) __attribute__((always_inline));
+static inline void *__memcpy(void *dst, const void *src, size_t n) __attribute__((always_inline));
+
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+        "1: lodsb;"
+        "scasb;"
+        "jne 2f;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        "xorl %%eax, %%eax;"
+        "jmp 3f;"
+        "2: sbbl %%eax, %%eax;"
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+}
+
+#endif /* __HAVE_ARCH_STRCMP */
+
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+        "1: lodsb;"
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+}
+#endif /* __HAVE_ARCH_STRCPY */
+
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+}
+#endif /* __HAVE_ARCH_MEMSET */
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+}
+#endif /* __HAVE_ARCH_MEMMOVE */
+
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+        "rep; movsl;"
+        "movl %4, %%ecx;"
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+}
+#endif /* __HAVE_ARCH_MEMCPY */
+
+#endif /* !__LIBS_X86_H__ */
+
diff -r -u -P lab2_origin/Makefile lab2/Makefile
--- lab2_origin/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ lab2/Makefile	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,292 @@
+PROJ	:= 5
+EMPTY	:=
+SPACE	:= $(EMPTY) $(EMPTY)
+SLASH	:= /
+
+V       := @
+#need llvm/cang-3.5+
+#USELLVM := 1
+# try to infer the correct GCCPREFX
+ifndef GCCPREFIX
+GCCPREFIX := $(shell if i386-ucore-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-ucore-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-ucore-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-ucore-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-ucore-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-ucore-elf-', set your GCCPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# try to infer the correct QEMU
+ifndef QEMU
+QEMU := $(shell if which qemu-system-i386 > /dev/null; \
+	then echo 'qemu-system-i386'; exit; \
+	elif which i386-elf-qemu > /dev/null; \
+	then echo 'i386-elf-qemu'; exit; \
+	elif which qemu > /dev/null; \
+	then echo 'qemu'; exit; \
+	else \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# eliminate default suffix rules
+.SUFFIXES: .c .S .h
+
+# delete target files if there is an error (or make is interrupted)
+.DELETE_ON_ERROR:
+
+# define compiler and flags
+ifndef  USELLVM
+HOSTCC		:= gcc
+HOSTCFLAGS	:= -g -Wall -O2
+CC		:= $(GCCPREFIX)gcc
+CFLAGS	:= -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
+CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+else
+HOSTCC		:= clang
+HOSTCFLAGS	:= -g -Wall -O2
+CC		:= $(GCCPREFIX)clang
+CFLAGS	:= -fno-builtin -Wall -g -m32 -mno-sse -nostdinc $(DEFS)
+CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+endif
+
+GDB		:= $(GCCPREFIX)gdb
+CTYPE	:= c S
+
+LD      := $(GCCPREFIX)ld
+LDFLAGS	:= -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
+LDFLAGS	+= -nostdlib
+
+OBJCOPY := $(GCCPREFIX)objcopy
+OBJDUMP := $(GCCPREFIX)objdump
+
+COPY	:= cp
+MKDIR   := mkdir -p
+MV		:= mv
+RM		:= rm -f
+AWK		:= awk
+SED		:= sed
+SH		:= sh
+TR		:= tr
+TOUCH	:= touch -c
+
+TAR		:= tar
+ZIP		:= gzip
+
+OBJDIR	:= obj
+BINDIR	:= bin
+
+ALLOBJS	:=
+ALLDEPS	:=
+TARGETS	:=
+
+include tools/function.mk
+
+listf_cc = $(call listf,$(1),$(CTYPE))
+
+# for cc
+add_files_cc = $(call add_files,$(1),$(CC),$(CFLAGS) $(3),$(2),$(4))
+create_target_cc = $(call create_target,$(1),$(2),$(3),$(CC),$(CFLAGS))
+
+# for hostcc
+add_files_host = $(call add_files,$(1),$(HOSTCC),$(HOSTCFLAGS),$(2),$(3))
+create_target_host = $(call create_target,$(1),$(2),$(3),$(HOSTCC),$(HOSTCFLAGS))
+
+cgtype = $(patsubst %.$(2),%.$(3),$(1))
+objfile = $(call toobj,$(1))
+asmfile = $(call cgtype,$(call toobj,$(1)),o,asm)
+outfile = $(call cgtype,$(call toobj,$(1)),o,out)
+symfile = $(call cgtype,$(call toobj,$(1)),o,sym)
+
+# for match pattern
+match = $(shell echo $(2) | $(AWK) '{for(i=1;i<=NF;i++){if(match("$(1)","^"$$(i)"$$")){exit 1;}}}'; echo $$?)
+
+# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+# include kernel/user
+
+INCLUDE	+= libs/
+
+CFLAGS	+= $(addprefix -I,$(INCLUDE))
+
+LIBDIR	+= libs
+
+$(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)
+
+# -------------------------------------------------------------------
+# kernel
+
+KINCLUDE	+= kern/debug/ \
+			   kern/driver/ \
+			   kern/trap/ \
+			   kern/mm/ \
+			   kern/libs/ \
+			   kern/sync/
+
+KSRCDIR		+= kern/init \
+			   kern/libs \
+			   kern/debug \
+			   kern/driver \
+			   kern/trap \
+			   kern/mm \
+			   kern/sync
+
+KCFLAGS		+= $(addprefix -I,$(KINCLUDE))
+
+$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
+
+KOBJS	= $(call read_packet,kernel libs)
+
+# create kernel target
+kernel = $(call totarget,kernel)
+
+$(kernel): tools/kernel.ld
+
+$(kernel): $(KOBJS)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
+	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
+	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)
+
+$(call create_target,kernel)
+
+
+# create kernel_nopage target
+kernel_nopage = $(call totarget,kernel_nopage)
+
+$(kernel_nopage): tools/kernel_nopage.ld
+
+$(kernel_nopage): $(KOBJS)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -T tools/kernel_nopage.ld -o $@ $(KOBJS)
+	@$(OBJDUMP) -S $@ > $(call asmfile,kernel_nopage)
+	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel_nopage)
+
+$(call create_target,kernel)
+
+# -------------------------------------------------------------------
+
+# create bootblock
+bootfiles = $(call listf_cc,boot)
+$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))
+
+bootblock = $(call totarget,bootblock)
+
+$(bootblock): $(call toobj,boot/bootasm.S) $(call toobj,$(bootfiles)) | $(call totarget,sign)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -N -T tools/boot.ld $^ -o $(call toobj,bootblock)
+	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
+	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
+	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
+
+$(call create_target,bootblock)
+
+# -------------------------------------------------------------------
+
+# create 'sign' tools
+$(call add_files_host,tools/sign.c,sign,sign)
+$(call create_target_host,sign,sign)
+
+# -------------------------------------------------------------------
+
+# create ucore.img
+UCOREIMG	:= $(call totarget,ucore.img)
+
+$(UCOREIMG): $(kernel) $(bootblock) $(kernel_nopage)
+	$(V)dd if=/dev/zero of=$@ count=10000
+	$(V)dd if=$(bootblock) of=$@ conv=notrunc
+	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
+
+$(call create_target,ucore.img)
+
+# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+$(call finish_all)
+
+IGNORE_ALLDEPS	= gdb \
+				  clean \
+				  distclean \
+				  grade \
+				  touch \
+				  print-.+ \
+				  handin
+
+ifeq ($(call match,$(MAKECMDGOALS),$(IGNORE_ALLDEPS)),0)
+-include $(ALLDEPS)
+endif
+
+# files for grade script
+
+targets: $(TARGETS)
+
+.DEFAULT_GOAL := targets
+
+QEMUOPTS = -hda $(UCOREIMG)
+
+.PHONY: qemu qemu-nox gdb debug debug-mon debug-nox
+qemu-mon: targets
+	$(V)$(QEMU) -monitor stdio $(QEMUOPTS) -serial null
+qemu: targets
+	$(V)$(QEMU) -parallel stdio $(QEMUOPTS) -serial null
+
+qemu-nox: targets
+	$(V)$(QEMU) -serial mon:stdio $(QEMUOPTS) -nographic
+
+gdb:
+	$(V)$(GDB) -q -x tools/gdbinit
+
+debug: targets
+	$(V)$(QEMU) -S -s -parallel stdio $(QEMUOPTS) -serial null
+
+debug-mon: targets
+	$(V)$(QEMU) -S -s -monitor stdio $(QEMUOPTS) -parallel null -serial null
+
+debug-nox: targets
+	$(V)$(QEMU) -S -s -serial mon:stdio $(QEMUOPTS) -nographic
+
+.PHONY: grade touch
+
+GRADE_GDB_IN	:= .gdb.in
+GRADE_QEMU_OUT	:= .qemu.out
+HANDIN			:= lab2-handin.tar.gz
+
+TOUCH_FILES		:= kern/trap/trap.c
+
+MAKEOPTS		:= --quiet --no-print-directory
+
+grade:
+	$(V)$(MAKE) $(MAKEOPTS) clean
+	$(V)$(SH) tools/grade.sh
+
+touch:
+	$(V)$(foreach f,$(TOUCH_FILES),$(TOUCH) $(f))
+
+print-%:
+	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
+
+.PHONY: clean distclean handin tags
+clean:
+	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT) cscope* tags
+	$(V)$(RM) -r $(OBJDIR) $(BINDIR)
+
+distclean: clean
+	$(V)$(RM) $(HANDIN)
+
+handin: distclean
+	$(V)$(TAR) -cf - `find . -type f -o -type d | grep -v '^\.$$' | grep -v '/CVS/' \
+					| grep -v '/\.git/' | grep -v '/\.svn/' | grep -v "$(HANDIN)"` \
+					| $(ZIP) > $(HANDIN)
+					
+tags:
+	@echo TAGS ALL
+	$(V)rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags
+	$(V)find . -type f -name "*.[chS]" >cscope.files
+	$(V)cscope -bq 
+	$(V)ctags -L cscope.files
diff -r -u -P lab2_origin/obj/boot/bootasm.d lab2/obj/boot/bootasm.d
--- lab2_origin/obj/boot/bootasm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/boot/bootasm.d	2021-08-29 21:35:37.854604853 +0800
@@ -0,0 +1 @@
+obj/boot/bootasm.o obj/boot/bootasm.d: boot/bootasm.S boot/asm.h
Binary files lab2_origin/obj/boot/bootasm.o and lab2/obj/boot/bootasm.o differ
diff -r -u -P lab2_origin/obj/boot/bootmain.d lab2/obj/boot/bootmain.d
--- lab2_origin/obj/boot/bootmain.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/boot/bootmain.d	2021-08-29 21:35:37.862604853 +0800
@@ -0,0 +1,2 @@
+obj/boot/bootmain.o obj/boot/bootmain.d: boot/bootmain.c libs/defs.h \
+ libs/x86.h libs/elf.h
Binary files lab2_origin/obj/boot/bootmain.o and lab2/obj/boot/bootmain.o differ
diff -r -u -P lab2_origin/obj/bootblock.asm lab2/obj/bootblock.asm
--- lab2_origin/obj/bootblock.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/bootblock.asm	2021-08-29 21:35:38.830604847 +0800
@@ -0,0 +1,433 @@
+
+obj/bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .startup:
+
+00007c00 <start>:
+
+# start address should be 0:7c00, in real mode, the beginning address of the running bootloader
+.globl start
+start:
+.code16                                             # Assemble for 16-bit mode
+    cli                                             # Disable interrupts
+    7c00:	fa                   	cli    
+    cld                                             # String operations increment
+    7c01:	fc                   	cld    
+
+    # Set up the important data segment registers (DS, ES, SS).
+    xorw %ax, %ax                                   # Segment number zero
+    7c02:	31 c0                	xor    %eax,%eax
+    movw %ax, %ds                                   # -> Data Segment
+    7c04:	8e d8                	mov    %eax,%ds
+    movw %ax, %es                                   # -> Extra Segment
+    7c06:	8e c0                	mov    %eax,%es
+    movw %ax, %ss                                   # -> Stack Segment
+    7c08:	8e d0                	mov    %eax,%ss
+
+00007c0a <seta20.1>:
+    # Enable A20:
+    #  For backwards compatibility with the earliest PCs, physical
+    #  address line 20 is tied low, so that addresses higher than
+    #  1MB wrap around to zero by default. This code undoes this.
+seta20.1:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    7c0a:	e4 64                	in     $0x64,%al
+    testb $0x2, %al
+    7c0c:	a8 02                	test   $0x2,%al
+    jnz seta20.1
+    7c0e:	75 fa                	jne    7c0a <seta20.1>
+
+    movb $0xd1, %al                                 # 0xd1 -> port 0x64
+    7c10:	b0 d1                	mov    $0xd1,%al
+    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
+    7c12:	e6 64                	out    %al,$0x64
+
+00007c14 <seta20.2>:
+
+seta20.2:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    7c14:	e4 64                	in     $0x64,%al
+    testb $0x2, %al
+    7c16:	a8 02                	test   $0x2,%al
+    jnz seta20.2
+    7c18:	75 fa                	jne    7c14 <seta20.2>
+
+    movb $0xdf, %al                                 # 0xdf -> port 0x60
+    7c1a:	b0 df                	mov    $0xdf,%al
+    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
+    7c1c:	e6 60                	out    %al,$0x60
+
+00007c1e <probe_memory>:
+
+probe_memory:
+    movl $0, 0x8000
+    7c1e:	66 c7 06 00 80       	movw   $0x8000,(%esi)
+    7c23:	00 00                	add    %al,(%eax)
+    7c25:	00 00                	add    %al,(%eax)
+    xorl %ebx, %ebx
+    7c27:	66 31 db             	xor    %bx,%bx
+    movw $0x8004, %di
+    7c2a:	bf 04 80 66 b8       	mov    $0xb8668004,%edi
+
+00007c2d <start_probe>:
+start_probe:
+    movl $0xE820, %eax
+    7c2d:	66 b8 20 e8          	mov    $0xe820,%ax
+    7c31:	00 00                	add    %al,(%eax)
+    movl $20, %ecx
+    7c33:	66 b9 14 00          	mov    $0x14,%cx
+    7c37:	00 00                	add    %al,(%eax)
+    movl $SMAP, %edx
+    7c39:	66 ba 50 41          	mov    $0x4150,%dx
+    7c3d:	4d                   	dec    %ebp
+    7c3e:	53                   	push   %ebx
+    int $0x15
+    7c3f:	cd 15                	int    $0x15
+    jnc cont
+    7c41:	73 08                	jae    7c4b <cont>
+    movw $12345, 0x8000
+    7c43:	c7 06 00 80 39 30    	movl   $0x30398000,(%esi)
+    jmp finish_probe
+    7c49:	eb 0e                	jmp    7c59 <finish_probe>
+
+00007c4b <cont>:
+cont:
+    addw $20, %di
+    7c4b:	83 c7 14             	add    $0x14,%edi
+    incl 0x8000
+    7c4e:	66 ff 06             	incw   (%esi)
+    7c51:	00 80 66 83 fb 00    	add    %al,0xfb8366(%eax)
+    cmpl $0, %ebx
+    jnz start_probe
+    7c57:	75 d4                	jne    7c2d <start_probe>
+
+00007c59 <finish_probe>:
+
+    # Switch from real to protected mode, using a bootstrap GDT
+    # and segment translation that makes virtual addresses
+    # identical to physical addresses, so that the
+    # effective memory map does not change during the switch.
+    lgdt gdtdesc
+    7c59:	0f 01 16             	lgdtl  (%esi)
+    7c5c:	ac                   	lods   %ds:(%esi),%al
+    7c5d:	7d 0f                	jge    7c6e <protcseg+0x1>
+    movl %cr0, %eax
+    7c5f:	20 c0                	and    %al,%al
+    orl $CR0_PE_ON, %eax
+    7c61:	66 83 c8 01          	or     $0x1,%ax
+    movl %eax, %cr0
+    7c65:	0f 22 c0             	mov    %eax,%cr0
+
+    # Jump to next instruction, but in 32-bit code segment.
+    # Switches processor into 32-bit mode.
+    ljmp $PROT_MODE_CSEG, $protcseg
+    7c68:	ea 6d 7c 08 00 66 b8 	ljmp   $0xb866,$0x87c6d
+
+00007c6d <protcseg>:
+
+.code32                                             # Assemble for 32-bit mode
+protcseg:
+    # Set up the protected-mode data segment registers
+    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
+    7c6d:	66 b8 10 00          	mov    $0x10,%ax
+    movw %ax, %ds                                   # -> DS: Data Segment
+    7c71:	8e d8                	mov    %eax,%ds
+    movw %ax, %es                                   # -> ES: Extra Segment
+    7c73:	8e c0                	mov    %eax,%es
+    movw %ax, %fs                                   # -> FS
+    7c75:	8e e0                	mov    %eax,%fs
+    movw %ax, %gs                                   # -> GS
+    7c77:	8e e8                	mov    %eax,%gs
+    movw %ax, %ss                                   # -> SS: Stack Segment
+    7c79:	8e d0                	mov    %eax,%ss
+
+    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
+    movl $0x0, %ebp
+    7c7b:	bd 00 00 00 00       	mov    $0x0,%ebp
+    movl $start, %esp
+    7c80:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+    call bootmain
+    7c85:	e8 61 00 00 00       	call   7ceb <bootmain>
+
+00007c8a <spin>:
+
+    # If bootmain returns (it shouldn't), loop.
+spin:
+    jmp spin
+    7c8a:	eb fe                	jmp    7c8a <spin>
+
+Disassembly of section .text:
+
+00007c8c <readsect>:
+        /* do nothing */;
+}
+
+/* readsect - read a single sector at @secno into @dst */
+static void
+readsect(void *dst, uint32_t secno) {
+    7c8c:	55                   	push   %ebp
+    7c8d:	89 d1                	mov    %edx,%ecx
+    7c8f:	89 e5                	mov    %esp,%ebp
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+    7c91:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c96:	57                   	push   %edi
+    7c97:	89 c7                	mov    %eax,%edi
+    7c99:	ec                   	in     (%dx),%al
+#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space
+
+/* waitdisk - wait for disk ready */
+static void
+waitdisk(void) {
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+    7c9a:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c9d:	3c 40                	cmp    $0x40,%al
+    7c9f:	75 f8                	jne    7c99 <readsect+0xd>
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+    7ca1:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7ca6:	b0 01                	mov    $0x1,%al
+    7ca8:	ee                   	out    %al,(%dx)
+    7ca9:	0f b6 c1             	movzbl %cl,%eax
+    7cac:	b2 f3                	mov    $0xf3,%dl
+    7cae:	ee                   	out    %al,(%dx)
+    7caf:	0f b6 c5             	movzbl %ch,%eax
+    7cb2:	b2 f4                	mov    $0xf4,%dl
+    7cb4:	ee                   	out    %al,(%dx)
+    waitdisk();
+
+    outb(0x1F2, 1);                         // count = 1
+    outb(0x1F3, secno & 0xFF);
+    outb(0x1F4, (secno >> 8) & 0xFF);
+    outb(0x1F5, (secno >> 16) & 0xFF);
+    7cb5:	89 c8                	mov    %ecx,%eax
+    7cb7:	b2 f5                	mov    $0xf5,%dl
+    7cb9:	c1 e8 10             	shr    $0x10,%eax
+    7cbc:	0f b6 c0             	movzbl %al,%eax
+    7cbf:	ee                   	out    %al,(%dx)
+    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
+    7cc0:	c1 e9 18             	shr    $0x18,%ecx
+    7cc3:	b2 f6                	mov    $0xf6,%dl
+    7cc5:	88 c8                	mov    %cl,%al
+    7cc7:	83 e0 0f             	and    $0xf,%eax
+    7cca:	83 c8 e0             	or     $0xffffffe0,%eax
+    7ccd:	ee                   	out    %al,(%dx)
+    7cce:	b0 20                	mov    $0x20,%al
+    7cd0:	b2 f7                	mov    $0xf7,%dl
+    7cd2:	ee                   	out    %al,(%dx)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+    7cd3:	ec                   	in     (%dx),%al
+#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space
+
+/* waitdisk - wait for disk ready */
+static void
+waitdisk(void) {
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+    7cd4:	83 e0 c0             	and    $0xffffffc0,%eax
+    7cd7:	3c 40                	cmp    $0x40,%al
+    7cd9:	75 f8                	jne    7cd3 <readsect+0x47>
+    return data;
+}
+
+static inline void
+insl(uint32_t port, void *addr, int cnt) {
+    asm volatile (
+    7cdb:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7ce0:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7ce5:	fc                   	cld    
+    7ce6:	f2 6d                	repnz insl (%dx),%es:(%edi)
+    // wait for disk to be ready
+    waitdisk();
+
+    // read a sector
+    insl(0x1F0, dst, SECTSIZE / 4);
+}
+    7ce8:	5f                   	pop    %edi
+    7ce9:	5d                   	pop    %ebp
+    7cea:	c3                   	ret    
+
+00007ceb <bootmain>:
+    }
+}
+
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    7ceb:	55                   	push   %ebp
+    7cec:	89 e5                	mov    %esp,%ebp
+    7cee:	57                   	push   %edi
+    7cef:	56                   	push   %esi
+    7cf0:	53                   	push   %ebx
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7cf1:	bb 01 00 00 00       	mov    $0x1,%ebx
+    }
+}
+
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    7cf6:	83 ec 1c             	sub    $0x1c,%esp
+    7cf9:	8d 43 7f             	lea    0x7f(%ebx),%eax
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+        readsect((void *)va, secno);
+    7cfc:	89 da                	mov    %ebx,%edx
+    7cfe:	c1 e0 09             	shl    $0x9,%eax
+    uint32_t secno = (offset / SECTSIZE) + 1;
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7d01:	43                   	inc    %ebx
+        readsect((void *)va, secno);
+    7d02:	e8 85 ff ff ff       	call   7c8c <readsect>
+    uint32_t secno = (offset / SECTSIZE) + 1;
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7d07:	83 fb 09             	cmp    $0x9,%ebx
+    7d0a:	75 ed                	jne    7cf9 <bootmain+0xe>
+bootmain(void) {
+    // read the 1st page off disk
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+
+    // is this a valid ELF?
+    if (ELFHDR->e_magic != ELF_MAGIC) {
+    7d0c:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d13:	45 4c 46 
+    7d16:	75 6a                	jne    7d82 <bootmain+0x97>
+    }
+
+    struct proghdr *ph, *eph;
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    7d18:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    7d1d:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+    eph = ph + ELFHDR->e_phnum;
+    7d23:	0f b7 05 2c 00 01 00 	movzwl 0x1002c,%eax
+    7d2a:	c1 e0 05             	shl    $0x5,%eax
+    7d2d:	01 d8                	add    %ebx,%eax
+    7d2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    for (; ph < eph; ph ++) {
+    7d32:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
+    7d35:	73 3f                	jae    7d76 <bootmain+0x8b>
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    7d37:	8b 73 08             	mov    0x8(%ebx),%esi
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    uintptr_t end_va = va + count;
+    7d3a:	8b 43 14             	mov    0x14(%ebx),%eax
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    eph = ph + ELFHDR->e_phnum;
+    for (; ph < eph; ph ++) {
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    7d3d:	8b 4b 04             	mov    0x4(%ebx),%ecx
+    7d40:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    uintptr_t end_va = va + count;
+    7d46:	01 f0                	add    %esi,%eax
+    7d48:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+    7d4b:	89 c8                	mov    %ecx,%eax
+    7d4d:	25 ff 01 00 00       	and    $0x1ff,%eax
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7d52:	c1 e9 09             	shr    $0x9,%ecx
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    uintptr_t end_va = va + count;
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+    7d55:	29 c6                	sub    %eax,%esi
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7d57:	8d 79 01             	lea    0x1(%ecx),%edi
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7d5a:	3b 75 e0             	cmp    -0x20(%ebp),%esi
+    7d5d:	73 12                	jae    7d71 <bootmain+0x86>
+        readsect((void *)va, secno);
+    7d5f:	89 fa                	mov    %edi,%edx
+    7d61:	89 f0                	mov    %esi,%eax
+    7d63:	e8 24 ff ff ff       	call   7c8c <readsect>
+    uint32_t secno = (offset / SECTSIZE) + 1;
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7d68:	81 c6 00 02 00 00    	add    $0x200,%esi
+    7d6e:	47                   	inc    %edi
+    7d6f:	eb e9                	jmp    7d5a <bootmain+0x6f>
+    struct proghdr *ph, *eph;
+
+    // load each program segment (ignores ph flags)
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    eph = ph + ELFHDR->e_phnum;
+    for (; ph < eph; ph ++) {
+    7d71:	83 c3 20             	add    $0x20,%ebx
+    7d74:	eb bc                	jmp    7d32 <bootmain+0x47>
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    }
+
+    // call the entry point from the ELF header
+    // note: does not return
+    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
+    7d76:	a1 18 00 01 00       	mov    0x10018,%eax
+    7d7b:	25 ff ff ff 00       	and    $0xffffff,%eax
+    7d80:	ff d0                	call   *%eax
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+}
+
+static inline void
+outw(uint16_t port, uint16_t data) {
+    asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
+    7d82:	b8 00 8a ff ff       	mov    $0xffff8a00,%eax
+    7d87:	89 c2                	mov    %eax,%edx
+    7d89:	66 ef                	out    %ax,(%dx)
+    7d8b:	b8 00 8e ff ff       	mov    $0xffff8e00,%eax
+    7d90:	66 ef                	out    %ax,(%dx)
+    7d92:	eb fe                	jmp    7d92 <bootmain+0xa7>
Binary files lab2_origin/obj/bootblock.o and lab2/obj/bootblock.o differ
Binary files lab2_origin/obj/bootblock.out and lab2/obj/bootblock.out differ
diff -r -u -P lab2_origin/obj/kern/debug/kdebug.d lab2/obj/kern/debug/kdebug.d
--- lab2_origin/obj/kern/debug/kdebug.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/debug/kdebug.d	2021-08-29 21:35:38.046604852 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/kdebug.o obj/kern/debug/kdebug.d: kern/debug/kdebug.c \
+ libs/defs.h libs/x86.h kern/debug/stab.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/debug/kdebug.h kern/trap/trap.h
Binary files lab2_origin/obj/kern/debug/kdebug.o and lab2/obj/kern/debug/kdebug.o differ
diff -r -u -P lab2_origin/obj/kern/debug/kmonitor.d lab2/obj/kern/debug/kmonitor.d
--- lab2_origin/obj/kern/debug/kmonitor.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/debug/kmonitor.d	2021-08-29 21:35:37.966604853 +0800
@@ -0,0 +1,4 @@
+obj/kern/debug/kmonitor.o obj/kern/debug/kmonitor.d: \
+ kern/debug/kmonitor.c libs/stdio.h libs/defs.h libs/stdarg.h \
+ libs/string.h kern/mm/mmu.h kern/trap/trap.h kern/debug/kmonitor.h \
+ kern/debug/kdebug.h
Binary files lab2_origin/obj/kern/debug/kmonitor.o and lab2/obj/kern/debug/kmonitor.o differ
diff -r -u -P lab2_origin/obj/kern/debug/panic.d lab2/obj/kern/debug/panic.d
--- lab2_origin/obj/kern/debug/panic.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/debug/panic.d	2021-08-29 21:35:37.942604853 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/panic.o obj/kern/debug/panic.d: kern/debug/panic.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/driver/intr.h \
+ kern/debug/kmonitor.h kern/trap/trap.h
Binary files lab2_origin/obj/kern/debug/panic.o and lab2/obj/kern/debug/panic.o differ
diff -r -u -P lab2_origin/obj/kern/driver/clock.d lab2/obj/kern/driver/clock.d
--- lab2_origin/obj/kern/driver/clock.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/driver/clock.d	2021-08-29 21:35:37.934604853 +0800
@@ -0,0 +1,3 @@
+obj/kern/driver/clock.o obj/kern/driver/clock.d: kern/driver/clock.c \
+ libs/x86.h libs/defs.h kern/trap/trap.h libs/stdio.h libs/stdarg.h \
+ kern/driver/picirq.h
Binary files lab2_origin/obj/kern/driver/clock.o and lab2/obj/kern/driver/clock.o differ
diff -r -u -P lab2_origin/obj/kern/driver/console.d lab2/obj/kern/driver/console.d
--- lab2_origin/obj/kern/driver/console.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/driver/console.d	2021-08-29 21:35:37.958604853 +0800
@@ -0,0 +1,5 @@
+obj/kern/driver/console.o obj/kern/driver/console.d: \
+ kern/driver/console.c libs/defs.h libs/x86.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/driver/kbdreg.h kern/driver/picirq.h kern/trap/trap.h \
+ kern/mm/memlayout.h libs/atomic.h libs/list.h kern/sync/sync.h \
+ kern/driver/intr.h kern/mm/mmu.h
Binary files lab2_origin/obj/kern/driver/console.o and lab2/obj/kern/driver/console.o differ
diff -r -u -P lab2_origin/obj/kern/driver/intr.d lab2/obj/kern/driver/intr.d
--- lab2_origin/obj/kern/driver/intr.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/driver/intr.d	2021-08-29 21:35:37.910604853 +0800
@@ -0,0 +1,2 @@
+obj/kern/driver/intr.o obj/kern/driver/intr.d: kern/driver/intr.c \
+ libs/x86.h libs/defs.h kern/driver/intr.h
Binary files lab2_origin/obj/kern/driver/intr.o and lab2/obj/kern/driver/intr.o differ
diff -r -u -P lab2_origin/obj/kern/driver/picirq.d lab2/obj/kern/driver/picirq.d
--- lab2_origin/obj/kern/driver/picirq.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/driver/picirq.d	2021-08-29 21:35:37.898604853 +0800
@@ -0,0 +1,2 @@
+obj/kern/driver/picirq.o obj/kern/driver/picirq.d: kern/driver/picirq.c \
+ libs/defs.h libs/x86.h kern/driver/picirq.h
Binary files lab2_origin/obj/kern/driver/picirq.o and lab2/obj/kern/driver/picirq.o differ
diff -r -u -P lab2_origin/obj/kern/init/entry.d lab2/obj/kern/init/entry.d
--- lab2_origin/obj/kern/init/entry.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/init/entry.d	2021-08-29 21:35:38.046604852 +0800
@@ -0,0 +1,2 @@
+obj/kern/init/entry.o obj/kern/init/entry.d: kern/init/entry.S \
+ kern/mm/mmu.h kern/mm/memlayout.h
Binary files lab2_origin/obj/kern/init/entry.o and lab2/obj/kern/init/entry.o differ
diff -r -u -P lab2_origin/obj/kern/init/init.d lab2/obj/kern/init/init.d
--- lab2_origin/obj/kern/init/init.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/init/init.d	2021-08-29 21:35:38.006604852 +0800
@@ -0,0 +1,6 @@
+obj/kern/init/init.o obj/kern/init/init.d: kern/init/init.c libs/defs.h \
+ libs/stdio.h libs/stdarg.h libs/string.h kern/driver/console.h \
+ kern/debug/kdebug.h kern/trap/trap.h kern/driver/picirq.h \
+ kern/driver/clock.h kern/driver/intr.h kern/mm/pmm.h kern/mm/mmu.h \
+ kern/mm/memlayout.h libs/atomic.h libs/list.h kern/debug/assert.h \
+ kern/debug/kmonitor.h
Binary files lab2_origin/obj/kern/init/init.o and lab2/obj/kern/init/init.o differ
diff -r -u -P lab2_origin/obj/kern/libs/readline.d lab2/obj/kern/libs/readline.d
--- lab2_origin/obj/kern/libs/readline.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/libs/readline.d	2021-08-29 21:35:38.002604852 +0800
@@ -0,0 +1,2 @@
+obj/kern/libs/readline.o obj/kern/libs/readline.d: kern/libs/readline.c \
+ libs/stdio.h libs/defs.h libs/stdarg.h
Binary files lab2_origin/obj/kern/libs/readline.o and lab2/obj/kern/libs/readline.o differ
diff -r -u -P lab2_origin/obj/kern/libs/stdio.d lab2/obj/kern/libs/stdio.d
--- lab2_origin/obj/kern/libs/stdio.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/libs/stdio.d	2021-08-29 21:35:37.974604852 +0800
@@ -0,0 +1,2 @@
+obj/kern/libs/stdio.o obj/kern/libs/stdio.d: kern/libs/stdio.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/driver/console.h
Binary files lab2_origin/obj/kern/libs/stdio.o and lab2/obj/kern/libs/stdio.o differ
diff -r -u -P lab2_origin/obj/kern/mm/default_pmm.d lab2/obj/kern/mm/default_pmm.d
--- lab2_origin/obj/kern/mm/default_pmm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/mm/default_pmm.d	2021-08-29 21:35:37.870604853 +0800
@@ -0,0 +1,4 @@
+obj/kern/mm/default_pmm.o obj/kern/mm/default_pmm.d: \
+ kern/mm/default_pmm.c kern/mm/pmm.h libs/defs.h kern/mm/mmu.h \
+ kern/mm/memlayout.h libs/atomic.h libs/list.h kern/debug/assert.h \
+ libs/string.h kern/mm/default_pmm.h
Binary files lab2_origin/obj/kern/mm/default_pmm.o and lab2/obj/kern/mm/default_pmm.o differ
diff -r -u -P lab2_origin/obj/kern/mm/pmm.d lab2/obj/kern/mm/pmm.d
--- lab2_origin/obj/kern/mm/pmm.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/mm/pmm.d	2021-08-29 21:35:37.930604853 +0800
@@ -0,0 +1,5 @@
+obj/kern/mm/pmm.o obj/kern/mm/pmm.d: kern/mm/pmm.c libs/defs.h libs/x86.h \
+ libs/stdio.h libs/stdarg.h libs/string.h kern/mm/mmu.h \
+ kern/mm/memlayout.h libs/atomic.h libs/list.h kern/mm/pmm.h \
+ kern/debug/assert.h kern/mm/default_pmm.h kern/sync/sync.h \
+ kern/driver/intr.h libs/error.h
Binary files lab2_origin/obj/kern/mm/pmm.o and lab2/obj/kern/mm/pmm.o differ
diff -r -u -P lab2_origin/obj/kern/trap/trap.d lab2/obj/kern/trap/trap.d
--- lab2_origin/obj/kern/trap/trap.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/trap/trap.d	2021-08-29 21:35:37.986604852 +0800
@@ -0,0 +1,5 @@
+obj/kern/trap/trap.o obj/kern/trap/trap.d: kern/trap/trap.c libs/defs.h \
+ kern/mm/mmu.h kern/mm/memlayout.h libs/atomic.h libs/list.h \
+ kern/driver/clock.h kern/trap/trap.h libs/x86.h libs/stdio.h \
+ libs/stdarg.h kern/debug/assert.h kern/driver/console.h \
+ kern/debug/kdebug.h libs/string.h
diff -r -u -P lab2_origin/obj/kern/trap/trapentry.d lab2/obj/kern/trap/trapentry.d
--- lab2_origin/obj/kern/trap/trapentry.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/trap/trapentry.d	2021-08-29 21:35:37.890604853 +0800
@@ -0,0 +1,2 @@
+obj/kern/trap/trapentry.o obj/kern/trap/trapentry.d: \
+ kern/trap/trapentry.S kern/mm/memlayout.h
Binary files lab2_origin/obj/kern/trap/trapentry.o and lab2/obj/kern/trap/trapentry.o differ
Binary files lab2_origin/obj/kern/trap/trap.o and lab2/obj/kern/trap/trap.o differ
diff -r -u -P lab2_origin/obj/kern/trap/vectors.d lab2/obj/kern/trap/vectors.d
--- lab2_origin/obj/kern/trap/vectors.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kern/trap/vectors.d	2021-08-29 21:35:37.922604853 +0800
@@ -0,0 +1 @@
+obj/kern/trap/vectors.o obj/kern/trap/vectors.d: kern/trap/vectors.S
Binary files lab2_origin/obj/kern/trap/vectors.o and lab2/obj/kern/trap/vectors.o differ
diff -r -u -P lab2_origin/obj/kernel.asm lab2/obj/kernel.asm
--- lab2_origin/obj/kernel.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kernel.asm	2021-08-29 21:35:38.858604847 +0800
@@ -0,0 +1,12692 @@
+
+bin/kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+c0100000 <kern_entry>:
+.text
+.globl kern_entry
+kern_entry:
+    # reload temperate gdt (second time) to remap all physical memory
+    # virtual_addr 0~4G=linear_addr&physical_addr -KERNBASE~4G-KERNBASE 
+    lgdt REALLOC(__gdtdesc)
+c0100000:	0f 01 15 18 70 11 00 	lgdtl  0x117018
+    movl $KERNEL_DS, %eax
+c0100007:	b8 10 00 00 00       	mov    $0x10,%eax
+    movw %ax, %ds
+c010000c:	8e d8                	mov    %eax,%ds
+    movw %ax, %es
+c010000e:	8e c0                	mov    %eax,%es
+    movw %ax, %ss
+c0100010:	8e d0                	mov    %eax,%ss
+
+    ljmp $KERNEL_CS, $relocated
+c0100012:	ea 19 00 10 c0 08 00 	ljmp   $0x8,$0xc0100019
+
+c0100019 <relocated>:
+
+relocated:
+
+    # set ebp, esp
+    movl $0x0, %ebp
+c0100019:	bd 00 00 00 00       	mov    $0x0,%ebp
+    # the kernel stack region is from bootstack -- bootstacktop,
+    # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h
+    movl $bootstacktop, %esp
+c010001e:	bc 00 70 11 c0       	mov    $0xc0117000,%esp
+    # now kernel stack is ready , call the first C function
+    call kern_init
+c0100023:	e8 02 00 00 00       	call   c010002a <kern_init>
+
+c0100028 <spin>:
+
+# should never get here
+spin:
+    jmp spin
+c0100028:	eb fe                	jmp    c0100028 <spin>
+
+c010002a <kern_init>:
+int kern_init(void) __attribute__((noreturn));
+void grade_backtrace(void);
+static void lab1_switch_test(void);
+
+int
+kern_init(void) {
+c010002a:	55                   	push   %ebp
+c010002b:	89 e5                	mov    %esp,%ebp
+c010002d:	83 ec 28             	sub    $0x28,%esp
+    extern char edata[], end[];
+    memset(edata, 0, end - edata);
+c0100030:	ba c8 89 11 c0       	mov    $0xc01189c8,%edx
+c0100035:	b8 36 7a 11 c0       	mov    $0xc0117a36,%eax
+c010003a:	29 c2                	sub    %eax,%edx
+c010003c:	89 d0                	mov    %edx,%eax
+c010003e:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100042:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0100049:	00 
+c010004a:	c7 04 24 36 7a 11 c0 	movl   $0xc0117a36,(%esp)
+c0100051:	e8 70 5e 00 00       	call   c0105ec6 <memset>
+
+    cons_init();                // init the console
+c0100056:	e8 6b 15 00 00       	call   c01015c6 <cons_init>
+
+    const char *message = "(THU.CST) os is loading ...";
+c010005b:	c7 45 f4 60 60 10 c0 	movl   $0xc0106060,-0xc(%ebp)
+    cprintf("%s\n\n", message);
+c0100062:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100065:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100069:	c7 04 24 7c 60 10 c0 	movl   $0xc010607c,(%esp)
+c0100070:	e8 c7 02 00 00       	call   c010033c <cprintf>
+
+    print_kerninfo();
+c0100075:	e8 f6 07 00 00       	call   c0100870 <print_kerninfo>
+
+    grade_backtrace();
+c010007a:	e8 86 00 00 00       	call   c0100105 <grade_backtrace>
+
+    pmm_init();                 // init physical memory management
+c010007f:	e8 5e 43 00 00       	call   c01043e2 <pmm_init>
+
+    pic_init();                 // init interrupt controller
+c0100084:	e8 a6 16 00 00       	call   c010172f <pic_init>
+    idt_init();                 // init interrupt descriptor table
+c0100089:	e8 1e 18 00 00       	call   c01018ac <idt_init>
+
+    clock_init();               // init clock interrupt
+c010008e:	e8 e9 0c 00 00       	call   c0100d7c <clock_init>
+    intr_enable();              // enable irq interrupt
+c0100093:	e8 05 16 00 00       	call   c010169d <intr_enable>
+    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
+    // user/kernel mode switch test
+    //lab1_switch_test();
+
+    /* do nothing */
+    while (1);
+c0100098:	eb fe                	jmp    c0100098 <kern_init+0x6e>
+
+c010009a <grade_backtrace2>:
+}
+
+void __attribute__((noinline))
+grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
+c010009a:	55                   	push   %ebp
+c010009b:	89 e5                	mov    %esp,%ebp
+c010009d:	83 ec 18             	sub    $0x18,%esp
+    mon_backtrace(0, NULL, NULL);
+c01000a0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c01000a7:	00 
+c01000a8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c01000af:	00 
+c01000b0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c01000b7:	e8 f2 0b 00 00       	call   c0100cae <mon_backtrace>
+}
+c01000bc:	c9                   	leave  
+c01000bd:	c3                   	ret    
+
+c01000be <grade_backtrace1>:
+
+void __attribute__((noinline))
+grade_backtrace1(int arg0, int arg1) {
+c01000be:	55                   	push   %ebp
+c01000bf:	89 e5                	mov    %esp,%ebp
+c01000c1:	53                   	push   %ebx
+c01000c2:	83 ec 14             	sub    $0x14,%esp
+    grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
+c01000c5:	8d 5d 0c             	lea    0xc(%ebp),%ebx
+c01000c8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+c01000cb:	8d 55 08             	lea    0x8(%ebp),%edx
+c01000ce:	8b 45 08             	mov    0x8(%ebp),%eax
+c01000d1:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+c01000d5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c01000d9:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01000dd:	89 04 24             	mov    %eax,(%esp)
+c01000e0:	e8 b5 ff ff ff       	call   c010009a <grade_backtrace2>
+}
+c01000e5:	83 c4 14             	add    $0x14,%esp
+c01000e8:	5b                   	pop    %ebx
+c01000e9:	5d                   	pop    %ebp
+c01000ea:	c3                   	ret    
+
+c01000eb <grade_backtrace0>:
+
+void __attribute__((noinline))
+grade_backtrace0(int arg0, int arg1, int arg2) {
+c01000eb:	55                   	push   %ebp
+c01000ec:	89 e5                	mov    %esp,%ebp
+c01000ee:	83 ec 18             	sub    $0x18,%esp
+    grade_backtrace1(arg0, arg2);
+c01000f1:	8b 45 10             	mov    0x10(%ebp),%eax
+c01000f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+c01000fb:	89 04 24             	mov    %eax,(%esp)
+c01000fe:	e8 bb ff ff ff       	call   c01000be <grade_backtrace1>
+}
+c0100103:	c9                   	leave  
+c0100104:	c3                   	ret    
+
+c0100105 <grade_backtrace>:
+
+void
+grade_backtrace(void) {
+c0100105:	55                   	push   %ebp
+c0100106:	89 e5                	mov    %esp,%ebp
+c0100108:	83 ec 18             	sub    $0x18,%esp
+    grade_backtrace0(0, (int)kern_init, 0xffff0000);
+c010010b:	b8 2a 00 10 c0       	mov    $0xc010002a,%eax
+c0100110:	c7 44 24 08 00 00 ff 	movl   $0xffff0000,0x8(%esp)
+c0100117:	ff 
+c0100118:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010011c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c0100123:	e8 c3 ff ff ff       	call   c01000eb <grade_backtrace0>
+}
+c0100128:	c9                   	leave  
+c0100129:	c3                   	ret    
+
+c010012a <lab1_print_cur_status>:
+
+static void
+lab1_print_cur_status(void) {
+c010012a:	55                   	push   %ebp
+c010012b:	89 e5                	mov    %esp,%ebp
+c010012d:	83 ec 28             	sub    $0x28,%esp
+    static int round = 0;
+    uint16_t reg1, reg2, reg3, reg4;
+    asm volatile (
+c0100130:	8c 4d f6             	mov    %cs,-0xa(%ebp)
+c0100133:	8c 5d f4             	mov    %ds,-0xc(%ebp)
+c0100136:	8c 45 f2             	mov    %es,-0xe(%ebp)
+c0100139:	8c 55 f0             	mov    %ss,-0x10(%ebp)
+            "mov %%cs, %0;"
+            "mov %%ds, %1;"
+            "mov %%es, %2;"
+            "mov %%ss, %3;"
+            : "=m"(reg1), "=m"(reg2), "=m"(reg3), "=m"(reg4));
+    cprintf("%d: @ring %d\n", round, reg1 & 3);
+c010013c:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100140:	0f b7 c0             	movzwl %ax,%eax
+c0100143:	83 e0 03             	and    $0x3,%eax
+c0100146:	89 c2                	mov    %eax,%edx
+c0100148:	a1 40 7a 11 c0       	mov    0xc0117a40,%eax
+c010014d:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0100151:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100155:	c7 04 24 81 60 10 c0 	movl   $0xc0106081,(%esp)
+c010015c:	e8 db 01 00 00       	call   c010033c <cprintf>
+    cprintf("%d:  cs = %x\n", round, reg1);
+c0100161:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100165:	0f b7 d0             	movzwl %ax,%edx
+c0100168:	a1 40 7a 11 c0       	mov    0xc0117a40,%eax
+c010016d:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0100171:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100175:	c7 04 24 8f 60 10 c0 	movl   $0xc010608f,(%esp)
+c010017c:	e8 bb 01 00 00       	call   c010033c <cprintf>
+    cprintf("%d:  ds = %x\n", round, reg2);
+c0100181:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
+c0100185:	0f b7 d0             	movzwl %ax,%edx
+c0100188:	a1 40 7a 11 c0       	mov    0xc0117a40,%eax
+c010018d:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0100191:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100195:	c7 04 24 9d 60 10 c0 	movl   $0xc010609d,(%esp)
+c010019c:	e8 9b 01 00 00       	call   c010033c <cprintf>
+    cprintf("%d:  es = %x\n", round, reg3);
+c01001a1:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01001a5:	0f b7 d0             	movzwl %ax,%edx
+c01001a8:	a1 40 7a 11 c0       	mov    0xc0117a40,%eax
+c01001ad:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01001b1:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01001b5:	c7 04 24 ab 60 10 c0 	movl   $0xc01060ab,(%esp)
+c01001bc:	e8 7b 01 00 00       	call   c010033c <cprintf>
+    cprintf("%d:  ss = %x\n", round, reg4);
+c01001c1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+c01001c5:	0f b7 d0             	movzwl %ax,%edx
+c01001c8:	a1 40 7a 11 c0       	mov    0xc0117a40,%eax
+c01001cd:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01001d1:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01001d5:	c7 04 24 b9 60 10 c0 	movl   $0xc01060b9,(%esp)
+c01001dc:	e8 5b 01 00 00       	call   c010033c <cprintf>
+    round ++;
+c01001e1:	a1 40 7a 11 c0       	mov    0xc0117a40,%eax
+c01001e6:	83 c0 01             	add    $0x1,%eax
+c01001e9:	a3 40 7a 11 c0       	mov    %eax,0xc0117a40
+}
+c01001ee:	c9                   	leave  
+c01001ef:	c3                   	ret    
+
+c01001f0 <lab1_switch_to_user>:
+
+static void
+lab1_switch_to_user(void) {
+c01001f0:	55                   	push   %ebp
+c01001f1:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 : TODO
+}
+c01001f3:	5d                   	pop    %ebp
+c01001f4:	c3                   	ret    
+
+c01001f5 <lab1_switch_to_kernel>:
+
+static void
+lab1_switch_to_kernel(void) {
+c01001f5:	55                   	push   %ebp
+c01001f6:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 :  TODO
+}
+c01001f8:	5d                   	pop    %ebp
+c01001f9:	c3                   	ret    
+
+c01001fa <lab1_switch_test>:
+
+static void
+lab1_switch_test(void) {
+c01001fa:	55                   	push   %ebp
+c01001fb:	89 e5                	mov    %esp,%ebp
+c01001fd:	83 ec 18             	sub    $0x18,%esp
+    lab1_print_cur_status();
+c0100200:	e8 25 ff ff ff       	call   c010012a <lab1_print_cur_status>
+    cprintf("+++ switch to  user  mode +++\n");
+c0100205:	c7 04 24 c8 60 10 c0 	movl   $0xc01060c8,(%esp)
+c010020c:	e8 2b 01 00 00       	call   c010033c <cprintf>
+    lab1_switch_to_user();
+c0100211:	e8 da ff ff ff       	call   c01001f0 <lab1_switch_to_user>
+    lab1_print_cur_status();
+c0100216:	e8 0f ff ff ff       	call   c010012a <lab1_print_cur_status>
+    cprintf("+++ switch to kernel mode +++\n");
+c010021b:	c7 04 24 e8 60 10 c0 	movl   $0xc01060e8,(%esp)
+c0100222:	e8 15 01 00 00       	call   c010033c <cprintf>
+    lab1_switch_to_kernel();
+c0100227:	e8 c9 ff ff ff       	call   c01001f5 <lab1_switch_to_kernel>
+    lab1_print_cur_status();
+c010022c:	e8 f9 fe ff ff       	call   c010012a <lab1_print_cur_status>
+}
+c0100231:	c9                   	leave  
+c0100232:	c3                   	ret    
+
+c0100233 <readline>:
+ * The readline() function returns the text of the line read. If some errors
+ * are happened, NULL is returned. The return value is a global variable,
+ * thus it should be copied before it is used.
+ * */
+char *
+readline(const char *prompt) {
+c0100233:	55                   	push   %ebp
+c0100234:	89 e5                	mov    %esp,%ebp
+c0100236:	83 ec 28             	sub    $0x28,%esp
+    if (prompt != NULL) {
+c0100239:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010023d:	74 13                	je     c0100252 <readline+0x1f>
+        cprintf("%s", prompt);
+c010023f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100242:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100246:	c7 04 24 07 61 10 c0 	movl   $0xc0106107,(%esp)
+c010024d:	e8 ea 00 00 00       	call   c010033c <cprintf>
+    }
+    int i = 0, c;
+c0100252:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        c = getchar();
+c0100259:	e8 66 01 00 00       	call   c01003c4 <getchar>
+c010025e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (c < 0) {
+c0100261:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0100265:	79 07                	jns    c010026e <readline+0x3b>
+            return NULL;
+c0100267:	b8 00 00 00 00       	mov    $0x0,%eax
+c010026c:	eb 79                	jmp    c01002e7 <readline+0xb4>
+        }
+        else if (c >= ' ' && i < BUFSIZE - 1) {
+c010026e:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
+c0100272:	7e 28                	jle    c010029c <readline+0x69>
+c0100274:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
+c010027b:	7f 1f                	jg     c010029c <readline+0x69>
+            cputchar(c);
+c010027d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100280:	89 04 24             	mov    %eax,(%esp)
+c0100283:	e8 da 00 00 00       	call   c0100362 <cputchar>
+            buf[i ++] = c;
+c0100288:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010028b:	8d 50 01             	lea    0x1(%eax),%edx
+c010028e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0100291:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100294:	88 90 60 7a 11 c0    	mov    %dl,-0x3fee85a0(%eax)
+c010029a:	eb 46                	jmp    c01002e2 <readline+0xaf>
+        }
+        else if (c == '\b' && i > 0) {
+c010029c:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
+c01002a0:	75 17                	jne    c01002b9 <readline+0x86>
+c01002a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01002a6:	7e 11                	jle    c01002b9 <readline+0x86>
+            cputchar(c);
+c01002a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01002ab:	89 04 24             	mov    %eax,(%esp)
+c01002ae:	e8 af 00 00 00       	call   c0100362 <cputchar>
+            i --;
+c01002b3:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c01002b7:	eb 29                	jmp    c01002e2 <readline+0xaf>
+        }
+        else if (c == '\n' || c == '\r') {
+c01002b9:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+c01002bd:	74 06                	je     c01002c5 <readline+0x92>
+c01002bf:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+c01002c3:	75 1d                	jne    c01002e2 <readline+0xaf>
+            cputchar(c);
+c01002c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01002c8:	89 04 24             	mov    %eax,(%esp)
+c01002cb:	e8 92 00 00 00       	call   c0100362 <cputchar>
+            buf[i] = '\0';
+c01002d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01002d3:	05 60 7a 11 c0       	add    $0xc0117a60,%eax
+c01002d8:	c6 00 00             	movb   $0x0,(%eax)
+            return buf;
+c01002db:	b8 60 7a 11 c0       	mov    $0xc0117a60,%eax
+c01002e0:	eb 05                	jmp    c01002e7 <readline+0xb4>
+        }
+    }
+c01002e2:	e9 72 ff ff ff       	jmp    c0100259 <readline+0x26>
+}
+c01002e7:	c9                   	leave  
+c01002e8:	c3                   	ret    
+
+c01002e9 <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+c01002e9:	55                   	push   %ebp
+c01002ea:	89 e5                	mov    %esp,%ebp
+c01002ec:	83 ec 18             	sub    $0x18,%esp
+    cons_putc(c);
+c01002ef:	8b 45 08             	mov    0x8(%ebp),%eax
+c01002f2:	89 04 24             	mov    %eax,(%esp)
+c01002f5:	e8 f8 12 00 00       	call   c01015f2 <cons_putc>
+    (*cnt) ++;
+c01002fa:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01002fd:	8b 00                	mov    (%eax),%eax
+c01002ff:	8d 50 01             	lea    0x1(%eax),%edx
+c0100302:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100305:	89 10                	mov    %edx,(%eax)
+}
+c0100307:	c9                   	leave  
+c0100308:	c3                   	ret    
+
+c0100309 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+c0100309:	55                   	push   %ebp
+c010030a:	89 e5                	mov    %esp,%ebp
+c010030c:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+c010030f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+c0100316:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100319:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c010031d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100320:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100324:	8d 45 f4             	lea    -0xc(%ebp),%eax
+c0100327:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010032b:	c7 04 24 e9 02 10 c0 	movl   $0xc01002e9,(%esp)
+c0100332:	e8 a8 53 00 00       	call   c01056df <vprintfmt>
+    return cnt;
+c0100337:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010033a:	c9                   	leave  
+c010033b:	c3                   	ret    
+
+c010033c <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+c010033c:	55                   	push   %ebp
+c010033d:	89 e5                	mov    %esp,%ebp
+c010033f:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+c0100342:	8d 45 0c             	lea    0xc(%ebp),%eax
+c0100345:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vcprintf(fmt, ap);
+c0100348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010034b:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010034f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100352:	89 04 24             	mov    %eax,(%esp)
+c0100355:	e8 af ff ff ff       	call   c0100309 <vcprintf>
+c010035a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+c010035d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0100360:	c9                   	leave  
+c0100361:	c3                   	ret    
+
+c0100362 <cputchar>:
+
+/* cputchar - writes a single character to stdout */
+void
+cputchar(int c) {
+c0100362:	55                   	push   %ebp
+c0100363:	89 e5                	mov    %esp,%ebp
+c0100365:	83 ec 18             	sub    $0x18,%esp
+    cons_putc(c);
+c0100368:	8b 45 08             	mov    0x8(%ebp),%eax
+c010036b:	89 04 24             	mov    %eax,(%esp)
+c010036e:	e8 7f 12 00 00       	call   c01015f2 <cons_putc>
+}
+c0100373:	c9                   	leave  
+c0100374:	c3                   	ret    
+
+c0100375 <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+c0100375:	55                   	push   %ebp
+c0100376:	89 e5                	mov    %esp,%ebp
+c0100378:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+c010037b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+c0100382:	eb 13                	jmp    c0100397 <cputs+0x22>
+        cputch(c, &cnt);
+c0100384:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+c0100388:	8d 55 f0             	lea    -0x10(%ebp),%edx
+c010038b:	89 54 24 04          	mov    %edx,0x4(%esp)
+c010038f:	89 04 24             	mov    %eax,(%esp)
+c0100392:	e8 52 ff ff ff       	call   c01002e9 <cputch>
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+c0100397:	8b 45 08             	mov    0x8(%ebp),%eax
+c010039a:	8d 50 01             	lea    0x1(%eax),%edx
+c010039d:	89 55 08             	mov    %edx,0x8(%ebp)
+c01003a0:	0f b6 00             	movzbl (%eax),%eax
+c01003a3:	88 45 f7             	mov    %al,-0x9(%ebp)
+c01003a6:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+c01003aa:	75 d8                	jne    c0100384 <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+c01003ac:	8d 45 f0             	lea    -0x10(%ebp),%eax
+c01003af:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01003b3:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+c01003ba:	e8 2a ff ff ff       	call   c01002e9 <cputch>
+    return cnt;
+c01003bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+c01003c2:	c9                   	leave  
+c01003c3:	c3                   	ret    
+
+c01003c4 <getchar>:
+
+/* getchar - reads a single non-zero character from stdin */
+int
+getchar(void) {
+c01003c4:	55                   	push   %ebp
+c01003c5:	89 e5                	mov    %esp,%ebp
+c01003c7:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = cons_getc()) == 0)
+c01003ca:	e8 5f 12 00 00       	call   c010162e <cons_getc>
+c01003cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01003d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01003d6:	74 f2                	je     c01003ca <getchar+0x6>
+        /* do nothing */;
+    return c;
+c01003d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c01003db:	c9                   	leave  
+c01003dc:	c3                   	ret    
+
+c01003dd <stab_binsearch>:
+ *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+ * will exit setting left = 118, right = 554.
+ * */
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+c01003dd:	55                   	push   %ebp
+c01003de:	89 e5                	mov    %esp,%ebp
+c01003e0:	83 ec 20             	sub    $0x20,%esp
+    int l = *region_left, r = *region_right, any_matches = 0;
+c01003e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01003e6:	8b 00                	mov    (%eax),%eax
+c01003e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c01003eb:	8b 45 10             	mov    0x10(%ebp),%eax
+c01003ee:	8b 00                	mov    (%eax),%eax
+c01003f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c01003f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+    while (l <= r) {
+c01003fa:	e9 d2 00 00 00       	jmp    c01004d1 <stab_binsearch+0xf4>
+        int true_m = (l + r) / 2, m = true_m;
+c01003ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0100402:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0100405:	01 d0                	add    %edx,%eax
+c0100407:	89 c2                	mov    %eax,%edx
+c0100409:	c1 ea 1f             	shr    $0x1f,%edx
+c010040c:	01 d0                	add    %edx,%eax
+c010040e:	d1 f8                	sar    %eax
+c0100410:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0100413:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100416:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+c0100419:	eb 04                	jmp    c010041f <stab_binsearch+0x42>
+            m --;
+c010041b:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
+
+    while (l <= r) {
+        int true_m = (l + r) / 2, m = true_m;
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+c010041f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100422:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c0100425:	7c 1f                	jl     c0100446 <stab_binsearch+0x69>
+c0100427:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010042a:	89 d0                	mov    %edx,%eax
+c010042c:	01 c0                	add    %eax,%eax
+c010042e:	01 d0                	add    %edx,%eax
+c0100430:	c1 e0 02             	shl    $0x2,%eax
+c0100433:	89 c2                	mov    %eax,%edx
+c0100435:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100438:	01 d0                	add    %edx,%eax
+c010043a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c010043e:	0f b6 c0             	movzbl %al,%eax
+c0100441:	3b 45 14             	cmp    0x14(%ebp),%eax
+c0100444:	75 d5                	jne    c010041b <stab_binsearch+0x3e>
+            m --;
+        }
+        if (m < l) {    // no match in [l, m]
+c0100446:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100449:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c010044c:	7d 0b                	jge    c0100459 <stab_binsearch+0x7c>
+            l = true_m + 1;
+c010044e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100451:	83 c0 01             	add    $0x1,%eax
+c0100454:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            continue;
+c0100457:	eb 78                	jmp    c01004d1 <stab_binsearch+0xf4>
+        }
+
+        // actual binary search
+        any_matches = 1;
+c0100459:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+        if (stabs[m].n_value < addr) {
+c0100460:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100463:	89 d0                	mov    %edx,%eax
+c0100465:	01 c0                	add    %eax,%eax
+c0100467:	01 d0                	add    %edx,%eax
+c0100469:	c1 e0 02             	shl    $0x2,%eax
+c010046c:	89 c2                	mov    %eax,%edx
+c010046e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100471:	01 d0                	add    %edx,%eax
+c0100473:	8b 40 08             	mov    0x8(%eax),%eax
+c0100476:	3b 45 18             	cmp    0x18(%ebp),%eax
+c0100479:	73 13                	jae    c010048e <stab_binsearch+0xb1>
+            *region_left = m;
+c010047b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010047e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100481:	89 10                	mov    %edx,(%eax)
+            l = true_m + 1;
+c0100483:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100486:	83 c0 01             	add    $0x1,%eax
+c0100489:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c010048c:	eb 43                	jmp    c01004d1 <stab_binsearch+0xf4>
+        } else if (stabs[m].n_value > addr) {
+c010048e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100491:	89 d0                	mov    %edx,%eax
+c0100493:	01 c0                	add    %eax,%eax
+c0100495:	01 d0                	add    %edx,%eax
+c0100497:	c1 e0 02             	shl    $0x2,%eax
+c010049a:	89 c2                	mov    %eax,%edx
+c010049c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010049f:	01 d0                	add    %edx,%eax
+c01004a1:	8b 40 08             	mov    0x8(%eax),%eax
+c01004a4:	3b 45 18             	cmp    0x18(%ebp),%eax
+c01004a7:	76 16                	jbe    c01004bf <stab_binsearch+0xe2>
+            *region_right = m - 1;
+c01004a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01004ac:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01004af:	8b 45 10             	mov    0x10(%ebp),%eax
+c01004b2:	89 10                	mov    %edx,(%eax)
+            r = m - 1;
+c01004b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01004b7:	83 e8 01             	sub    $0x1,%eax
+c01004ba:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c01004bd:	eb 12                	jmp    c01004d1 <stab_binsearch+0xf4>
+        } else {
+            // exact match for 'addr', but continue loop to find
+            // *region_right
+            *region_left = m;
+c01004bf:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01004c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01004c5:	89 10                	mov    %edx,(%eax)
+            l = m;
+c01004c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01004ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            addr ++;
+c01004cd:	83 45 18 01          	addl   $0x1,0x18(%ebp)
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+c01004d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01004d4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+c01004d7:	0f 8e 22 ff ff ff    	jle    c01003ff <stab_binsearch+0x22>
+            l = m;
+            addr ++;
+        }
+    }
+
+    if (!any_matches) {
+c01004dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01004e1:	75 0f                	jne    c01004f2 <stab_binsearch+0x115>
+        *region_right = *region_left - 1;
+c01004e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01004e6:	8b 00                	mov    (%eax),%eax
+c01004e8:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01004eb:	8b 45 10             	mov    0x10(%ebp),%eax
+c01004ee:	89 10                	mov    %edx,(%eax)
+c01004f0:	eb 3f                	jmp    c0100531 <stab_binsearch+0x154>
+    }
+    else {
+        // find rightmost region containing 'addr'
+        l = *region_right;
+c01004f2:	8b 45 10             	mov    0x10(%ebp),%eax
+c01004f5:	8b 00                	mov    (%eax),%eax
+c01004f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+c01004fa:	eb 04                	jmp    c0100500 <stab_binsearch+0x123>
+c01004fc:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
+c0100500:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100503:	8b 00                	mov    (%eax),%eax
+c0100505:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c0100508:	7d 1f                	jge    c0100529 <stab_binsearch+0x14c>
+c010050a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c010050d:	89 d0                	mov    %edx,%eax
+c010050f:	01 c0                	add    %eax,%eax
+c0100511:	01 d0                	add    %edx,%eax
+c0100513:	c1 e0 02             	shl    $0x2,%eax
+c0100516:	89 c2                	mov    %eax,%edx
+c0100518:	8b 45 08             	mov    0x8(%ebp),%eax
+c010051b:	01 d0                	add    %edx,%eax
+c010051d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c0100521:	0f b6 c0             	movzbl %al,%eax
+c0100524:	3b 45 14             	cmp    0x14(%ebp),%eax
+c0100527:	75 d3                	jne    c01004fc <stab_binsearch+0x11f>
+            /* do nothing */;
+        *region_left = l;
+c0100529:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010052c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c010052f:	89 10                	mov    %edx,(%eax)
+    }
+}
+c0100531:	c9                   	leave  
+c0100532:	c3                   	ret    
+
+c0100533 <debuginfo_eip>:
+ * the specified instruction address, @addr.  Returns 0 if information
+ * was found, and negative if not.  But even if it returns negative it
+ * has stored some information into '*info'.
+ * */
+int
+debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
+c0100533:	55                   	push   %ebp
+c0100534:	89 e5                	mov    %esp,%ebp
+c0100536:	83 ec 58             	sub    $0x58,%esp
+    const struct stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+
+    info->eip_file = "<unknown>";
+c0100539:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010053c:	c7 00 0c 61 10 c0    	movl   $0xc010610c,(%eax)
+    info->eip_line = 0;
+c0100542:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100545:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    info->eip_fn_name = "<unknown>";
+c010054c:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010054f:	c7 40 08 0c 61 10 c0 	movl   $0xc010610c,0x8(%eax)
+    info->eip_fn_namelen = 9;
+c0100556:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100559:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
+    info->eip_fn_addr = addr;
+c0100560:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100563:	8b 55 08             	mov    0x8(%ebp),%edx
+c0100566:	89 50 10             	mov    %edx,0x10(%eax)
+    info->eip_fn_narg = 0;
+c0100569:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010056c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+
+    stabs = __STAB_BEGIN__;
+c0100573:	c7 45 f4 68 73 10 c0 	movl   $0xc0107368,-0xc(%ebp)
+    stab_end = __STAB_END__;
+c010057a:	c7 45 f0 00 20 11 c0 	movl   $0xc0112000,-0x10(%ebp)
+    stabstr = __STABSTR_BEGIN__;
+c0100581:	c7 45 ec 01 20 11 c0 	movl   $0xc0112001,-0x14(%ebp)
+    stabstr_end = __STABSTR_END__;
+c0100588:	c7 45 e8 5a 4a 11 c0 	movl   $0xc0114a5a,-0x18(%ebp)
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
+c010058f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100592:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0100595:	76 0d                	jbe    c01005a4 <debuginfo_eip+0x71>
+c0100597:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010059a:	83 e8 01             	sub    $0x1,%eax
+c010059d:	0f b6 00             	movzbl (%eax),%eax
+c01005a0:	84 c0                	test   %al,%al
+c01005a2:	74 0a                	je     c01005ae <debuginfo_eip+0x7b>
+        return -1;
+c01005a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c01005a9:	e9 c0 02 00 00       	jmp    c010086e <debuginfo_eip+0x33b>
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    int lfile = 0, rfile = (stab_end - stabs) - 1;
+c01005ae:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+c01005b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01005b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01005bb:	29 c2                	sub    %eax,%edx
+c01005bd:	89 d0                	mov    %edx,%eax
+c01005bf:	c1 f8 02             	sar    $0x2,%eax
+c01005c2:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
+c01005c8:	83 e8 01             	sub    $0x1,%eax
+c01005cb:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+c01005ce:	8b 45 08             	mov    0x8(%ebp),%eax
+c01005d1:	89 44 24 10          	mov    %eax,0x10(%esp)
+c01005d5:	c7 44 24 0c 64 00 00 	movl   $0x64,0xc(%esp)
+c01005dc:	00 
+c01005dd:	8d 45 e0             	lea    -0x20(%ebp),%eax
+c01005e0:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01005e4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+c01005e7:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01005eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01005ee:	89 04 24             	mov    %eax,(%esp)
+c01005f1:	e8 e7 fd ff ff       	call   c01003dd <stab_binsearch>
+    if (lfile == 0)
+c01005f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01005f9:	85 c0                	test   %eax,%eax
+c01005fb:	75 0a                	jne    c0100607 <debuginfo_eip+0xd4>
+        return -1;
+c01005fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0100602:	e9 67 02 00 00       	jmp    c010086e <debuginfo_eip+0x33b>
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    int lfun = lfile, rfun = rfile;
+c0100607:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010060a:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c010060d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0100610:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    int lline, rline;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+c0100613:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100616:	89 44 24 10          	mov    %eax,0x10(%esp)
+c010061a:	c7 44 24 0c 24 00 00 	movl   $0x24,0xc(%esp)
+c0100621:	00 
+c0100622:	8d 45 d8             	lea    -0x28(%ebp),%eax
+c0100625:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100629:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c010062c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100630:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100633:	89 04 24             	mov    %eax,(%esp)
+c0100636:	e8 a2 fd ff ff       	call   c01003dd <stab_binsearch>
+
+    if (lfun <= rfun) {
+c010063b:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c010063e:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0100641:	39 c2                	cmp    %eax,%edx
+c0100643:	7f 7c                	jg     c01006c1 <debuginfo_eip+0x18e>
+        // stabs[lfun] points to the function name
+        // in the string table, but check bounds just in case.
+        if (stabs[lfun].n_strx < stabstr_end - stabstr) {
+c0100645:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100648:	89 c2                	mov    %eax,%edx
+c010064a:	89 d0                	mov    %edx,%eax
+c010064c:	01 c0                	add    %eax,%eax
+c010064e:	01 d0                	add    %edx,%eax
+c0100650:	c1 e0 02             	shl    $0x2,%eax
+c0100653:	89 c2                	mov    %eax,%edx
+c0100655:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100658:	01 d0                	add    %edx,%eax
+c010065a:	8b 10                	mov    (%eax),%edx
+c010065c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+c010065f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100662:	29 c1                	sub    %eax,%ecx
+c0100664:	89 c8                	mov    %ecx,%eax
+c0100666:	39 c2                	cmp    %eax,%edx
+c0100668:	73 22                	jae    c010068c <debuginfo_eip+0x159>
+            info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+c010066a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010066d:	89 c2                	mov    %eax,%edx
+c010066f:	89 d0                	mov    %edx,%eax
+c0100671:	01 c0                	add    %eax,%eax
+c0100673:	01 d0                	add    %edx,%eax
+c0100675:	c1 e0 02             	shl    $0x2,%eax
+c0100678:	89 c2                	mov    %eax,%edx
+c010067a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010067d:	01 d0                	add    %edx,%eax
+c010067f:	8b 10                	mov    (%eax),%edx
+c0100681:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100684:	01 c2                	add    %eax,%edx
+c0100686:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100689:	89 50 08             	mov    %edx,0x8(%eax)
+        }
+        info->eip_fn_addr = stabs[lfun].n_value;
+c010068c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010068f:	89 c2                	mov    %eax,%edx
+c0100691:	89 d0                	mov    %edx,%eax
+c0100693:	01 c0                	add    %eax,%eax
+c0100695:	01 d0                	add    %edx,%eax
+c0100697:	c1 e0 02             	shl    $0x2,%eax
+c010069a:	89 c2                	mov    %eax,%edx
+c010069c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010069f:	01 d0                	add    %edx,%eax
+c01006a1:	8b 50 08             	mov    0x8(%eax),%edx
+c01006a4:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01006a7:	89 50 10             	mov    %edx,0x10(%eax)
+        addr -= info->eip_fn_addr;
+c01006aa:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01006ad:	8b 40 10             	mov    0x10(%eax),%eax
+c01006b0:	29 45 08             	sub    %eax,0x8(%ebp)
+        // Search within the function definition for the line number.
+        lline = lfun;
+c01006b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01006b6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        rline = rfun;
+c01006b9:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01006bc:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c01006bf:	eb 15                	jmp    c01006d6 <debuginfo_eip+0x1a3>
+    } else {
+        // Couldn't find function stab!  Maybe we're in an assembly
+        // file.  Search the whole file for the line number.
+        info->eip_fn_addr = addr;
+c01006c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01006c4:	8b 55 08             	mov    0x8(%ebp),%edx
+c01006c7:	89 50 10             	mov    %edx,0x10(%eax)
+        lline = lfile;
+c01006ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01006cd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        rline = rfile;
+c01006d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01006d3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    }
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+c01006d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01006d9:	8b 40 08             	mov    0x8(%eax),%eax
+c01006dc:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
+c01006e3:	00 
+c01006e4:	89 04 24             	mov    %eax,(%esp)
+c01006e7:	e8 4e 56 00 00       	call   c0105d3a <strfind>
+c01006ec:	89 c2                	mov    %eax,%edx
+c01006ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01006f1:	8b 40 08             	mov    0x8(%eax),%eax
+c01006f4:	29 c2                	sub    %eax,%edx
+c01006f6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01006f9:	89 50 0c             	mov    %edx,0xc(%eax)
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+c01006fc:	8b 45 08             	mov    0x8(%ebp),%eax
+c01006ff:	89 44 24 10          	mov    %eax,0x10(%esp)
+c0100703:	c7 44 24 0c 44 00 00 	movl   $0x44,0xc(%esp)
+c010070a:	00 
+c010070b:	8d 45 d0             	lea    -0x30(%ebp),%eax
+c010070e:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100712:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+c0100715:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100719:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010071c:	89 04 24             	mov    %eax,(%esp)
+c010071f:	e8 b9 fc ff ff       	call   c01003dd <stab_binsearch>
+    if (lline <= rline) {
+c0100724:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0100727:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010072a:	39 c2                	cmp    %eax,%edx
+c010072c:	7f 24                	jg     c0100752 <debuginfo_eip+0x21f>
+        info->eip_line = stabs[rline].n_desc;
+c010072e:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0100731:	89 c2                	mov    %eax,%edx
+c0100733:	89 d0                	mov    %edx,%eax
+c0100735:	01 c0                	add    %eax,%eax
+c0100737:	01 d0                	add    %edx,%eax
+c0100739:	c1 e0 02             	shl    $0x2,%eax
+c010073c:	89 c2                	mov    %eax,%edx
+c010073e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100741:	01 d0                	add    %edx,%eax
+c0100743:	0f b7 40 06          	movzwl 0x6(%eax),%eax
+c0100747:	0f b7 d0             	movzwl %ax,%edx
+c010074a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010074d:	89 50 04             	mov    %edx,0x4(%eax)
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+c0100750:	eb 13                	jmp    c0100765 <debuginfo_eip+0x232>
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) {
+        info->eip_line = stabs[rline].n_desc;
+    } else {
+        return -1;
+c0100752:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0100757:	e9 12 01 00 00       	jmp    c010086e <debuginfo_eip+0x33b>
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+           && stabs[lline].n_type != N_SOL
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+        lline --;
+c010075c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010075f:	83 e8 01             	sub    $0x1,%eax
+c0100762:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+c0100765:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0100768:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010076b:	39 c2                	cmp    %eax,%edx
+c010076d:	7c 56                	jl     c01007c5 <debuginfo_eip+0x292>
+           && stabs[lline].n_type != N_SOL
+c010076f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0100772:	89 c2                	mov    %eax,%edx
+c0100774:	89 d0                	mov    %edx,%eax
+c0100776:	01 c0                	add    %eax,%eax
+c0100778:	01 d0                	add    %edx,%eax
+c010077a:	c1 e0 02             	shl    $0x2,%eax
+c010077d:	89 c2                	mov    %eax,%edx
+c010077f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100782:	01 d0                	add    %edx,%eax
+c0100784:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c0100788:	3c 84                	cmp    $0x84,%al
+c010078a:	74 39                	je     c01007c5 <debuginfo_eip+0x292>
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+c010078c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010078f:	89 c2                	mov    %eax,%edx
+c0100791:	89 d0                	mov    %edx,%eax
+c0100793:	01 c0                	add    %eax,%eax
+c0100795:	01 d0                	add    %edx,%eax
+c0100797:	c1 e0 02             	shl    $0x2,%eax
+c010079a:	89 c2                	mov    %eax,%edx
+c010079c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010079f:	01 d0                	add    %edx,%eax
+c01007a1:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c01007a5:	3c 64                	cmp    $0x64,%al
+c01007a7:	75 b3                	jne    c010075c <debuginfo_eip+0x229>
+c01007a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01007ac:	89 c2                	mov    %eax,%edx
+c01007ae:	89 d0                	mov    %edx,%eax
+c01007b0:	01 c0                	add    %eax,%eax
+c01007b2:	01 d0                	add    %edx,%eax
+c01007b4:	c1 e0 02             	shl    $0x2,%eax
+c01007b7:	89 c2                	mov    %eax,%edx
+c01007b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01007bc:	01 d0                	add    %edx,%eax
+c01007be:	8b 40 08             	mov    0x8(%eax),%eax
+c01007c1:	85 c0                	test   %eax,%eax
+c01007c3:	74 97                	je     c010075c <debuginfo_eip+0x229>
+        lline --;
+    }
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
+c01007c5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01007c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01007cb:	39 c2                	cmp    %eax,%edx
+c01007cd:	7c 46                	jl     c0100815 <debuginfo_eip+0x2e2>
+c01007cf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01007d2:	89 c2                	mov    %eax,%edx
+c01007d4:	89 d0                	mov    %edx,%eax
+c01007d6:	01 c0                	add    %eax,%eax
+c01007d8:	01 d0                	add    %edx,%eax
+c01007da:	c1 e0 02             	shl    $0x2,%eax
+c01007dd:	89 c2                	mov    %eax,%edx
+c01007df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01007e2:	01 d0                	add    %edx,%eax
+c01007e4:	8b 10                	mov    (%eax),%edx
+c01007e6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+c01007e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01007ec:	29 c1                	sub    %eax,%ecx
+c01007ee:	89 c8                	mov    %ecx,%eax
+c01007f0:	39 c2                	cmp    %eax,%edx
+c01007f2:	73 21                	jae    c0100815 <debuginfo_eip+0x2e2>
+        info->eip_file = stabstr + stabs[lline].n_strx;
+c01007f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01007f7:	89 c2                	mov    %eax,%edx
+c01007f9:	89 d0                	mov    %edx,%eax
+c01007fb:	01 c0                	add    %eax,%eax
+c01007fd:	01 d0                	add    %edx,%eax
+c01007ff:	c1 e0 02             	shl    $0x2,%eax
+c0100802:	89 c2                	mov    %eax,%edx
+c0100804:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100807:	01 d0                	add    %edx,%eax
+c0100809:	8b 10                	mov    (%eax),%edx
+c010080b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010080e:	01 c2                	add    %eax,%edx
+c0100810:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100813:	89 10                	mov    %edx,(%eax)
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+c0100815:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0100818:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010081b:	39 c2                	cmp    %eax,%edx
+c010081d:	7d 4a                	jge    c0100869 <debuginfo_eip+0x336>
+        for (lline = lfun + 1;
+c010081f:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100822:	83 c0 01             	add    $0x1,%eax
+c0100825:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0100828:	eb 18                	jmp    c0100842 <debuginfo_eip+0x30f>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+            info->eip_fn_narg ++;
+c010082a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010082d:	8b 40 14             	mov    0x14(%eax),%eax
+c0100830:	8d 50 01             	lea    0x1(%eax),%edx
+c0100833:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100836:	89 50 14             	mov    %edx,0x14(%eax)
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+c0100839:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010083c:	83 c0 01             	add    $0x1,%eax
+c010083f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+c0100842:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0100845:	8b 45 d8             	mov    -0x28(%ebp),%eax
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+c0100848:	39 c2                	cmp    %eax,%edx
+c010084a:	7d 1d                	jge    c0100869 <debuginfo_eip+0x336>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+c010084c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010084f:	89 c2                	mov    %eax,%edx
+c0100851:	89 d0                	mov    %edx,%eax
+c0100853:	01 c0                	add    %eax,%eax
+c0100855:	01 d0                	add    %edx,%eax
+c0100857:	c1 e0 02             	shl    $0x2,%eax
+c010085a:	89 c2                	mov    %eax,%edx
+c010085c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010085f:	01 d0                	add    %edx,%eax
+c0100861:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c0100865:	3c a0                	cmp    $0xa0,%al
+c0100867:	74 c1                	je     c010082a <debuginfo_eip+0x2f7>
+             lline ++) {
+            info->eip_fn_narg ++;
+        }
+    }
+    return 0;
+c0100869:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010086e:	c9                   	leave  
+c010086f:	c3                   	ret    
+
+c0100870 <print_kerninfo>:
+ * print_kerninfo - print the information about kernel, including the location
+ * of kernel entry, the start addresses of data and text segements, the start
+ * address of free memory and how many memory that kernel has used.
+ * */
+void
+print_kerninfo(void) {
+c0100870:	55                   	push   %ebp
+c0100871:	89 e5                	mov    %esp,%ebp
+c0100873:	83 ec 18             	sub    $0x18,%esp
+    extern char etext[], edata[], end[], kern_init[];
+    cprintf("Special kernel symbols:\n");
+c0100876:	c7 04 24 16 61 10 c0 	movl   $0xc0106116,(%esp)
+c010087d:	e8 ba fa ff ff       	call   c010033c <cprintf>
+    cprintf("  entry  0x%08x (phys)\n", kern_init);
+c0100882:	c7 44 24 04 2a 00 10 	movl   $0xc010002a,0x4(%esp)
+c0100889:	c0 
+c010088a:	c7 04 24 2f 61 10 c0 	movl   $0xc010612f,(%esp)
+c0100891:	e8 a6 fa ff ff       	call   c010033c <cprintf>
+    cprintf("  etext  0x%08x (phys)\n", etext);
+c0100896:	c7 44 24 04 4f 60 10 	movl   $0xc010604f,0x4(%esp)
+c010089d:	c0 
+c010089e:	c7 04 24 47 61 10 c0 	movl   $0xc0106147,(%esp)
+c01008a5:	e8 92 fa ff ff       	call   c010033c <cprintf>
+    cprintf("  edata  0x%08x (phys)\n", edata);
+c01008aa:	c7 44 24 04 36 7a 11 	movl   $0xc0117a36,0x4(%esp)
+c01008b1:	c0 
+c01008b2:	c7 04 24 5f 61 10 c0 	movl   $0xc010615f,(%esp)
+c01008b9:	e8 7e fa ff ff       	call   c010033c <cprintf>
+    cprintf("  end    0x%08x (phys)\n", end);
+c01008be:	c7 44 24 04 c8 89 11 	movl   $0xc01189c8,0x4(%esp)
+c01008c5:	c0 
+c01008c6:	c7 04 24 77 61 10 c0 	movl   $0xc0106177,(%esp)
+c01008cd:	e8 6a fa ff ff       	call   c010033c <cprintf>
+    cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
+c01008d2:	b8 c8 89 11 c0       	mov    $0xc01189c8,%eax
+c01008d7:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+c01008dd:	b8 2a 00 10 c0       	mov    $0xc010002a,%eax
+c01008e2:	29 c2                	sub    %eax,%edx
+c01008e4:	89 d0                	mov    %edx,%eax
+c01008e6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+c01008ec:	85 c0                	test   %eax,%eax
+c01008ee:	0f 48 c2             	cmovs  %edx,%eax
+c01008f1:	c1 f8 0a             	sar    $0xa,%eax
+c01008f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01008f8:	c7 04 24 90 61 10 c0 	movl   $0xc0106190,(%esp)
+c01008ff:	e8 38 fa ff ff       	call   c010033c <cprintf>
+}
+c0100904:	c9                   	leave  
+c0100905:	c3                   	ret    
+
+c0100906 <print_debuginfo>:
+/* *
+ * print_debuginfo - read and print the stat information for the address @eip,
+ * and info.eip_fn_addr should be the first address of the related function.
+ * */
+void
+print_debuginfo(uintptr_t eip) {
+c0100906:	55                   	push   %ebp
+c0100907:	89 e5                	mov    %esp,%ebp
+c0100909:	81 ec 48 01 00 00    	sub    $0x148,%esp
+    struct eipdebuginfo info;
+    if (debuginfo_eip(eip, &info) != 0) {
+c010090f:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c0100912:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100916:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100919:	89 04 24             	mov    %eax,(%esp)
+c010091c:	e8 12 fc ff ff       	call   c0100533 <debuginfo_eip>
+c0100921:	85 c0                	test   %eax,%eax
+c0100923:	74 15                	je     c010093a <print_debuginfo+0x34>
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+c0100925:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100928:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010092c:	c7 04 24 ba 61 10 c0 	movl   $0xc01061ba,(%esp)
+c0100933:	e8 04 fa ff ff       	call   c010033c <cprintf>
+c0100938:	eb 6d                	jmp    c01009a7 <print_debuginfo+0xa1>
+    }
+    else{ 
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+c010093a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100941:	eb 1c                	jmp    c010095f <print_debuginfo+0x59>
+            fnname[j] = info.eip_fn_name[j];
+c0100943:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0100946:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100949:	01 d0                	add    %edx,%eax
+c010094b:	0f b6 00             	movzbl (%eax),%eax
+c010094e:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+c0100954:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100957:	01 ca                	add    %ecx,%edx
+c0100959:	88 02                	mov    %al,(%edx)
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+    }
+    else{ 
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+c010095b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c010095f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100962:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0100965:	7f dc                	jg     c0100943 <print_debuginfo+0x3d>
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+c0100967:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
+c010096d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100970:	01 d0                	add    %edx,%eax
+c0100972:	c6 00 00             	movb   $0x0,(%eax)
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+c0100975:	8b 45 ec             	mov    -0x14(%ebp),%eax
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+c0100978:	8b 55 08             	mov    0x8(%ebp),%edx
+c010097b:	89 d1                	mov    %edx,%ecx
+c010097d:	29 c1                	sub    %eax,%ecx
+c010097f:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0100982:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100985:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+c0100989:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+c010098f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+c0100993:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0100997:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010099b:	c7 04 24 d6 61 10 c0 	movl   $0xc01061d6,(%esp)
+c01009a2:	e8 95 f9 ff ff       	call   c010033c <cprintf>
+                fnname, eip - info.eip_fn_addr);
+    }
+}
+c01009a7:	c9                   	leave  
+c01009a8:	c3                   	ret    
+
+c01009a9 <read_eip>:
+
+static __noinline uint32_t
+read_eip(void) {
+c01009a9:	55                   	push   %ebp
+c01009aa:	89 e5                	mov    %esp,%ebp
+c01009ac:	83 ec 10             	sub    $0x10,%esp
+    uint32_t eip;
+    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
+c01009af:	8b 45 04             	mov    0x4(%ebp),%eax
+c01009b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return eip;
+c01009b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c01009b8:	c9                   	leave  
+c01009b9:	c3                   	ret    
+
+c01009ba <print_stackframe>:
+ *
+ * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
+ * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
+ * */
+void
+print_stackframe(void) {
+c01009ba:	55                   	push   %ebp
+c01009bb:	89 e5                	mov    %esp,%ebp
+c01009bd:	83 ec 38             	sub    $0x38,%esp
+}
+
+static inline uint32_t
+read_ebp(void) {
+    uint32_t ebp;
+    asm volatile ("movl %%ebp, %0" : "=r" (ebp));
+c01009c0:	89 e8                	mov    %ebp,%eax
+c01009c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    return ebp;
+c01009c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
+      *    (3.5) popup a calling stackframe
+      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+	uint32_t ebp = read_ebp();
+c01009c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	uint32_t eip = read_eip();
+c01009cb:	e8 d9 ff ff ff       	call   c01009a9 <read_eip>
+c01009d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	int i,j;
+	for(i=0;i<STACKFRAME_DEPTH;i++){
+c01009d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c01009da:	e9 88 00 00 00       	jmp    c0100a67 <print_stackframe+0xad>
+		cprintf("ebp:0x%08x eip:0x%08x args:",ebp,eip);
+c01009df:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01009e2:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01009e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01009e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01009ed:	c7 04 24 e8 61 10 c0 	movl   $0xc01061e8,(%esp)
+c01009f4:	e8 43 f9 ff ff       	call   c010033c <cprintf>
+		uint32_t *args = (uint32_t *)ebp +2;
+c01009f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01009fc:	83 c0 08             	add    $0x8,%eax
+c01009ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		for(j=0;j<4;j++){
+c0100a02:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+c0100a09:	eb 25                	jmp    c0100a30 <print_stackframe+0x76>
+			cprintf("0x%08x ",args[j]);
+c0100a0b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100a0e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0100a15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0100a18:	01 d0                	add    %edx,%eax
+c0100a1a:	8b 00                	mov    (%eax),%eax
+c0100a1c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100a20:	c7 04 24 04 62 10 c0 	movl   $0xc0106204,(%esp)
+c0100a27:	e8 10 f9 ff ff       	call   c010033c <cprintf>
+	uint32_t eip = read_eip();
+	int i,j;
+	for(i=0;i<STACKFRAME_DEPTH;i++){
+		cprintf("ebp:0x%08x eip:0x%08x args:",ebp,eip);
+		uint32_t *args = (uint32_t *)ebp +2;
+		for(j=0;j<4;j++){
+c0100a2c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+c0100a30:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
+c0100a34:	7e d5                	jle    c0100a0b <print_stackframe+0x51>
+			cprintf("0x%08x ",args[j]);
+		}
+		cprintf("\n");
+c0100a36:	c7 04 24 0c 62 10 c0 	movl   $0xc010620c,(%esp)
+c0100a3d:	e8 fa f8 ff ff       	call   c010033c <cprintf>
+		print_debuginfo(eip-1);
+c0100a42:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100a45:	83 e8 01             	sub    $0x1,%eax
+c0100a48:	89 04 24             	mov    %eax,(%esp)
+c0100a4b:	e8 b6 fe ff ff       	call   c0100906 <print_debuginfo>
+		eip = ((uint32_t *)ebp)[1];
+c0100a50:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100a53:	83 c0 04             	add    $0x4,%eax
+c0100a56:	8b 00                	mov    (%eax),%eax
+c0100a58:	89 45 f0             	mov    %eax,-0x10(%ebp)
+		ebp = ((uint32_t *)ebp)[0];
+c0100a5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100a5e:	8b 00                	mov    (%eax),%eax
+c0100a60:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+	uint32_t ebp = read_ebp();
+	uint32_t eip = read_eip();
+	int i,j;
+	for(i=0;i<STACKFRAME_DEPTH;i++){
+c0100a63:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+c0100a67:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
+c0100a6b:	0f 8e 6e ff ff ff    	jle    c01009df <print_stackframe+0x25>
+		cprintf("\n");
+		print_debuginfo(eip-1);
+		eip = ((uint32_t *)ebp)[1];
+		ebp = ((uint32_t *)ebp)[0];
+	}
+}
+c0100a71:	c9                   	leave  
+c0100a72:	c3                   	ret    
+
+c0100a73 <parse>:
+#define MAXARGS         16
+#define WHITESPACE      " \t\n\r"
+
+/* parse - parse the command buffer into whitespace-separated arguments */
+static int
+parse(char *buf, char **argv) {
+c0100a73:	55                   	push   %ebp
+c0100a74:	89 e5                	mov    %esp,%ebp
+c0100a76:	83 ec 28             	sub    $0x28,%esp
+    int argc = 0;
+c0100a79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+c0100a80:	eb 0c                	jmp    c0100a8e <parse+0x1b>
+            *buf ++ = '\0';
+c0100a82:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100a85:	8d 50 01             	lea    0x1(%eax),%edx
+c0100a88:	89 55 08             	mov    %edx,0x8(%ebp)
+c0100a8b:	c6 00 00             	movb   $0x0,(%eax)
+static int
+parse(char *buf, char **argv) {
+    int argc = 0;
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+c0100a8e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100a91:	0f b6 00             	movzbl (%eax),%eax
+c0100a94:	84 c0                	test   %al,%al
+c0100a96:	74 1d                	je     c0100ab5 <parse+0x42>
+c0100a98:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100a9b:	0f b6 00             	movzbl (%eax),%eax
+c0100a9e:	0f be c0             	movsbl %al,%eax
+c0100aa1:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100aa5:	c7 04 24 90 62 10 c0 	movl   $0xc0106290,(%esp)
+c0100aac:	e8 56 52 00 00       	call   c0105d07 <strchr>
+c0100ab1:	85 c0                	test   %eax,%eax
+c0100ab3:	75 cd                	jne    c0100a82 <parse+0xf>
+            *buf ++ = '\0';
+        }
+        if (*buf == '\0') {
+c0100ab5:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100ab8:	0f b6 00             	movzbl (%eax),%eax
+c0100abb:	84 c0                	test   %al,%al
+c0100abd:	75 02                	jne    c0100ac1 <parse+0x4e>
+            break;
+c0100abf:	eb 67                	jmp    c0100b28 <parse+0xb5>
+        }
+
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+c0100ac1:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+c0100ac5:	75 14                	jne    c0100adb <parse+0x68>
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+c0100ac7:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
+c0100ace:	00 
+c0100acf:	c7 04 24 95 62 10 c0 	movl   $0xc0106295,(%esp)
+c0100ad6:	e8 61 f8 ff ff       	call   c010033c <cprintf>
+        }
+        argv[argc ++] = buf;
+c0100adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100ade:	8d 50 01             	lea    0x1(%eax),%edx
+c0100ae1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0100ae4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0100aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100aee:	01 c2                	add    %eax,%edx
+c0100af0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100af3:	89 02                	mov    %eax,(%edx)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+c0100af5:	eb 04                	jmp    c0100afb <parse+0x88>
+            buf ++;
+c0100af7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+        }
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+c0100afb:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100afe:	0f b6 00             	movzbl (%eax),%eax
+c0100b01:	84 c0                	test   %al,%al
+c0100b03:	74 1d                	je     c0100b22 <parse+0xaf>
+c0100b05:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100b08:	0f b6 00             	movzbl (%eax),%eax
+c0100b0b:	0f be c0             	movsbl %al,%eax
+c0100b0e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100b12:	c7 04 24 90 62 10 c0 	movl   $0xc0106290,(%esp)
+c0100b19:	e8 e9 51 00 00       	call   c0105d07 <strchr>
+c0100b1e:	85 c0                	test   %eax,%eax
+c0100b20:	74 d5                	je     c0100af7 <parse+0x84>
+            buf ++;
+        }
+    }
+c0100b22:	90                   	nop
+static int
+parse(char *buf, char **argv) {
+    int argc = 0;
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+c0100b23:	e9 66 ff ff ff       	jmp    c0100a8e <parse+0x1b>
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+            buf ++;
+        }
+    }
+    return argc;
+c0100b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0100b2b:	c9                   	leave  
+c0100b2c:	c3                   	ret    
+
+c0100b2d <runcmd>:
+/* *
+ * runcmd - parse the input string, split it into separated arguments
+ * and then lookup and invoke some related commands/
+ * */
+static int
+runcmd(char *buf, struct trapframe *tf) {
+c0100b2d:	55                   	push   %ebp
+c0100b2e:	89 e5                	mov    %esp,%ebp
+c0100b30:	83 ec 68             	sub    $0x68,%esp
+    char *argv[MAXARGS];
+    int argc = parse(buf, argv);
+c0100b33:	8d 45 b0             	lea    -0x50(%ebp),%eax
+c0100b36:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100b3a:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100b3d:	89 04 24             	mov    %eax,(%esp)
+c0100b40:	e8 2e ff ff ff       	call   c0100a73 <parse>
+c0100b45:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if (argc == 0) {
+c0100b48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0100b4c:	75 0a                	jne    c0100b58 <runcmd+0x2b>
+        return 0;
+c0100b4e:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100b53:	e9 85 00 00 00       	jmp    c0100bdd <runcmd+0xb0>
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+c0100b58:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100b5f:	eb 5c                	jmp    c0100bbd <runcmd+0x90>
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+c0100b61:	8b 4d b0             	mov    -0x50(%ebp),%ecx
+c0100b64:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100b67:	89 d0                	mov    %edx,%eax
+c0100b69:	01 c0                	add    %eax,%eax
+c0100b6b:	01 d0                	add    %edx,%eax
+c0100b6d:	c1 e0 02             	shl    $0x2,%eax
+c0100b70:	05 20 70 11 c0       	add    $0xc0117020,%eax
+c0100b75:	8b 00                	mov    (%eax),%eax
+c0100b77:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+c0100b7b:	89 04 24             	mov    %eax,(%esp)
+c0100b7e:	e8 e5 50 00 00       	call   c0105c68 <strcmp>
+c0100b83:	85 c0                	test   %eax,%eax
+c0100b85:	75 32                	jne    c0100bb9 <runcmd+0x8c>
+            return commands[i].func(argc - 1, argv + 1, tf);
+c0100b87:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100b8a:	89 d0                	mov    %edx,%eax
+c0100b8c:	01 c0                	add    %eax,%eax
+c0100b8e:	01 d0                	add    %edx,%eax
+c0100b90:	c1 e0 02             	shl    $0x2,%eax
+c0100b93:	05 20 70 11 c0       	add    $0xc0117020,%eax
+c0100b98:	8b 40 08             	mov    0x8(%eax),%eax
+c0100b9b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100b9e:	8d 4a ff             	lea    -0x1(%edx),%ecx
+c0100ba1:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0100ba4:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0100ba8:	8d 55 b0             	lea    -0x50(%ebp),%edx
+c0100bab:	83 c2 04             	add    $0x4,%edx
+c0100bae:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0100bb2:	89 0c 24             	mov    %ecx,(%esp)
+c0100bb5:	ff d0                	call   *%eax
+c0100bb7:	eb 24                	jmp    c0100bdd <runcmd+0xb0>
+    int argc = parse(buf, argv);
+    if (argc == 0) {
+        return 0;
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+c0100bb9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0100bbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100bc0:	83 f8 02             	cmp    $0x2,%eax
+c0100bc3:	76 9c                	jbe    c0100b61 <runcmd+0x34>
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+            return commands[i].func(argc - 1, argv + 1, tf);
+        }
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+c0100bc5:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0100bc8:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100bcc:	c7 04 24 b3 62 10 c0 	movl   $0xc01062b3,(%esp)
+c0100bd3:	e8 64 f7 ff ff       	call   c010033c <cprintf>
+    return 0;
+c0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100bdd:	c9                   	leave  
+c0100bde:	c3                   	ret    
+
+c0100bdf <kmonitor>:
+
+/***** Implementations of basic kernel monitor commands *****/
+
+void
+kmonitor(struct trapframe *tf) {
+c0100bdf:	55                   	push   %ebp
+c0100be0:	89 e5                	mov    %esp,%ebp
+c0100be2:	83 ec 28             	sub    $0x28,%esp
+    cprintf("Welcome to the kernel debug monitor!!\n");
+c0100be5:	c7 04 24 cc 62 10 c0 	movl   $0xc01062cc,(%esp)
+c0100bec:	e8 4b f7 ff ff       	call   c010033c <cprintf>
+    cprintf("Type 'help' for a list of commands.\n");
+c0100bf1:	c7 04 24 f4 62 10 c0 	movl   $0xc01062f4,(%esp)
+c0100bf8:	e8 3f f7 ff ff       	call   c010033c <cprintf>
+
+    if (tf != NULL) {
+c0100bfd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0100c01:	74 0b                	je     c0100c0e <kmonitor+0x2f>
+        print_trapframe(tf);
+c0100c03:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c06:	89 04 24             	mov    %eax,(%esp)
+c0100c09:	e8 56 0e 00 00       	call   c0101a64 <print_trapframe>
+    }
+
+    char *buf;
+    while (1) {
+        if ((buf = readline("K> ")) != NULL) {
+c0100c0e:	c7 04 24 19 63 10 c0 	movl   $0xc0106319,(%esp)
+c0100c15:	e8 19 f6 ff ff       	call   c0100233 <readline>
+c0100c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0100c1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0100c21:	74 18                	je     c0100c3b <kmonitor+0x5c>
+            if (runcmd(buf, tf) < 0) {
+c0100c23:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c26:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100c2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100c2d:	89 04 24             	mov    %eax,(%esp)
+c0100c30:	e8 f8 fe ff ff       	call   c0100b2d <runcmd>
+c0100c35:	85 c0                	test   %eax,%eax
+c0100c37:	79 02                	jns    c0100c3b <kmonitor+0x5c>
+                break;
+c0100c39:	eb 02                	jmp    c0100c3d <kmonitor+0x5e>
+            }
+        }
+    }
+c0100c3b:	eb d1                	jmp    c0100c0e <kmonitor+0x2f>
+}
+c0100c3d:	c9                   	leave  
+c0100c3e:	c3                   	ret    
+
+c0100c3f <mon_help>:
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+c0100c3f:	55                   	push   %ebp
+c0100c40:	89 e5                	mov    %esp,%ebp
+c0100c42:	83 ec 28             	sub    $0x28,%esp
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+c0100c45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100c4c:	eb 3f                	jmp    c0100c8d <mon_help+0x4e>
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+c0100c4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100c51:	89 d0                	mov    %edx,%eax
+c0100c53:	01 c0                	add    %eax,%eax
+c0100c55:	01 d0                	add    %edx,%eax
+c0100c57:	c1 e0 02             	shl    $0x2,%eax
+c0100c5a:	05 20 70 11 c0       	add    $0xc0117020,%eax
+c0100c5f:	8b 48 04             	mov    0x4(%eax),%ecx
+c0100c62:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100c65:	89 d0                	mov    %edx,%eax
+c0100c67:	01 c0                	add    %eax,%eax
+c0100c69:	01 d0                	add    %edx,%eax
+c0100c6b:	c1 e0 02             	shl    $0x2,%eax
+c0100c6e:	05 20 70 11 c0       	add    $0xc0117020,%eax
+c0100c73:	8b 00                	mov    (%eax),%eax
+c0100c75:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c0100c79:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100c7d:	c7 04 24 1d 63 10 c0 	movl   $0xc010631d,(%esp)
+c0100c84:	e8 b3 f6 ff ff       	call   c010033c <cprintf>
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+c0100c89:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0100c8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100c90:	83 f8 02             	cmp    $0x2,%eax
+c0100c93:	76 b9                	jbe    c0100c4e <mon_help+0xf>
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+    }
+    return 0;
+c0100c95:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100c9a:	c9                   	leave  
+c0100c9b:	c3                   	ret    
+
+c0100c9c <mon_kerninfo>:
+/* *
+ * mon_kerninfo - call print_kerninfo in kern/debug/kdebug.c to
+ * print the memory occupancy in kernel.
+ * */
+int
+mon_kerninfo(int argc, char **argv, struct trapframe *tf) {
+c0100c9c:	55                   	push   %ebp
+c0100c9d:	89 e5                	mov    %esp,%ebp
+c0100c9f:	83 ec 08             	sub    $0x8,%esp
+    print_kerninfo();
+c0100ca2:	e8 c9 fb ff ff       	call   c0100870 <print_kerninfo>
+    return 0;
+c0100ca7:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100cac:	c9                   	leave  
+c0100cad:	c3                   	ret    
+
+c0100cae <mon_backtrace>:
+/* *
+ * mon_backtrace - call print_stackframe in kern/debug/kdebug.c to
+ * print a backtrace of the stack.
+ * */
+int
+mon_backtrace(int argc, char **argv, struct trapframe *tf) {
+c0100cae:	55                   	push   %ebp
+c0100caf:	89 e5                	mov    %esp,%ebp
+c0100cb1:	83 ec 08             	sub    $0x8,%esp
+    print_stackframe();
+c0100cb4:	e8 01 fd ff ff       	call   c01009ba <print_stackframe>
+    return 0;
+c0100cb9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100cbe:	c9                   	leave  
+c0100cbf:	c3                   	ret    
+
+c0100cc0 <__panic>:
+/* *
+ * __panic - __panic is called on unresolvable fatal errors. it prints
+ * "panic: 'message'", and then enters the kernel monitor.
+ * */
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+c0100cc0:	55                   	push   %ebp
+c0100cc1:	89 e5                	mov    %esp,%ebp
+c0100cc3:	83 ec 28             	sub    $0x28,%esp
+    if (is_panic) {
+c0100cc6:	a1 60 7e 11 c0       	mov    0xc0117e60,%eax
+c0100ccb:	85 c0                	test   %eax,%eax
+c0100ccd:	74 02                	je     c0100cd1 <__panic+0x11>
+        goto panic_dead;
+c0100ccf:	eb 48                	jmp    c0100d19 <__panic+0x59>
+    }
+    is_panic = 1;
+c0100cd1:	c7 05 60 7e 11 c0 01 	movl   $0x1,0xc0117e60
+c0100cd8:	00 00 00 
+
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+c0100cdb:	8d 45 14             	lea    0x14(%ebp),%eax
+c0100cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel panic at %s:%d:\n    ", file, line);
+c0100ce1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100ce4:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100ce8:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100ceb:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100cef:	c7 04 24 26 63 10 c0 	movl   $0xc0106326,(%esp)
+c0100cf6:	e8 41 f6 ff ff       	call   c010033c <cprintf>
+    vcprintf(fmt, ap);
+c0100cfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100cfe:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100d02:	8b 45 10             	mov    0x10(%ebp),%eax
+c0100d05:	89 04 24             	mov    %eax,(%esp)
+c0100d08:	e8 fc f5 ff ff       	call   c0100309 <vcprintf>
+    cprintf("\n");
+c0100d0d:	c7 04 24 42 63 10 c0 	movl   $0xc0106342,(%esp)
+c0100d14:	e8 23 f6 ff ff       	call   c010033c <cprintf>
+    va_end(ap);
+
+panic_dead:
+    intr_disable();
+c0100d19:	e8 85 09 00 00       	call   c01016a3 <intr_disable>
+    while (1) {
+        kmonitor(NULL);
+c0100d1e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c0100d25:	e8 b5 fe ff ff       	call   c0100bdf <kmonitor>
+    }
+c0100d2a:	eb f2                	jmp    c0100d1e <__panic+0x5e>
+
+c0100d2c <__warn>:
+}
+
+/* __warn - like panic, but don't */
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+c0100d2c:	55                   	push   %ebp
+c0100d2d:	89 e5                	mov    %esp,%ebp
+c0100d2f:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    va_start(ap, fmt);
+c0100d32:	8d 45 14             	lea    0x14(%ebp),%eax
+c0100d35:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel warning at %s:%d:\n    ", file, line);
+c0100d38:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100d3b:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100d3f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100d42:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100d46:	c7 04 24 44 63 10 c0 	movl   $0xc0106344,(%esp)
+c0100d4d:	e8 ea f5 ff ff       	call   c010033c <cprintf>
+    vcprintf(fmt, ap);
+c0100d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100d55:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100d59:	8b 45 10             	mov    0x10(%ebp),%eax
+c0100d5c:	89 04 24             	mov    %eax,(%esp)
+c0100d5f:	e8 a5 f5 ff ff       	call   c0100309 <vcprintf>
+    cprintf("\n");
+c0100d64:	c7 04 24 42 63 10 c0 	movl   $0xc0106342,(%esp)
+c0100d6b:	e8 cc f5 ff ff       	call   c010033c <cprintf>
+    va_end(ap);
+}
+c0100d70:	c9                   	leave  
+c0100d71:	c3                   	ret    
+
+c0100d72 <is_kernel_panic>:
+
+bool
+is_kernel_panic(void) {
+c0100d72:	55                   	push   %ebp
+c0100d73:	89 e5                	mov    %esp,%ebp
+    return is_panic;
+c0100d75:	a1 60 7e 11 c0       	mov    0xc0117e60,%eax
+}
+c0100d7a:	5d                   	pop    %ebp
+c0100d7b:	c3                   	ret    
+
+c0100d7c <clock_init>:
+/* *
+ * clock_init - initialize 8253 clock to interrupt 100 times per second,
+ * and then enable IRQ_TIMER.
+ * */
+void
+clock_init(void) {
+c0100d7c:	55                   	push   %ebp
+c0100d7d:	89 e5                	mov    %esp,%ebp
+c0100d7f:	83 ec 28             	sub    $0x28,%esp
+c0100d82:	66 c7 45 f6 43 00    	movw   $0x43,-0xa(%ebp)
+c0100d88:	c6 45 f5 34          	movb   $0x34,-0xb(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0100d8c:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+c0100d90:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c0100d94:	ee                   	out    %al,(%dx)
+c0100d95:	66 c7 45 f2 40 00    	movw   $0x40,-0xe(%ebp)
+c0100d9b:	c6 45 f1 9c          	movb   $0x9c,-0xf(%ebp)
+c0100d9f:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c0100da3:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0100da7:	ee                   	out    %al,(%dx)
+c0100da8:	66 c7 45 ee 40 00    	movw   $0x40,-0x12(%ebp)
+c0100dae:	c6 45 ed 2e          	movb   $0x2e,-0x13(%ebp)
+c0100db2:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+c0100db6:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0100dba:	ee                   	out    %al,(%dx)
+    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+    outb(IO_TIMER1, TIMER_DIV(100) % 256);
+    outb(IO_TIMER1, TIMER_DIV(100) / 256);
+
+    // initialize time counter 'ticks' to zero
+    ticks = 0;
+c0100dbb:	c7 05 4c 89 11 c0 00 	movl   $0x0,0xc011894c
+c0100dc2:	00 00 00 
+
+    cprintf("++ setup timer interrupts\n");
+c0100dc5:	c7 04 24 62 63 10 c0 	movl   $0xc0106362,(%esp)
+c0100dcc:	e8 6b f5 ff ff       	call   c010033c <cprintf>
+    pic_enable(IRQ_TIMER);
+c0100dd1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c0100dd8:	e8 24 09 00 00       	call   c0101701 <pic_enable>
+}
+c0100ddd:	c9                   	leave  
+c0100dde:	c3                   	ret    
+
+c0100ddf <__intr_save>:
+#include <x86.h>
+#include <intr.h>
+#include <mmu.h>
+
+static inline bool
+__intr_save(void) {
+c0100ddf:	55                   	push   %ebp
+c0100de0:	89 e5                	mov    %esp,%ebp
+c0100de2:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+c0100de5:	9c                   	pushf  
+c0100de6:	58                   	pop    %eax
+c0100de7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+c0100dea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+c0100ded:	25 00 02 00 00       	and    $0x200,%eax
+c0100df2:	85 c0                	test   %eax,%eax
+c0100df4:	74 0c                	je     c0100e02 <__intr_save+0x23>
+        intr_disable();
+c0100df6:	e8 a8 08 00 00       	call   c01016a3 <intr_disable>
+        return 1;
+c0100dfb:	b8 01 00 00 00       	mov    $0x1,%eax
+c0100e00:	eb 05                	jmp    c0100e07 <__intr_save+0x28>
+    }
+    return 0;
+c0100e02:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0100e07:	c9                   	leave  
+c0100e08:	c3                   	ret    
+
+c0100e09 <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+c0100e09:	55                   	push   %ebp
+c0100e0a:	89 e5                	mov    %esp,%ebp
+c0100e0c:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+c0100e0f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0100e13:	74 05                	je     c0100e1a <__intr_restore+0x11>
+        intr_enable();
+c0100e15:	e8 83 08 00 00       	call   c010169d <intr_enable>
+    }
+}
+c0100e1a:	c9                   	leave  
+c0100e1b:	c3                   	ret    
+
+c0100e1c <delay>:
+#include <memlayout.h>
+#include <sync.h>
+
+/* stupid I/O delay routine necessitated by historical PC design flaws */
+static void
+delay(void) {
+c0100e1c:	55                   	push   %ebp
+c0100e1d:	89 e5                	mov    %esp,%ebp
+c0100e1f:	83 ec 10             	sub    $0x10,%esp
+c0100e22:	66 c7 45 fe 84 00    	movw   $0x84,-0x2(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0100e28:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+c0100e2c:	89 c2                	mov    %eax,%edx
+c0100e2e:	ec                   	in     (%dx),%al
+c0100e2f:	88 45 fd             	mov    %al,-0x3(%ebp)
+c0100e32:	66 c7 45 fa 84 00    	movw   $0x84,-0x6(%ebp)
+c0100e38:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c0100e3c:	89 c2                	mov    %eax,%edx
+c0100e3e:	ec                   	in     (%dx),%al
+c0100e3f:	88 45 f9             	mov    %al,-0x7(%ebp)
+c0100e42:	66 c7 45 f6 84 00    	movw   $0x84,-0xa(%ebp)
+c0100e48:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100e4c:	89 c2                	mov    %eax,%edx
+c0100e4e:	ec                   	in     (%dx),%al
+c0100e4f:	88 45 f5             	mov    %al,-0xb(%ebp)
+c0100e52:	66 c7 45 f2 84 00    	movw   $0x84,-0xe(%ebp)
+c0100e58:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c0100e5c:	89 c2                	mov    %eax,%edx
+c0100e5e:	ec                   	in     (%dx),%al
+c0100e5f:	88 45 f1             	mov    %al,-0xf(%ebp)
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+}
+c0100e62:	c9                   	leave  
+c0100e63:	c3                   	ret    
+
+c0100e64 <cga_init>:
+static uint16_t addr_6845;
+
+/* TEXT-mode CGA/VGA display output */
+
+static void
+cga_init(void) {
+c0100e64:	55                   	push   %ebp
+c0100e65:	89 e5                	mov    %esp,%ebp
+c0100e67:	83 ec 20             	sub    $0x20,%esp
+    volatile uint16_t *cp = (uint16_t *)(CGA_BUF + KERNBASE);
+c0100e6a:	c7 45 fc 00 80 0b c0 	movl   $0xc00b8000,-0x4(%ebp)
+    uint16_t was = *cp;
+c0100e71:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100e74:	0f b7 00             	movzwl (%eax),%eax
+c0100e77:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+    *cp = (uint16_t) 0xA55A;
+c0100e7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100e7e:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
+    if (*cp != 0xA55A) {
+c0100e83:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100e86:	0f b7 00             	movzwl (%eax),%eax
+c0100e89:	66 3d 5a a5          	cmp    $0xa55a,%ax
+c0100e8d:	74 12                	je     c0100ea1 <cga_init+0x3d>
+        cp = (uint16_t*)(MONO_BUF + KERNBASE);
+c0100e8f:	c7 45 fc 00 00 0b c0 	movl   $0xc00b0000,-0x4(%ebp)
+        addr_6845 = MONO_BASE;
+c0100e96:	66 c7 05 86 7e 11 c0 	movw   $0x3b4,0xc0117e86
+c0100e9d:	b4 03 
+c0100e9f:	eb 13                	jmp    c0100eb4 <cga_init+0x50>
+    } else {
+        *cp = was;
+c0100ea1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100ea4:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c0100ea8:	66 89 10             	mov    %dx,(%eax)
+        addr_6845 = CGA_BASE;
+c0100eab:	66 c7 05 86 7e 11 c0 	movw   $0x3d4,0xc0117e86
+c0100eb2:	d4 03 
+    }
+
+    // Extract cursor location
+    uint32_t pos;
+    outb(addr_6845, 14);
+c0100eb4:	0f b7 05 86 7e 11 c0 	movzwl 0xc0117e86,%eax
+c0100ebb:	0f b7 c0             	movzwl %ax,%eax
+c0100ebe:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c0100ec2:	c6 45 f1 0e          	movb   $0xe,-0xf(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0100ec6:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c0100eca:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0100ece:	ee                   	out    %al,(%dx)
+    pos = inb(addr_6845 + 1) << 8;
+c0100ecf:	0f b7 05 86 7e 11 c0 	movzwl 0xc0117e86,%eax
+c0100ed6:	83 c0 01             	add    $0x1,%eax
+c0100ed9:	0f b7 c0             	movzwl %ax,%eax
+c0100edc:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0100ee0:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
+c0100ee4:	89 c2                	mov    %eax,%edx
+c0100ee6:	ec                   	in     (%dx),%al
+c0100ee7:	88 45 ed             	mov    %al,-0x13(%ebp)
+    return data;
+c0100eea:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+c0100eee:	0f b6 c0             	movzbl %al,%eax
+c0100ef1:	c1 e0 08             	shl    $0x8,%eax
+c0100ef4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    outb(addr_6845, 15);
+c0100ef7:	0f b7 05 86 7e 11 c0 	movzwl 0xc0117e86,%eax
+c0100efe:	0f b7 c0             	movzwl %ax,%eax
+c0100f01:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+c0100f05:	c6 45 e9 0f          	movb   $0xf,-0x17(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0100f09:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+c0100f0d:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c0100f11:	ee                   	out    %al,(%dx)
+    pos |= inb(addr_6845 + 1);
+c0100f12:	0f b7 05 86 7e 11 c0 	movzwl 0xc0117e86,%eax
+c0100f19:	83 c0 01             	add    $0x1,%eax
+c0100f1c:	0f b7 c0             	movzwl %ax,%eax
+c0100f1f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0100f23:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
+c0100f27:	89 c2                	mov    %eax,%edx
+c0100f29:	ec                   	in     (%dx),%al
+c0100f2a:	88 45 e5             	mov    %al,-0x1b(%ebp)
+    return data;
+c0100f2d:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+c0100f31:	0f b6 c0             	movzbl %al,%eax
+c0100f34:	09 45 f4             	or     %eax,-0xc(%ebp)
+
+    crt_buf = (uint16_t*) cp;
+c0100f37:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100f3a:	a3 80 7e 11 c0       	mov    %eax,0xc0117e80
+    crt_pos = pos;
+c0100f3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100f42:	66 a3 84 7e 11 c0    	mov    %ax,0xc0117e84
+}
+c0100f48:	c9                   	leave  
+c0100f49:	c3                   	ret    
+
+c0100f4a <serial_init>:
+
+static bool serial_exists = 0;
+
+static void
+serial_init(void) {
+c0100f4a:	55                   	push   %ebp
+c0100f4b:	89 e5                	mov    %esp,%ebp
+c0100f4d:	83 ec 48             	sub    $0x48,%esp
+c0100f50:	66 c7 45 f6 fa 03    	movw   $0x3fa,-0xa(%ebp)
+c0100f56:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0100f5a:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+c0100f5e:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c0100f62:	ee                   	out    %al,(%dx)
+c0100f63:	66 c7 45 f2 fb 03    	movw   $0x3fb,-0xe(%ebp)
+c0100f69:	c6 45 f1 80          	movb   $0x80,-0xf(%ebp)
+c0100f6d:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c0100f71:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0100f75:	ee                   	out    %al,(%dx)
+c0100f76:	66 c7 45 ee f8 03    	movw   $0x3f8,-0x12(%ebp)
+c0100f7c:	c6 45 ed 0c          	movb   $0xc,-0x13(%ebp)
+c0100f80:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+c0100f84:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0100f88:	ee                   	out    %al,(%dx)
+c0100f89:	66 c7 45 ea f9 03    	movw   $0x3f9,-0x16(%ebp)
+c0100f8f:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
+c0100f93:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+c0100f97:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c0100f9b:	ee                   	out    %al,(%dx)
+c0100f9c:	66 c7 45 e6 fb 03    	movw   $0x3fb,-0x1a(%ebp)
+c0100fa2:	c6 45 e5 03          	movb   $0x3,-0x1b(%ebp)
+c0100fa6:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+c0100faa:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c0100fae:	ee                   	out    %al,(%dx)
+c0100faf:	66 c7 45 e2 fc 03    	movw   $0x3fc,-0x1e(%ebp)
+c0100fb5:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
+c0100fb9:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+c0100fbd:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+c0100fc1:	ee                   	out    %al,(%dx)
+c0100fc2:	66 c7 45 de f9 03    	movw   $0x3f9,-0x22(%ebp)
+c0100fc8:	c6 45 dd 01          	movb   $0x1,-0x23(%ebp)
+c0100fcc:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c0100fd0:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+c0100fd4:	ee                   	out    %al,(%dx)
+c0100fd5:	66 c7 45 da fd 03    	movw   $0x3fd,-0x26(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0100fdb:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
+c0100fdf:	89 c2                	mov    %eax,%edx
+c0100fe1:	ec                   	in     (%dx),%al
+c0100fe2:	88 45 d9             	mov    %al,-0x27(%ebp)
+    return data;
+c0100fe5:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+    // Enable rcv interrupts
+    outb(COM1 + COM_IER, COM_IER_RDI);
+
+    // Clear any preexisting overrun indications and interrupts
+    // Serial port doesn't exist if COM_LSR returns 0xFF
+    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
+c0100fe9:	3c ff                	cmp    $0xff,%al
+c0100feb:	0f 95 c0             	setne  %al
+c0100fee:	0f b6 c0             	movzbl %al,%eax
+c0100ff1:	a3 88 7e 11 c0       	mov    %eax,0xc0117e88
+c0100ff6:	66 c7 45 d6 fa 03    	movw   $0x3fa,-0x2a(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0100ffc:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
+c0101000:	89 c2                	mov    %eax,%edx
+c0101002:	ec                   	in     (%dx),%al
+c0101003:	88 45 d5             	mov    %al,-0x2b(%ebp)
+c0101006:	66 c7 45 d2 f8 03    	movw   $0x3f8,-0x2e(%ebp)
+c010100c:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
+c0101010:	89 c2                	mov    %eax,%edx
+c0101012:	ec                   	in     (%dx),%al
+c0101013:	88 45 d1             	mov    %al,-0x2f(%ebp)
+    (void) inb(COM1+COM_IIR);
+    (void) inb(COM1+COM_RX);
+
+    if (serial_exists) {
+c0101016:	a1 88 7e 11 c0       	mov    0xc0117e88,%eax
+c010101b:	85 c0                	test   %eax,%eax
+c010101d:	74 0c                	je     c010102b <serial_init+0xe1>
+        pic_enable(IRQ_COM1);
+c010101f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+c0101026:	e8 d6 06 00 00       	call   c0101701 <pic_enable>
+    }
+}
+c010102b:	c9                   	leave  
+c010102c:	c3                   	ret    
+
+c010102d <lpt_putc_sub>:
+
+static void
+lpt_putc_sub(int c) {
+c010102d:	55                   	push   %ebp
+c010102e:	89 e5                	mov    %esp,%ebp
+c0101030:	83 ec 20             	sub    $0x20,%esp
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+c0101033:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c010103a:	eb 09                	jmp    c0101045 <lpt_putc_sub+0x18>
+        delay();
+c010103c:	e8 db fd ff ff       	call   c0100e1c <delay>
+}
+
+static void
+lpt_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+c0101041:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c0101045:	66 c7 45 fa 79 03    	movw   $0x379,-0x6(%ebp)
+c010104b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c010104f:	89 c2                	mov    %eax,%edx
+c0101051:	ec                   	in     (%dx),%al
+c0101052:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+c0101055:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+c0101059:	84 c0                	test   %al,%al
+c010105b:	78 09                	js     c0101066 <lpt_putc_sub+0x39>
+c010105d:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+c0101064:	7e d6                	jle    c010103c <lpt_putc_sub+0xf>
+        delay();
+    }
+    outb(LPTPORT + 0, c);
+c0101066:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101069:	0f b6 c0             	movzbl %al,%eax
+c010106c:	66 c7 45 f6 78 03    	movw   $0x378,-0xa(%ebp)
+c0101072:	88 45 f5             	mov    %al,-0xb(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0101075:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+c0101079:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c010107d:	ee                   	out    %al,(%dx)
+c010107e:	66 c7 45 f2 7a 03    	movw   $0x37a,-0xe(%ebp)
+c0101084:	c6 45 f1 0d          	movb   $0xd,-0xf(%ebp)
+c0101088:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c010108c:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101090:	ee                   	out    %al,(%dx)
+c0101091:	66 c7 45 ee 7a 03    	movw   $0x37a,-0x12(%ebp)
+c0101097:	c6 45 ed 08          	movb   $0x8,-0x13(%ebp)
+c010109b:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+c010109f:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c01010a3:	ee                   	out    %al,(%dx)
+    outb(LPTPORT + 2, 0x08 | 0x04 | 0x01);
+    outb(LPTPORT + 2, 0x08);
+}
+c01010a4:	c9                   	leave  
+c01010a5:	c3                   	ret    
+
+c01010a6 <lpt_putc>:
+
+/* lpt_putc - copy console output to parallel port */
+static void
+lpt_putc(int c) {
+c01010a6:	55                   	push   %ebp
+c01010a7:	89 e5                	mov    %esp,%ebp
+c01010a9:	83 ec 04             	sub    $0x4,%esp
+    if (c != '\b') {
+c01010ac:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+c01010b0:	74 0d                	je     c01010bf <lpt_putc+0x19>
+        lpt_putc_sub(c);
+c01010b2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01010b5:	89 04 24             	mov    %eax,(%esp)
+c01010b8:	e8 70 ff ff ff       	call   c010102d <lpt_putc_sub>
+c01010bd:	eb 24                	jmp    c01010e3 <lpt_putc+0x3d>
+    }
+    else {
+        lpt_putc_sub('\b');
+c01010bf:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+c01010c6:	e8 62 ff ff ff       	call   c010102d <lpt_putc_sub>
+        lpt_putc_sub(' ');
+c01010cb:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+c01010d2:	e8 56 ff ff ff       	call   c010102d <lpt_putc_sub>
+        lpt_putc_sub('\b');
+c01010d7:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+c01010de:	e8 4a ff ff ff       	call   c010102d <lpt_putc_sub>
+    }
+}
+c01010e3:	c9                   	leave  
+c01010e4:	c3                   	ret    
+
+c01010e5 <cga_putc>:
+
+/* cga_putc - print character to console */
+static void
+cga_putc(int c) {
+c01010e5:	55                   	push   %ebp
+c01010e6:	89 e5                	mov    %esp,%ebp
+c01010e8:	53                   	push   %ebx
+c01010e9:	83 ec 34             	sub    $0x34,%esp
+    // set black on white
+    if (!(c & ~0xFF)) {
+c01010ec:	8b 45 08             	mov    0x8(%ebp),%eax
+c01010ef:	b0 00                	mov    $0x0,%al
+c01010f1:	85 c0                	test   %eax,%eax
+c01010f3:	75 07                	jne    c01010fc <cga_putc+0x17>
+        c |= 0x0700;
+c01010f5:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)
+    }
+
+    switch (c & 0xff) {
+c01010fc:	8b 45 08             	mov    0x8(%ebp),%eax
+c01010ff:	0f b6 c0             	movzbl %al,%eax
+c0101102:	83 f8 0a             	cmp    $0xa,%eax
+c0101105:	74 4c                	je     c0101153 <cga_putc+0x6e>
+c0101107:	83 f8 0d             	cmp    $0xd,%eax
+c010110a:	74 57                	je     c0101163 <cga_putc+0x7e>
+c010110c:	83 f8 08             	cmp    $0x8,%eax
+c010110f:	0f 85 88 00 00 00    	jne    c010119d <cga_putc+0xb8>
+    case '\b':
+        if (crt_pos > 0) {
+c0101115:	0f b7 05 84 7e 11 c0 	movzwl 0xc0117e84,%eax
+c010111c:	66 85 c0             	test   %ax,%ax
+c010111f:	74 30                	je     c0101151 <cga_putc+0x6c>
+            crt_pos --;
+c0101121:	0f b7 05 84 7e 11 c0 	movzwl 0xc0117e84,%eax
+c0101128:	83 e8 01             	sub    $0x1,%eax
+c010112b:	66 a3 84 7e 11 c0    	mov    %ax,0xc0117e84
+            crt_buf[crt_pos] = (c & ~0xff) | ' ';
+c0101131:	a1 80 7e 11 c0       	mov    0xc0117e80,%eax
+c0101136:	0f b7 15 84 7e 11 c0 	movzwl 0xc0117e84,%edx
+c010113d:	0f b7 d2             	movzwl %dx,%edx
+c0101140:	01 d2                	add    %edx,%edx
+c0101142:	01 c2                	add    %eax,%edx
+c0101144:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101147:	b0 00                	mov    $0x0,%al
+c0101149:	83 c8 20             	or     $0x20,%eax
+c010114c:	66 89 02             	mov    %ax,(%edx)
+        }
+        break;
+c010114f:	eb 72                	jmp    c01011c3 <cga_putc+0xde>
+c0101151:	eb 70                	jmp    c01011c3 <cga_putc+0xde>
+    case '\n':
+        crt_pos += CRT_COLS;
+c0101153:	0f b7 05 84 7e 11 c0 	movzwl 0xc0117e84,%eax
+c010115a:	83 c0 50             	add    $0x50,%eax
+c010115d:	66 a3 84 7e 11 c0    	mov    %ax,0xc0117e84
+    case '\r':
+        crt_pos -= (crt_pos % CRT_COLS);
+c0101163:	0f b7 1d 84 7e 11 c0 	movzwl 0xc0117e84,%ebx
+c010116a:	0f b7 0d 84 7e 11 c0 	movzwl 0xc0117e84,%ecx
+c0101171:	0f b7 c1             	movzwl %cx,%eax
+c0101174:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
+c010117a:	c1 e8 10             	shr    $0x10,%eax
+c010117d:	89 c2                	mov    %eax,%edx
+c010117f:	66 c1 ea 06          	shr    $0x6,%dx
+c0101183:	89 d0                	mov    %edx,%eax
+c0101185:	c1 e0 02             	shl    $0x2,%eax
+c0101188:	01 d0                	add    %edx,%eax
+c010118a:	c1 e0 04             	shl    $0x4,%eax
+c010118d:	29 c1                	sub    %eax,%ecx
+c010118f:	89 ca                	mov    %ecx,%edx
+c0101191:	89 d8                	mov    %ebx,%eax
+c0101193:	29 d0                	sub    %edx,%eax
+c0101195:	66 a3 84 7e 11 c0    	mov    %ax,0xc0117e84
+        break;
+c010119b:	eb 26                	jmp    c01011c3 <cga_putc+0xde>
+    default:
+        crt_buf[crt_pos ++] = c;     // write the character
+c010119d:	8b 0d 80 7e 11 c0    	mov    0xc0117e80,%ecx
+c01011a3:	0f b7 05 84 7e 11 c0 	movzwl 0xc0117e84,%eax
+c01011aa:	8d 50 01             	lea    0x1(%eax),%edx
+c01011ad:	66 89 15 84 7e 11 c0 	mov    %dx,0xc0117e84
+c01011b4:	0f b7 c0             	movzwl %ax,%eax
+c01011b7:	01 c0                	add    %eax,%eax
+c01011b9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
+c01011bc:	8b 45 08             	mov    0x8(%ebp),%eax
+c01011bf:	66 89 02             	mov    %ax,(%edx)
+        break;
+c01011c2:	90                   	nop
+    }
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+c01011c3:	0f b7 05 84 7e 11 c0 	movzwl 0xc0117e84,%eax
+c01011ca:	66 3d cf 07          	cmp    $0x7cf,%ax
+c01011ce:	76 5b                	jbe    c010122b <cga_putc+0x146>
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+c01011d0:	a1 80 7e 11 c0       	mov    0xc0117e80,%eax
+c01011d5:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+c01011db:	a1 80 7e 11 c0       	mov    0xc0117e80,%eax
+c01011e0:	c7 44 24 08 00 0f 00 	movl   $0xf00,0x8(%esp)
+c01011e7:	00 
+c01011e8:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01011ec:	89 04 24             	mov    %eax,(%esp)
+c01011ef:	e8 11 4d 00 00       	call   c0105f05 <memmove>
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+c01011f4:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
+c01011fb:	eb 15                	jmp    c0101212 <cga_putc+0x12d>
+            crt_buf[i] = 0x0700 | ' ';
+c01011fd:	a1 80 7e 11 c0       	mov    0xc0117e80,%eax
+c0101202:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0101205:	01 d2                	add    %edx,%edx
+c0101207:	01 d0                	add    %edx,%eax
+c0101209:	66 c7 00 20 07       	movw   $0x720,(%eax)
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+c010120e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0101212:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
+c0101219:	7e e2                	jle    c01011fd <cga_putc+0x118>
+            crt_buf[i] = 0x0700 | ' ';
+        }
+        crt_pos -= CRT_COLS;
+c010121b:	0f b7 05 84 7e 11 c0 	movzwl 0xc0117e84,%eax
+c0101222:	83 e8 50             	sub    $0x50,%eax
+c0101225:	66 a3 84 7e 11 c0    	mov    %ax,0xc0117e84
+    }
+
+    // move that little blinky thing
+    outb(addr_6845, 14);
+c010122b:	0f b7 05 86 7e 11 c0 	movzwl 0xc0117e86,%eax
+c0101232:	0f b7 c0             	movzwl %ax,%eax
+c0101235:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c0101239:	c6 45 f1 0e          	movb   $0xe,-0xf(%ebp)
+c010123d:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c0101241:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101245:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos >> 8);
+c0101246:	0f b7 05 84 7e 11 c0 	movzwl 0xc0117e84,%eax
+c010124d:	66 c1 e8 08          	shr    $0x8,%ax
+c0101251:	0f b6 c0             	movzbl %al,%eax
+c0101254:	0f b7 15 86 7e 11 c0 	movzwl 0xc0117e86,%edx
+c010125b:	83 c2 01             	add    $0x1,%edx
+c010125e:	0f b7 d2             	movzwl %dx,%edx
+c0101261:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
+c0101265:	88 45 ed             	mov    %al,-0x13(%ebp)
+c0101268:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+c010126c:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0101270:	ee                   	out    %al,(%dx)
+    outb(addr_6845, 15);
+c0101271:	0f b7 05 86 7e 11 c0 	movzwl 0xc0117e86,%eax
+c0101278:	0f b7 c0             	movzwl %ax,%eax
+c010127b:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+c010127f:	c6 45 e9 0f          	movb   $0xf,-0x17(%ebp)
+c0101283:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+c0101287:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c010128b:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos);
+c010128c:	0f b7 05 84 7e 11 c0 	movzwl 0xc0117e84,%eax
+c0101293:	0f b6 c0             	movzbl %al,%eax
+c0101296:	0f b7 15 86 7e 11 c0 	movzwl 0xc0117e86,%edx
+c010129d:	83 c2 01             	add    $0x1,%edx
+c01012a0:	0f b7 d2             	movzwl %dx,%edx
+c01012a3:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
+c01012a7:	88 45 e5             	mov    %al,-0x1b(%ebp)
+c01012aa:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+c01012ae:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c01012b2:	ee                   	out    %al,(%dx)
+}
+c01012b3:	83 c4 34             	add    $0x34,%esp
+c01012b6:	5b                   	pop    %ebx
+c01012b7:	5d                   	pop    %ebp
+c01012b8:	c3                   	ret    
+
+c01012b9 <serial_putc_sub>:
+
+static void
+serial_putc_sub(int c) {
+c01012b9:	55                   	push   %ebp
+c01012ba:	89 e5                	mov    %esp,%ebp
+c01012bc:	83 ec 10             	sub    $0x10,%esp
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+c01012bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c01012c6:	eb 09                	jmp    c01012d1 <serial_putc_sub+0x18>
+        delay();
+c01012c8:	e8 4f fb ff ff       	call   c0100e1c <delay>
+}
+
+static void
+serial_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+c01012cd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c01012d1:	66 c7 45 fa fd 03    	movw   $0x3fd,-0x6(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c01012d7:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c01012db:	89 c2                	mov    %eax,%edx
+c01012dd:	ec                   	in     (%dx),%al
+c01012de:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+c01012e1:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+c01012e5:	0f b6 c0             	movzbl %al,%eax
+c01012e8:	83 e0 20             	and    $0x20,%eax
+c01012eb:	85 c0                	test   %eax,%eax
+c01012ed:	75 09                	jne    c01012f8 <serial_putc_sub+0x3f>
+c01012ef:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+c01012f6:	7e d0                	jle    c01012c8 <serial_putc_sub+0xf>
+        delay();
+    }
+    outb(COM1 + COM_TX, c);
+c01012f8:	8b 45 08             	mov    0x8(%ebp),%eax
+c01012fb:	0f b6 c0             	movzbl %al,%eax
+c01012fe:	66 c7 45 f6 f8 03    	movw   $0x3f8,-0xa(%ebp)
+c0101304:	88 45 f5             	mov    %al,-0xb(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c0101307:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+c010130b:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c010130f:	ee                   	out    %al,(%dx)
+}
+c0101310:	c9                   	leave  
+c0101311:	c3                   	ret    
+
+c0101312 <serial_putc>:
+
+/* serial_putc - print character to serial port */
+static void
+serial_putc(int c) {
+c0101312:	55                   	push   %ebp
+c0101313:	89 e5                	mov    %esp,%ebp
+c0101315:	83 ec 04             	sub    $0x4,%esp
+    if (c != '\b') {
+c0101318:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+c010131c:	74 0d                	je     c010132b <serial_putc+0x19>
+        serial_putc_sub(c);
+c010131e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101321:	89 04 24             	mov    %eax,(%esp)
+c0101324:	e8 90 ff ff ff       	call   c01012b9 <serial_putc_sub>
+c0101329:	eb 24                	jmp    c010134f <serial_putc+0x3d>
+    }
+    else {
+        serial_putc_sub('\b');
+c010132b:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+c0101332:	e8 82 ff ff ff       	call   c01012b9 <serial_putc_sub>
+        serial_putc_sub(' ');
+c0101337:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+c010133e:	e8 76 ff ff ff       	call   c01012b9 <serial_putc_sub>
+        serial_putc_sub('\b');
+c0101343:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+c010134a:	e8 6a ff ff ff       	call   c01012b9 <serial_putc_sub>
+    }
+}
+c010134f:	c9                   	leave  
+c0101350:	c3                   	ret    
+
+c0101351 <cons_intr>:
+/* *
+ * cons_intr - called by device interrupt routines to feed input
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+c0101351:	55                   	push   %ebp
+c0101352:	89 e5                	mov    %esp,%ebp
+c0101354:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = (*proc)()) != -1) {
+c0101357:	eb 33                	jmp    c010138c <cons_intr+0x3b>
+        if (c != 0) {
+c0101359:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010135d:	74 2d                	je     c010138c <cons_intr+0x3b>
+            cons.buf[cons.wpos ++] = c;
+c010135f:	a1 a4 80 11 c0       	mov    0xc01180a4,%eax
+c0101364:	8d 50 01             	lea    0x1(%eax),%edx
+c0101367:	89 15 a4 80 11 c0    	mov    %edx,0xc01180a4
+c010136d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0101370:	88 90 a0 7e 11 c0    	mov    %dl,-0x3fee8160(%eax)
+            if (cons.wpos == CONSBUFSIZE) {
+c0101376:	a1 a4 80 11 c0       	mov    0xc01180a4,%eax
+c010137b:	3d 00 02 00 00       	cmp    $0x200,%eax
+c0101380:	75 0a                	jne    c010138c <cons_intr+0x3b>
+                cons.wpos = 0;
+c0101382:	c7 05 a4 80 11 c0 00 	movl   $0x0,0xc01180a4
+c0101389:	00 00 00 
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+    int c;
+    while ((c = (*proc)()) != -1) {
+c010138c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010138f:	ff d0                	call   *%eax
+c0101391:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0101394:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+c0101398:	75 bf                	jne    c0101359 <cons_intr+0x8>
+            if (cons.wpos == CONSBUFSIZE) {
+                cons.wpos = 0;
+            }
+        }
+    }
+}
+c010139a:	c9                   	leave  
+c010139b:	c3                   	ret    
+
+c010139c <serial_proc_data>:
+
+/* serial_proc_data - get data from serial port */
+static int
+serial_proc_data(void) {
+c010139c:	55                   	push   %ebp
+c010139d:	89 e5                	mov    %esp,%ebp
+c010139f:	83 ec 10             	sub    $0x10,%esp
+c01013a2:	66 c7 45 fa fd 03    	movw   $0x3fd,-0x6(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c01013a8:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c01013ac:	89 c2                	mov    %eax,%edx
+c01013ae:	ec                   	in     (%dx),%al
+c01013af:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+c01013b2:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {
+c01013b6:	0f b6 c0             	movzbl %al,%eax
+c01013b9:	83 e0 01             	and    $0x1,%eax
+c01013bc:	85 c0                	test   %eax,%eax
+c01013be:	75 07                	jne    c01013c7 <serial_proc_data+0x2b>
+        return -1;
+c01013c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c01013c5:	eb 2a                	jmp    c01013f1 <serial_proc_data+0x55>
+c01013c7:	66 c7 45 f6 f8 03    	movw   $0x3f8,-0xa(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c01013cd:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c01013d1:	89 c2                	mov    %eax,%edx
+c01013d3:	ec                   	in     (%dx),%al
+c01013d4:	88 45 f5             	mov    %al,-0xb(%ebp)
+    return data;
+c01013d7:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+    }
+    int c = inb(COM1 + COM_RX);
+c01013db:	0f b6 c0             	movzbl %al,%eax
+c01013de:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    if (c == 127) {
+c01013e1:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
+c01013e5:	75 07                	jne    c01013ee <serial_proc_data+0x52>
+        c = '\b';
+c01013e7:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
+    }
+    return c;
+c01013ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c01013f1:	c9                   	leave  
+c01013f2:	c3                   	ret    
+
+c01013f3 <serial_intr>:
+
+/* serial_intr - try to feed input characters from serial port */
+void
+serial_intr(void) {
+c01013f3:	55                   	push   %ebp
+c01013f4:	89 e5                	mov    %esp,%ebp
+c01013f6:	83 ec 18             	sub    $0x18,%esp
+    if (serial_exists) {
+c01013f9:	a1 88 7e 11 c0       	mov    0xc0117e88,%eax
+c01013fe:	85 c0                	test   %eax,%eax
+c0101400:	74 0c                	je     c010140e <serial_intr+0x1b>
+        cons_intr(serial_proc_data);
+c0101402:	c7 04 24 9c 13 10 c0 	movl   $0xc010139c,(%esp)
+c0101409:	e8 43 ff ff ff       	call   c0101351 <cons_intr>
+    }
+}
+c010140e:	c9                   	leave  
+c010140f:	c3                   	ret    
+
+c0101410 <kbd_proc_data>:
+ *
+ * The kbd_proc_data() function gets data from the keyboard.
+ * If we finish a character, return it, else 0. And return -1 if no data.
+ * */
+static int
+kbd_proc_data(void) {
+c0101410:	55                   	push   %ebp
+c0101411:	89 e5                	mov    %esp,%ebp
+c0101413:	83 ec 38             	sub    $0x38,%esp
+c0101416:	66 c7 45 f0 64 00    	movw   $0x64,-0x10(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c010141c:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+c0101420:	89 c2                	mov    %eax,%edx
+c0101422:	ec                   	in     (%dx),%al
+c0101423:	88 45 ef             	mov    %al,-0x11(%ebp)
+    return data;
+c0101426:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    int c;
+    uint8_t data;
+    static uint32_t shift;
+
+    if ((inb(KBSTATP) & KBS_DIB) == 0) {
+c010142a:	0f b6 c0             	movzbl %al,%eax
+c010142d:	83 e0 01             	and    $0x1,%eax
+c0101430:	85 c0                	test   %eax,%eax
+c0101432:	75 0a                	jne    c010143e <kbd_proc_data+0x2e>
+        return -1;
+c0101434:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0101439:	e9 59 01 00 00       	jmp    c0101597 <kbd_proc_data+0x187>
+c010143e:	66 c7 45 ec 60 00    	movw   $0x60,-0x14(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+c0101444:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c0101448:	89 c2                	mov    %eax,%edx
+c010144a:	ec                   	in     (%dx),%al
+c010144b:	88 45 eb             	mov    %al,-0x15(%ebp)
+    return data;
+c010144e:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+    }
+
+    data = inb(KBDATAP);
+c0101452:	88 45 f3             	mov    %al,-0xd(%ebp)
+
+    if (data == 0xE0) {
+c0101455:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
+c0101459:	75 17                	jne    c0101472 <kbd_proc_data+0x62>
+        // E0 escape character
+        shift |= E0ESC;
+c010145b:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c0101460:	83 c8 40             	or     $0x40,%eax
+c0101463:	a3 a8 80 11 c0       	mov    %eax,0xc01180a8
+        return 0;
+c0101468:	b8 00 00 00 00       	mov    $0x0,%eax
+c010146d:	e9 25 01 00 00       	jmp    c0101597 <kbd_proc_data+0x187>
+    } else if (data & 0x80) {
+c0101472:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101476:	84 c0                	test   %al,%al
+c0101478:	79 47                	jns    c01014c1 <kbd_proc_data+0xb1>
+        // Key released
+        data = (shift & E0ESC ? data : data & 0x7F);
+c010147a:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c010147f:	83 e0 40             	and    $0x40,%eax
+c0101482:	85 c0                	test   %eax,%eax
+c0101484:	75 09                	jne    c010148f <kbd_proc_data+0x7f>
+c0101486:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c010148a:	83 e0 7f             	and    $0x7f,%eax
+c010148d:	eb 04                	jmp    c0101493 <kbd_proc_data+0x83>
+c010148f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101493:	88 45 f3             	mov    %al,-0xd(%ebp)
+        shift &= ~(shiftcode[data] | E0ESC);
+c0101496:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c010149a:	0f b6 80 60 70 11 c0 	movzbl -0x3fee8fa0(%eax),%eax
+c01014a1:	83 c8 40             	or     $0x40,%eax
+c01014a4:	0f b6 c0             	movzbl %al,%eax
+c01014a7:	f7 d0                	not    %eax
+c01014a9:	89 c2                	mov    %eax,%edx
+c01014ab:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c01014b0:	21 d0                	and    %edx,%eax
+c01014b2:	a3 a8 80 11 c0       	mov    %eax,0xc01180a8
+        return 0;
+c01014b7:	b8 00 00 00 00       	mov    $0x0,%eax
+c01014bc:	e9 d6 00 00 00       	jmp    c0101597 <kbd_proc_data+0x187>
+    } else if (shift & E0ESC) {
+c01014c1:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c01014c6:	83 e0 40             	and    $0x40,%eax
+c01014c9:	85 c0                	test   %eax,%eax
+c01014cb:	74 11                	je     c01014de <kbd_proc_data+0xce>
+        // Last character was an E0 escape; or with 0x80
+        data |= 0x80;
+c01014cd:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
+        shift &= ~E0ESC;
+c01014d1:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c01014d6:	83 e0 bf             	and    $0xffffffbf,%eax
+c01014d9:	a3 a8 80 11 c0       	mov    %eax,0xc01180a8
+    }
+
+    shift |= shiftcode[data];
+c01014de:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c01014e2:	0f b6 80 60 70 11 c0 	movzbl -0x3fee8fa0(%eax),%eax
+c01014e9:	0f b6 d0             	movzbl %al,%edx
+c01014ec:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c01014f1:	09 d0                	or     %edx,%eax
+c01014f3:	a3 a8 80 11 c0       	mov    %eax,0xc01180a8
+    shift ^= togglecode[data];
+c01014f8:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c01014fc:	0f b6 80 60 71 11 c0 	movzbl -0x3fee8ea0(%eax),%eax
+c0101503:	0f b6 d0             	movzbl %al,%edx
+c0101506:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c010150b:	31 d0                	xor    %edx,%eax
+c010150d:	a3 a8 80 11 c0       	mov    %eax,0xc01180a8
+
+    c = charcode[shift & (CTL | SHIFT)][data];
+c0101512:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c0101517:	83 e0 03             	and    $0x3,%eax
+c010151a:	8b 14 85 60 75 11 c0 	mov    -0x3fee8aa0(,%eax,4),%edx
+c0101521:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101525:	01 d0                	add    %edx,%eax
+c0101527:	0f b6 00             	movzbl (%eax),%eax
+c010152a:	0f b6 c0             	movzbl %al,%eax
+c010152d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (shift & CAPSLOCK) {
+c0101530:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c0101535:	83 e0 08             	and    $0x8,%eax
+c0101538:	85 c0                	test   %eax,%eax
+c010153a:	74 22                	je     c010155e <kbd_proc_data+0x14e>
+        if ('a' <= c && c <= 'z')
+c010153c:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
+c0101540:	7e 0c                	jle    c010154e <kbd_proc_data+0x13e>
+c0101542:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
+c0101546:	7f 06                	jg     c010154e <kbd_proc_data+0x13e>
+            c += 'A' - 'a';
+c0101548:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
+c010154c:	eb 10                	jmp    c010155e <kbd_proc_data+0x14e>
+        else if ('A' <= c && c <= 'Z')
+c010154e:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
+c0101552:	7e 0a                	jle    c010155e <kbd_proc_data+0x14e>
+c0101554:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
+c0101558:	7f 04                	jg     c010155e <kbd_proc_data+0x14e>
+            c += 'a' - 'A';
+c010155a:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+    }
+
+    // Process special keys
+    // Ctrl-Alt-Del: reboot
+    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+c010155e:	a1 a8 80 11 c0       	mov    0xc01180a8,%eax
+c0101563:	f7 d0                	not    %eax
+c0101565:	83 e0 06             	and    $0x6,%eax
+c0101568:	85 c0                	test   %eax,%eax
+c010156a:	75 28                	jne    c0101594 <kbd_proc_data+0x184>
+c010156c:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
+c0101573:	75 1f                	jne    c0101594 <kbd_proc_data+0x184>
+        cprintf("Rebooting!\n");
+c0101575:	c7 04 24 7d 63 10 c0 	movl   $0xc010637d,(%esp)
+c010157c:	e8 bb ed ff ff       	call   c010033c <cprintf>
+c0101581:	66 c7 45 e8 92 00    	movw   $0x92,-0x18(%ebp)
+c0101587:	c6 45 e7 03          	movb   $0x3,-0x19(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c010158b:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+c010158f:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+c0101593:	ee                   	out    %al,(%dx)
+        outb(0x92, 0x3); // courtesy of Chris Frost
+    }
+    return c;
+c0101594:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0101597:	c9                   	leave  
+c0101598:	c3                   	ret    
+
+c0101599 <kbd_intr>:
+
+/* kbd_intr - try to feed input characters from keyboard */
+static void
+kbd_intr(void) {
+c0101599:	55                   	push   %ebp
+c010159a:	89 e5                	mov    %esp,%ebp
+c010159c:	83 ec 18             	sub    $0x18,%esp
+    cons_intr(kbd_proc_data);
+c010159f:	c7 04 24 10 14 10 c0 	movl   $0xc0101410,(%esp)
+c01015a6:	e8 a6 fd ff ff       	call   c0101351 <cons_intr>
+}
+c01015ab:	c9                   	leave  
+c01015ac:	c3                   	ret    
+
+c01015ad <kbd_init>:
+
+static void
+kbd_init(void) {
+c01015ad:	55                   	push   %ebp
+c01015ae:	89 e5                	mov    %esp,%ebp
+c01015b0:	83 ec 18             	sub    $0x18,%esp
+    // drain the kbd buffer
+    kbd_intr();
+c01015b3:	e8 e1 ff ff ff       	call   c0101599 <kbd_intr>
+    pic_enable(IRQ_KBD);
+c01015b8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01015bf:	e8 3d 01 00 00       	call   c0101701 <pic_enable>
+}
+c01015c4:	c9                   	leave  
+c01015c5:	c3                   	ret    
+
+c01015c6 <cons_init>:
+
+/* cons_init - initializes the console devices */
+void
+cons_init(void) {
+c01015c6:	55                   	push   %ebp
+c01015c7:	89 e5                	mov    %esp,%ebp
+c01015c9:	83 ec 18             	sub    $0x18,%esp
+    cga_init();
+c01015cc:	e8 93 f8 ff ff       	call   c0100e64 <cga_init>
+    serial_init();
+c01015d1:	e8 74 f9 ff ff       	call   c0100f4a <serial_init>
+    kbd_init();
+c01015d6:	e8 d2 ff ff ff       	call   c01015ad <kbd_init>
+    if (!serial_exists) {
+c01015db:	a1 88 7e 11 c0       	mov    0xc0117e88,%eax
+c01015e0:	85 c0                	test   %eax,%eax
+c01015e2:	75 0c                	jne    c01015f0 <cons_init+0x2a>
+        cprintf("serial port does not exist!!\n");
+c01015e4:	c7 04 24 89 63 10 c0 	movl   $0xc0106389,(%esp)
+c01015eb:	e8 4c ed ff ff       	call   c010033c <cprintf>
+    }
+}
+c01015f0:	c9                   	leave  
+c01015f1:	c3                   	ret    
+
+c01015f2 <cons_putc>:
+
+/* cons_putc - print a single character @c to console devices */
+void
+cons_putc(int c) {
+c01015f2:	55                   	push   %ebp
+c01015f3:	89 e5                	mov    %esp,%ebp
+c01015f5:	83 ec 28             	sub    $0x28,%esp
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c01015f8:	e8 e2 f7 ff ff       	call   c0100ddf <__intr_save>
+c01015fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        lpt_putc(c);
+c0101600:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101603:	89 04 24             	mov    %eax,(%esp)
+c0101606:	e8 9b fa ff ff       	call   c01010a6 <lpt_putc>
+        cga_putc(c);
+c010160b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010160e:	89 04 24             	mov    %eax,(%esp)
+c0101611:	e8 cf fa ff ff       	call   c01010e5 <cga_putc>
+        serial_putc(c);
+c0101616:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101619:	89 04 24             	mov    %eax,(%esp)
+c010161c:	e8 f1 fc ff ff       	call   c0101312 <serial_putc>
+    }
+    local_intr_restore(intr_flag);
+c0101621:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101624:	89 04 24             	mov    %eax,(%esp)
+c0101627:	e8 dd f7 ff ff       	call   c0100e09 <__intr_restore>
+}
+c010162c:	c9                   	leave  
+c010162d:	c3                   	ret    
+
+c010162e <cons_getc>:
+/* *
+ * cons_getc - return the next input character from console,
+ * or 0 if none waiting.
+ * */
+int
+cons_getc(void) {
+c010162e:	55                   	push   %ebp
+c010162f:	89 e5                	mov    %esp,%ebp
+c0101631:	83 ec 28             	sub    $0x28,%esp
+    int c = 0;
+c0101634:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c010163b:	e8 9f f7 ff ff       	call   c0100ddf <__intr_save>
+c0101640:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    {
+        // poll for any pending input characters,
+        // so that this function works even when interrupts are disabled
+        // (e.g., when called from the kernel monitor).
+        serial_intr();
+c0101643:	e8 ab fd ff ff       	call   c01013f3 <serial_intr>
+        kbd_intr();
+c0101648:	e8 4c ff ff ff       	call   c0101599 <kbd_intr>
+
+        // grab the next character from the input buffer.
+        if (cons.rpos != cons.wpos) {
+c010164d:	8b 15 a0 80 11 c0    	mov    0xc01180a0,%edx
+c0101653:	a1 a4 80 11 c0       	mov    0xc01180a4,%eax
+c0101658:	39 c2                	cmp    %eax,%edx
+c010165a:	74 31                	je     c010168d <cons_getc+0x5f>
+            c = cons.buf[cons.rpos ++];
+c010165c:	a1 a0 80 11 c0       	mov    0xc01180a0,%eax
+c0101661:	8d 50 01             	lea    0x1(%eax),%edx
+c0101664:	89 15 a0 80 11 c0    	mov    %edx,0xc01180a0
+c010166a:	0f b6 80 a0 7e 11 c0 	movzbl -0x3fee8160(%eax),%eax
+c0101671:	0f b6 c0             	movzbl %al,%eax
+c0101674:	89 45 f4             	mov    %eax,-0xc(%ebp)
+            if (cons.rpos == CONSBUFSIZE) {
+c0101677:	a1 a0 80 11 c0       	mov    0xc01180a0,%eax
+c010167c:	3d 00 02 00 00       	cmp    $0x200,%eax
+c0101681:	75 0a                	jne    c010168d <cons_getc+0x5f>
+                cons.rpos = 0;
+c0101683:	c7 05 a0 80 11 c0 00 	movl   $0x0,0xc01180a0
+c010168a:	00 00 00 
+            }
+        }
+    }
+    local_intr_restore(intr_flag);
+c010168d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0101690:	89 04 24             	mov    %eax,(%esp)
+c0101693:	e8 71 f7 ff ff       	call   c0100e09 <__intr_restore>
+    return c;
+c0101698:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c010169b:	c9                   	leave  
+c010169c:	c3                   	ret    
+
+c010169d <intr_enable>:
+#include <x86.h>
+#include <intr.h>
+
+/* intr_enable - enable irq interrupt */
+void
+intr_enable(void) {
+c010169d:	55                   	push   %ebp
+c010169e:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+}
+
+static inline void
+sti(void) {
+    asm volatile ("sti");
+c01016a0:	fb                   	sti    
+    sti();
+}
+c01016a1:	5d                   	pop    %ebp
+c01016a2:	c3                   	ret    
+
+c01016a3 <intr_disable>:
+
+/* intr_disable - disable irq interrupt */
+void
+intr_disable(void) {
+c01016a3:	55                   	push   %ebp
+c01016a4:	89 e5                	mov    %esp,%ebp
+}
+
+static inline void
+cli(void) {
+    asm volatile ("cli" ::: "memory");
+c01016a6:	fa                   	cli    
+    cli();
+}
+c01016a7:	5d                   	pop    %ebp
+c01016a8:	c3                   	ret    
+
+c01016a9 <pic_setmask>:
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static uint16_t irq_mask = 0xFFFF & ~(1 << IRQ_SLAVE);
+static bool did_init = 0;
+
+static void
+pic_setmask(uint16_t mask) {
+c01016a9:	55                   	push   %ebp
+c01016aa:	89 e5                	mov    %esp,%ebp
+c01016ac:	83 ec 14             	sub    $0x14,%esp
+c01016af:	8b 45 08             	mov    0x8(%ebp),%eax
+c01016b2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+    irq_mask = mask;
+c01016b6:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c01016ba:	66 a3 70 75 11 c0    	mov    %ax,0xc0117570
+    if (did_init) {
+c01016c0:	a1 ac 80 11 c0       	mov    0xc01180ac,%eax
+c01016c5:	85 c0                	test   %eax,%eax
+c01016c7:	74 36                	je     c01016ff <pic_setmask+0x56>
+        outb(IO_PIC1 + 1, mask);
+c01016c9:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c01016cd:	0f b6 c0             	movzbl %al,%eax
+c01016d0:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+c01016d6:	88 45 fd             	mov    %al,-0x3(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+c01016d9:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
+c01016dd:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+c01016e1:	ee                   	out    %al,(%dx)
+        outb(IO_PIC2 + 1, mask >> 8);
+c01016e2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c01016e6:	66 c1 e8 08          	shr    $0x8,%ax
+c01016ea:	0f b6 c0             	movzbl %al,%eax
+c01016ed:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
+c01016f3:	88 45 f9             	mov    %al,-0x7(%ebp)
+c01016f6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+c01016fa:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c01016fe:	ee                   	out    %al,(%dx)
+    }
+}
+c01016ff:	c9                   	leave  
+c0101700:	c3                   	ret    
+
+c0101701 <pic_enable>:
+
+void
+pic_enable(unsigned int irq) {
+c0101701:	55                   	push   %ebp
+c0101702:	89 e5                	mov    %esp,%ebp
+c0101704:	83 ec 04             	sub    $0x4,%esp
+    pic_setmask(irq_mask & ~(1 << irq));
+c0101707:	8b 45 08             	mov    0x8(%ebp),%eax
+c010170a:	ba 01 00 00 00       	mov    $0x1,%edx
+c010170f:	89 c1                	mov    %eax,%ecx
+c0101711:	d3 e2                	shl    %cl,%edx
+c0101713:	89 d0                	mov    %edx,%eax
+c0101715:	f7 d0                	not    %eax
+c0101717:	89 c2                	mov    %eax,%edx
+c0101719:	0f b7 05 70 75 11 c0 	movzwl 0xc0117570,%eax
+c0101720:	21 d0                	and    %edx,%eax
+c0101722:	0f b7 c0             	movzwl %ax,%eax
+c0101725:	89 04 24             	mov    %eax,(%esp)
+c0101728:	e8 7c ff ff ff       	call   c01016a9 <pic_setmask>
+}
+c010172d:	c9                   	leave  
+c010172e:	c3                   	ret    
+
+c010172f <pic_init>:
+
+/* pic_init - initialize the 8259A interrupt controllers */
+void
+pic_init(void) {
+c010172f:	55                   	push   %ebp
+c0101730:	89 e5                	mov    %esp,%ebp
+c0101732:	83 ec 44             	sub    $0x44,%esp
+    did_init = 1;
+c0101735:	c7 05 ac 80 11 c0 01 	movl   $0x1,0xc01180ac
+c010173c:	00 00 00 
+c010173f:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+c0101745:	c6 45 fd ff          	movb   $0xff,-0x3(%ebp)
+c0101749:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
+c010174d:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+c0101751:	ee                   	out    %al,(%dx)
+c0101752:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
+c0101758:	c6 45 f9 ff          	movb   $0xff,-0x7(%ebp)
+c010175c:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+c0101760:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c0101764:	ee                   	out    %al,(%dx)
+c0101765:	66 c7 45 f6 20 00    	movw   $0x20,-0xa(%ebp)
+c010176b:	c6 45 f5 11          	movb   $0x11,-0xb(%ebp)
+c010176f:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+c0101773:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c0101777:	ee                   	out    %al,(%dx)
+c0101778:	66 c7 45 f2 21 00    	movw   $0x21,-0xe(%ebp)
+c010177e:	c6 45 f1 20          	movb   $0x20,-0xf(%ebp)
+c0101782:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c0101786:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c010178a:	ee                   	out    %al,(%dx)
+c010178b:	66 c7 45 ee 21 00    	movw   $0x21,-0x12(%ebp)
+c0101791:	c6 45 ed 04          	movb   $0x4,-0x13(%ebp)
+c0101795:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+c0101799:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c010179d:	ee                   	out    %al,(%dx)
+c010179e:	66 c7 45 ea 21 00    	movw   $0x21,-0x16(%ebp)
+c01017a4:	c6 45 e9 03          	movb   $0x3,-0x17(%ebp)
+c01017a8:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+c01017ac:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c01017b0:	ee                   	out    %al,(%dx)
+c01017b1:	66 c7 45 e6 a0 00    	movw   $0xa0,-0x1a(%ebp)
+c01017b7:	c6 45 e5 11          	movb   $0x11,-0x1b(%ebp)
+c01017bb:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+c01017bf:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c01017c3:	ee                   	out    %al,(%dx)
+c01017c4:	66 c7 45 e2 a1 00    	movw   $0xa1,-0x1e(%ebp)
+c01017ca:	c6 45 e1 28          	movb   $0x28,-0x1f(%ebp)
+c01017ce:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+c01017d2:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+c01017d6:	ee                   	out    %al,(%dx)
+c01017d7:	66 c7 45 de a1 00    	movw   $0xa1,-0x22(%ebp)
+c01017dd:	c6 45 dd 02          	movb   $0x2,-0x23(%ebp)
+c01017e1:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c01017e5:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+c01017e9:	ee                   	out    %al,(%dx)
+c01017ea:	66 c7 45 da a1 00    	movw   $0xa1,-0x26(%ebp)
+c01017f0:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
+c01017f4:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+c01017f8:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
+c01017fc:	ee                   	out    %al,(%dx)
+c01017fd:	66 c7 45 d6 20 00    	movw   $0x20,-0x2a(%ebp)
+c0101803:	c6 45 d5 68          	movb   $0x68,-0x2b(%ebp)
+c0101807:	0f b6 45 d5          	movzbl -0x2b(%ebp),%eax
+c010180b:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
+c010180f:	ee                   	out    %al,(%dx)
+c0101810:	66 c7 45 d2 20 00    	movw   $0x20,-0x2e(%ebp)
+c0101816:	c6 45 d1 0a          	movb   $0xa,-0x2f(%ebp)
+c010181a:	0f b6 45 d1          	movzbl -0x2f(%ebp),%eax
+c010181e:	0f b7 55 d2          	movzwl -0x2e(%ebp),%edx
+c0101822:	ee                   	out    %al,(%dx)
+c0101823:	66 c7 45 ce a0 00    	movw   $0xa0,-0x32(%ebp)
+c0101829:	c6 45 cd 68          	movb   $0x68,-0x33(%ebp)
+c010182d:	0f b6 45 cd          	movzbl -0x33(%ebp),%eax
+c0101831:	0f b7 55 ce          	movzwl -0x32(%ebp),%edx
+c0101835:	ee                   	out    %al,(%dx)
+c0101836:	66 c7 45 ca a0 00    	movw   $0xa0,-0x36(%ebp)
+c010183c:	c6 45 c9 0a          	movb   $0xa,-0x37(%ebp)
+c0101840:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
+c0101844:	0f b7 55 ca          	movzwl -0x36(%ebp),%edx
+c0101848:	ee                   	out    %al,(%dx)
+    outb(IO_PIC1, 0x0a);    // read IRR by default
+
+    outb(IO_PIC2, 0x68);    // OCW3
+    outb(IO_PIC2, 0x0a);    // OCW3
+
+    if (irq_mask != 0xFFFF) {
+c0101849:	0f b7 05 70 75 11 c0 	movzwl 0xc0117570,%eax
+c0101850:	66 83 f8 ff          	cmp    $0xffff,%ax
+c0101854:	74 12                	je     c0101868 <pic_init+0x139>
+        pic_setmask(irq_mask);
+c0101856:	0f b7 05 70 75 11 c0 	movzwl 0xc0117570,%eax
+c010185d:	0f b7 c0             	movzwl %ax,%eax
+c0101860:	89 04 24             	mov    %eax,(%esp)
+c0101863:	e8 41 fe ff ff       	call   c01016a9 <pic_setmask>
+    }
+}
+c0101868:	c9                   	leave  
+c0101869:	c3                   	ret    
+
+c010186a <print_ticks>:
+#include <kdebug.h>
+#include <string.h>
+
+#define TICK_NUM 100
+
+static void print_ticks() {
+c010186a:	55                   	push   %ebp
+c010186b:	89 e5                	mov    %esp,%ebp
+c010186d:	83 ec 18             	sub    $0x18,%esp
+    cprintf("%d ticks\n",TICK_NUM);
+c0101870:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+c0101877:	00 
+c0101878:	c7 04 24 c0 63 10 c0 	movl   $0xc01063c0,(%esp)
+c010187f:	e8 b8 ea ff ff       	call   c010033c <cprintf>
+#ifdef DEBUG_GRADE
+    cprintf("End of Test.\n");
+c0101884:	c7 04 24 ca 63 10 c0 	movl   $0xc01063ca,(%esp)
+c010188b:	e8 ac ea ff ff       	call   c010033c <cprintf>
+    panic("EOT: kernel seems ok.");
+c0101890:	c7 44 24 08 d8 63 10 	movl   $0xc01063d8,0x8(%esp)
+c0101897:	c0 
+c0101898:	c7 44 24 04 13 00 00 	movl   $0x13,0x4(%esp)
+c010189f:	00 
+c01018a0:	c7 04 24 ee 63 10 c0 	movl   $0xc01063ee,(%esp)
+c01018a7:	e8 14 f4 ff ff       	call   c0100cc0 <__panic>
+
+c01018ac <idt_init>:
+    sizeof(idt) - 1, (uintptr_t)idt
+};
+
+/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
+void
+idt_init(void) {
+c01018ac:	55                   	push   %ebp
+c01018ad:	89 e5                	mov    %esp,%ebp
+c01018af:	83 ec 10             	sub    $0x10,%esp
+      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+	extern uintptr_t __vectors[];
+	int i;
+	for(i=0;i<sizeof(idt)/sizeof(struct gatedesc);i++){
+c01018b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c01018b9:	e9 c3 00 00 00       	jmp    c0101981 <idt_init+0xd5>
+		SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+c01018be:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01018c1:	8b 04 85 00 76 11 c0 	mov    -0x3fee8a00(,%eax,4),%eax
+c01018c8:	89 c2                	mov    %eax,%edx
+c01018ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01018cd:	66 89 14 c5 c0 80 11 	mov    %dx,-0x3fee7f40(,%eax,8)
+c01018d4:	c0 
+c01018d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01018d8:	66 c7 04 c5 c2 80 11 	movw   $0x8,-0x3fee7f3e(,%eax,8)
+c01018df:	c0 08 00 
+c01018e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01018e5:	0f b6 14 c5 c4 80 11 	movzbl -0x3fee7f3c(,%eax,8),%edx
+c01018ec:	c0 
+c01018ed:	83 e2 e0             	and    $0xffffffe0,%edx
+c01018f0:	88 14 c5 c4 80 11 c0 	mov    %dl,-0x3fee7f3c(,%eax,8)
+c01018f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01018fa:	0f b6 14 c5 c4 80 11 	movzbl -0x3fee7f3c(,%eax,8),%edx
+c0101901:	c0 
+c0101902:	83 e2 1f             	and    $0x1f,%edx
+c0101905:	88 14 c5 c4 80 11 c0 	mov    %dl,-0x3fee7f3c(,%eax,8)
+c010190c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010190f:	0f b6 14 c5 c5 80 11 	movzbl -0x3fee7f3b(,%eax,8),%edx
+c0101916:	c0 
+c0101917:	83 e2 f0             	and    $0xfffffff0,%edx
+c010191a:	83 ca 0e             	or     $0xe,%edx
+c010191d:	88 14 c5 c5 80 11 c0 	mov    %dl,-0x3fee7f3b(,%eax,8)
+c0101924:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101927:	0f b6 14 c5 c5 80 11 	movzbl -0x3fee7f3b(,%eax,8),%edx
+c010192e:	c0 
+c010192f:	83 e2 ef             	and    $0xffffffef,%edx
+c0101932:	88 14 c5 c5 80 11 c0 	mov    %dl,-0x3fee7f3b(,%eax,8)
+c0101939:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010193c:	0f b6 14 c5 c5 80 11 	movzbl -0x3fee7f3b(,%eax,8),%edx
+c0101943:	c0 
+c0101944:	83 e2 9f             	and    $0xffffff9f,%edx
+c0101947:	88 14 c5 c5 80 11 c0 	mov    %dl,-0x3fee7f3b(,%eax,8)
+c010194e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101951:	0f b6 14 c5 c5 80 11 	movzbl -0x3fee7f3b(,%eax,8),%edx
+c0101958:	c0 
+c0101959:	83 ca 80             	or     $0xffffff80,%edx
+c010195c:	88 14 c5 c5 80 11 c0 	mov    %dl,-0x3fee7f3b(,%eax,8)
+c0101963:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101966:	8b 04 85 00 76 11 c0 	mov    -0x3fee8a00(,%eax,4),%eax
+c010196d:	c1 e8 10             	shr    $0x10,%eax
+c0101970:	89 c2                	mov    %eax,%edx
+c0101972:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101975:	66 89 14 c5 c6 80 11 	mov    %dx,-0x3fee7f3a(,%eax,8)
+c010197c:	c0 
+      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+	extern uintptr_t __vectors[];
+	int i;
+	for(i=0;i<sizeof(idt)/sizeof(struct gatedesc);i++){
+c010197d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c0101981:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101984:	3d ff 00 00 00       	cmp    $0xff,%eax
+c0101989:	0f 86 2f ff ff ff    	jbe    c01018be <idt_init+0x12>
+		SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+	}
+	SETGATE(idt[T_SWITCH_TOK],0,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER);
+c010198f:	a1 e4 77 11 c0       	mov    0xc01177e4,%eax
+c0101994:	66 a3 88 84 11 c0    	mov    %ax,0xc0118488
+c010199a:	66 c7 05 8a 84 11 c0 	movw   $0x8,0xc011848a
+c01019a1:	08 00 
+c01019a3:	0f b6 05 8c 84 11 c0 	movzbl 0xc011848c,%eax
+c01019aa:	83 e0 e0             	and    $0xffffffe0,%eax
+c01019ad:	a2 8c 84 11 c0       	mov    %al,0xc011848c
+c01019b2:	0f b6 05 8c 84 11 c0 	movzbl 0xc011848c,%eax
+c01019b9:	83 e0 1f             	and    $0x1f,%eax
+c01019bc:	a2 8c 84 11 c0       	mov    %al,0xc011848c
+c01019c1:	0f b6 05 8d 84 11 c0 	movzbl 0xc011848d,%eax
+c01019c8:	83 e0 f0             	and    $0xfffffff0,%eax
+c01019cb:	83 c8 0e             	or     $0xe,%eax
+c01019ce:	a2 8d 84 11 c0       	mov    %al,0xc011848d
+c01019d3:	0f b6 05 8d 84 11 c0 	movzbl 0xc011848d,%eax
+c01019da:	83 e0 ef             	and    $0xffffffef,%eax
+c01019dd:	a2 8d 84 11 c0       	mov    %al,0xc011848d
+c01019e2:	0f b6 05 8d 84 11 c0 	movzbl 0xc011848d,%eax
+c01019e9:	83 c8 60             	or     $0x60,%eax
+c01019ec:	a2 8d 84 11 c0       	mov    %al,0xc011848d
+c01019f1:	0f b6 05 8d 84 11 c0 	movzbl 0xc011848d,%eax
+c01019f8:	83 c8 80             	or     $0xffffff80,%eax
+c01019fb:	a2 8d 84 11 c0       	mov    %al,0xc011848d
+c0101a00:	a1 e4 77 11 c0       	mov    0xc01177e4,%eax
+c0101a05:	c1 e8 10             	shr    $0x10,%eax
+c0101a08:	66 a3 8e 84 11 c0    	mov    %ax,0xc011848e
+c0101a0e:	c7 45 f8 80 75 11 c0 	movl   $0xc0117580,-0x8(%ebp)
+    }
+}
+
+static inline void
+lidt(struct pseudodesc *pd) {
+    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+c0101a15:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0101a18:	0f 01 18             	lidtl  (%eax)
+	lidt(&idt_pd);
+}
+c0101a1b:	c9                   	leave  
+c0101a1c:	c3                   	ret    
+
+c0101a1d <trapname>:
+
+static const char *
+trapname(int trapno) {
+c0101a1d:	55                   	push   %ebp
+c0101a1e:	89 e5                	mov    %esp,%ebp
+        "Alignment Check",
+        "Machine-Check",
+        "SIMD Floating-Point Exception"
+    };
+
+    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+c0101a20:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101a23:	83 f8 13             	cmp    $0x13,%eax
+c0101a26:	77 0c                	ja     c0101a34 <trapname+0x17>
+        return excnames[trapno];
+c0101a28:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101a2b:	8b 04 85 40 67 10 c0 	mov    -0x3fef98c0(,%eax,4),%eax
+c0101a32:	eb 18                	jmp    c0101a4c <trapname+0x2f>
+    }
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+c0101a34:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
+c0101a38:	7e 0d                	jle    c0101a47 <trapname+0x2a>
+c0101a3a:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
+c0101a3e:	7f 07                	jg     c0101a47 <trapname+0x2a>
+        return "Hardware Interrupt";
+c0101a40:	b8 ff 63 10 c0       	mov    $0xc01063ff,%eax
+c0101a45:	eb 05                	jmp    c0101a4c <trapname+0x2f>
+    }
+    return "(unknown trap)";
+c0101a47:	b8 12 64 10 c0       	mov    $0xc0106412,%eax
+}
+c0101a4c:	5d                   	pop    %ebp
+c0101a4d:	c3                   	ret    
+
+c0101a4e <trap_in_kernel>:
+
+/* trap_in_kernel - test if trap happened in kernel */
+bool
+trap_in_kernel(struct trapframe *tf) {
+c0101a4e:	55                   	push   %ebp
+c0101a4f:	89 e5                	mov    %esp,%ebp
+    return (tf->tf_cs == (uint16_t)KERNEL_CS);
+c0101a51:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101a54:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c0101a58:	66 83 f8 08          	cmp    $0x8,%ax
+c0101a5c:	0f 94 c0             	sete   %al
+c0101a5f:	0f b6 c0             	movzbl %al,%eax
+}
+c0101a62:	5d                   	pop    %ebp
+c0101a63:	c3                   	ret    
+
+c0101a64 <print_trapframe>:
+    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
+    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+};
+
+void
+print_trapframe(struct trapframe *tf) {
+c0101a64:	55                   	push   %ebp
+c0101a65:	89 e5                	mov    %esp,%ebp
+c0101a67:	83 ec 28             	sub    $0x28,%esp
+    cprintf("trapframe at %p\n", tf);
+c0101a6a:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101a6d:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101a71:	c7 04 24 53 64 10 c0 	movl   $0xc0106453,(%esp)
+c0101a78:	e8 bf e8 ff ff       	call   c010033c <cprintf>
+    print_regs(&tf->tf_regs);
+c0101a7d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101a80:	89 04 24             	mov    %eax,(%esp)
+c0101a83:	e8 a1 01 00 00       	call   c0101c29 <print_regs>
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+c0101a88:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101a8b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
+c0101a8f:	0f b7 c0             	movzwl %ax,%eax
+c0101a92:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101a96:	c7 04 24 64 64 10 c0 	movl   $0xc0106464,(%esp)
+c0101a9d:	e8 9a e8 ff ff       	call   c010033c <cprintf>
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+c0101aa2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101aa5:	0f b7 40 28          	movzwl 0x28(%eax),%eax
+c0101aa9:	0f b7 c0             	movzwl %ax,%eax
+c0101aac:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101ab0:	c7 04 24 77 64 10 c0 	movl   $0xc0106477,(%esp)
+c0101ab7:	e8 80 e8 ff ff       	call   c010033c <cprintf>
+    cprintf("  fs   0x----%04x\n", tf->tf_fs);
+c0101abc:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101abf:	0f b7 40 24          	movzwl 0x24(%eax),%eax
+c0101ac3:	0f b7 c0             	movzwl %ax,%eax
+c0101ac6:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101aca:	c7 04 24 8a 64 10 c0 	movl   $0xc010648a,(%esp)
+c0101ad1:	e8 66 e8 ff ff       	call   c010033c <cprintf>
+    cprintf("  gs   0x----%04x\n", tf->tf_gs);
+c0101ad6:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101ad9:	0f b7 40 20          	movzwl 0x20(%eax),%eax
+c0101add:	0f b7 c0             	movzwl %ax,%eax
+c0101ae0:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101ae4:	c7 04 24 9d 64 10 c0 	movl   $0xc010649d,(%esp)
+c0101aeb:	e8 4c e8 ff ff       	call   c010033c <cprintf>
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+c0101af0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101af3:	8b 40 30             	mov    0x30(%eax),%eax
+c0101af6:	89 04 24             	mov    %eax,(%esp)
+c0101af9:	e8 1f ff ff ff       	call   c0101a1d <trapname>
+c0101afe:	8b 55 08             	mov    0x8(%ebp),%edx
+c0101b01:	8b 52 30             	mov    0x30(%edx),%edx
+c0101b04:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0101b08:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0101b0c:	c7 04 24 b0 64 10 c0 	movl   $0xc01064b0,(%esp)
+c0101b13:	e8 24 e8 ff ff       	call   c010033c <cprintf>
+    cprintf("  err  0x%08x\n", tf->tf_err);
+c0101b18:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101b1b:	8b 40 34             	mov    0x34(%eax),%eax
+c0101b1e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101b22:	c7 04 24 c2 64 10 c0 	movl   $0xc01064c2,(%esp)
+c0101b29:	e8 0e e8 ff ff       	call   c010033c <cprintf>
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+c0101b2e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101b31:	8b 40 38             	mov    0x38(%eax),%eax
+c0101b34:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101b38:	c7 04 24 d1 64 10 c0 	movl   $0xc01064d1,(%esp)
+c0101b3f:	e8 f8 e7 ff ff       	call   c010033c <cprintf>
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+c0101b44:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101b47:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c0101b4b:	0f b7 c0             	movzwl %ax,%eax
+c0101b4e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101b52:	c7 04 24 e0 64 10 c0 	movl   $0xc01064e0,(%esp)
+c0101b59:	e8 de e7 ff ff       	call   c010033c <cprintf>
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+c0101b5e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101b61:	8b 40 40             	mov    0x40(%eax),%eax
+c0101b64:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101b68:	c7 04 24 f3 64 10 c0 	movl   $0xc01064f3,(%esp)
+c0101b6f:	e8 c8 e7 ff ff       	call   c010033c <cprintf>
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+c0101b74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0101b7b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+c0101b82:	eb 3e                	jmp    c0101bc2 <print_trapframe+0x15e>
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+c0101b84:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101b87:	8b 50 40             	mov    0x40(%eax),%edx
+c0101b8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0101b8d:	21 d0                	and    %edx,%eax
+c0101b8f:	85 c0                	test   %eax,%eax
+c0101b91:	74 28                	je     c0101bbb <print_trapframe+0x157>
+c0101b93:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101b96:	8b 04 85 a0 75 11 c0 	mov    -0x3fee8a60(,%eax,4),%eax
+c0101b9d:	85 c0                	test   %eax,%eax
+c0101b9f:	74 1a                	je     c0101bbb <print_trapframe+0x157>
+            cprintf("%s,", IA32flags[i]);
+c0101ba1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101ba4:	8b 04 85 a0 75 11 c0 	mov    -0x3fee8a60(,%eax,4),%eax
+c0101bab:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101baf:	c7 04 24 02 65 10 c0 	movl   $0xc0106502,(%esp)
+c0101bb6:	e8 81 e7 ff ff       	call   c010033c <cprintf>
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+c0101bbb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c0101bbf:	d1 65 f0             	shll   -0x10(%ebp)
+c0101bc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101bc5:	83 f8 17             	cmp    $0x17,%eax
+c0101bc8:	76 ba                	jbe    c0101b84 <print_trapframe+0x120>
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+            cprintf("%s,", IA32flags[i]);
+        }
+    }
+    cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
+c0101bca:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101bcd:	8b 40 40             	mov    0x40(%eax),%eax
+c0101bd0:	25 00 30 00 00       	and    $0x3000,%eax
+c0101bd5:	c1 e8 0c             	shr    $0xc,%eax
+c0101bd8:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101bdc:	c7 04 24 06 65 10 c0 	movl   $0xc0106506,(%esp)
+c0101be3:	e8 54 e7 ff ff       	call   c010033c <cprintf>
+
+    if (!trap_in_kernel(tf)) {
+c0101be8:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101beb:	89 04 24             	mov    %eax,(%esp)
+c0101bee:	e8 5b fe ff ff       	call   c0101a4e <trap_in_kernel>
+c0101bf3:	85 c0                	test   %eax,%eax
+c0101bf5:	75 30                	jne    c0101c27 <print_trapframe+0x1c3>
+        cprintf("  esp  0x%08x\n", tf->tf_esp);
+c0101bf7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101bfa:	8b 40 44             	mov    0x44(%eax),%eax
+c0101bfd:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101c01:	c7 04 24 0f 65 10 c0 	movl   $0xc010650f,(%esp)
+c0101c08:	e8 2f e7 ff ff       	call   c010033c <cprintf>
+        cprintf("  ss   0x----%04x\n", tf->tf_ss);
+c0101c0d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101c10:	0f b7 40 48          	movzwl 0x48(%eax),%eax
+c0101c14:	0f b7 c0             	movzwl %ax,%eax
+c0101c17:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101c1b:	c7 04 24 1e 65 10 c0 	movl   $0xc010651e,(%esp)
+c0101c22:	e8 15 e7 ff ff       	call   c010033c <cprintf>
+    }
+}
+c0101c27:	c9                   	leave  
+c0101c28:	c3                   	ret    
+
+c0101c29 <print_regs>:
+
+void
+print_regs(struct pushregs *regs) {
+c0101c29:	55                   	push   %ebp
+c0101c2a:	89 e5                	mov    %esp,%ebp
+c0101c2c:	83 ec 18             	sub    $0x18,%esp
+    cprintf("  edi  0x%08x\n", regs->reg_edi);
+c0101c2f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101c32:	8b 00                	mov    (%eax),%eax
+c0101c34:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101c38:	c7 04 24 31 65 10 c0 	movl   $0xc0106531,(%esp)
+c0101c3f:	e8 f8 e6 ff ff       	call   c010033c <cprintf>
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+c0101c44:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101c47:	8b 40 04             	mov    0x4(%eax),%eax
+c0101c4a:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101c4e:	c7 04 24 40 65 10 c0 	movl   $0xc0106540,(%esp)
+c0101c55:	e8 e2 e6 ff ff       	call   c010033c <cprintf>
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+c0101c5a:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101c5d:	8b 40 08             	mov    0x8(%eax),%eax
+c0101c60:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101c64:	c7 04 24 4f 65 10 c0 	movl   $0xc010654f,(%esp)
+c0101c6b:	e8 cc e6 ff ff       	call   c010033c <cprintf>
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+c0101c70:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101c73:	8b 40 0c             	mov    0xc(%eax),%eax
+c0101c76:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101c7a:	c7 04 24 5e 65 10 c0 	movl   $0xc010655e,(%esp)
+c0101c81:	e8 b6 e6 ff ff       	call   c010033c <cprintf>
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+c0101c86:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101c89:	8b 40 10             	mov    0x10(%eax),%eax
+c0101c8c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101c90:	c7 04 24 6d 65 10 c0 	movl   $0xc010656d,(%esp)
+c0101c97:	e8 a0 e6 ff ff       	call   c010033c <cprintf>
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+c0101c9c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101c9f:	8b 40 14             	mov    0x14(%eax),%eax
+c0101ca2:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101ca6:	c7 04 24 7c 65 10 c0 	movl   $0xc010657c,(%esp)
+c0101cad:	e8 8a e6 ff ff       	call   c010033c <cprintf>
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+c0101cb2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101cb5:	8b 40 18             	mov    0x18(%eax),%eax
+c0101cb8:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101cbc:	c7 04 24 8b 65 10 c0 	movl   $0xc010658b,(%esp)
+c0101cc3:	e8 74 e6 ff ff       	call   c010033c <cprintf>
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+c0101cc8:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101ccb:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0101cce:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101cd2:	c7 04 24 9a 65 10 c0 	movl   $0xc010659a,(%esp)
+c0101cd9:	e8 5e e6 ff ff       	call   c010033c <cprintf>
+}
+c0101cde:	c9                   	leave  
+c0101cdf:	c3                   	ret    
+
+c0101ce0 <trap_dispatch>:
+
+struct trapframe switchk2u, *switchu2k;
+
+/* trap_dispatch - dispatch based on what type of trap occurred */
+static void
+trap_dispatch(struct trapframe *tf) {
+c0101ce0:	55                   	push   %ebp
+c0101ce1:	89 e5                	mov    %esp,%ebp
+c0101ce3:	57                   	push   %edi
+c0101ce4:	56                   	push   %esi
+c0101ce5:	53                   	push   %ebx
+c0101ce6:	83 ec 2c             	sub    $0x2c,%esp
+    char c;
+
+    switch (tf->tf_trapno) {
+c0101ce9:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101cec:	8b 40 30             	mov    0x30(%eax),%eax
+c0101cef:	83 f8 2f             	cmp    $0x2f,%eax
+c0101cf2:	77 21                	ja     c0101d15 <trap_dispatch+0x35>
+c0101cf4:	83 f8 2e             	cmp    $0x2e,%eax
+c0101cf7:	0f 83 ec 01 00 00    	jae    c0101ee9 <trap_dispatch+0x209>
+c0101cfd:	83 f8 21             	cmp    $0x21,%eax
+c0101d00:	0f 84 8a 00 00 00    	je     c0101d90 <trap_dispatch+0xb0>
+c0101d06:	83 f8 24             	cmp    $0x24,%eax
+c0101d09:	74 5c                	je     c0101d67 <trap_dispatch+0x87>
+c0101d0b:	83 f8 20             	cmp    $0x20,%eax
+c0101d0e:	74 1c                	je     c0101d2c <trap_dispatch+0x4c>
+c0101d10:	e9 9c 01 00 00       	jmp    c0101eb1 <trap_dispatch+0x1d1>
+c0101d15:	83 f8 78             	cmp    $0x78,%eax
+c0101d18:	0f 84 9b 00 00 00    	je     c0101db9 <trap_dispatch+0xd9>
+c0101d1e:	83 f8 79             	cmp    $0x79,%eax
+c0101d21:	0f 84 11 01 00 00    	je     c0101e38 <trap_dispatch+0x158>
+c0101d27:	e9 85 01 00 00       	jmp    c0101eb1 <trap_dispatch+0x1d1>
+        /* handle the timer interrupt */
+        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+	ticks++;
+c0101d2c:	a1 4c 89 11 c0       	mov    0xc011894c,%eax
+c0101d31:	83 c0 01             	add    $0x1,%eax
+c0101d34:	a3 4c 89 11 c0       	mov    %eax,0xc011894c
+	if(ticks%TICK_NUM==0){
+c0101d39:	8b 0d 4c 89 11 c0    	mov    0xc011894c,%ecx
+c0101d3f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+c0101d44:	89 c8                	mov    %ecx,%eax
+c0101d46:	f7 e2                	mul    %edx
+c0101d48:	89 d0                	mov    %edx,%eax
+c0101d4a:	c1 e8 05             	shr    $0x5,%eax
+c0101d4d:	6b c0 64             	imul   $0x64,%eax,%eax
+c0101d50:	29 c1                	sub    %eax,%ecx
+c0101d52:	89 c8                	mov    %ecx,%eax
+c0101d54:	85 c0                	test   %eax,%eax
+c0101d56:	75 0a                	jne    c0101d62 <trap_dispatch+0x82>
+		print_ticks();	
+c0101d58:	e8 0d fb ff ff       	call   c010186a <print_ticks>
+	}
+        break;
+c0101d5d:	e9 88 01 00 00       	jmp    c0101eea <trap_dispatch+0x20a>
+c0101d62:	e9 83 01 00 00       	jmp    c0101eea <trap_dispatch+0x20a>
+    case IRQ_OFFSET + IRQ_COM1:
+        c = cons_getc();
+c0101d67:	e8 c2 f8 ff ff       	call   c010162e <cons_getc>
+c0101d6c:	88 45 e7             	mov    %al,-0x19(%ebp)
+        cprintf("serial [%03d] %c\n", c, c);
+c0101d6f:	0f be 55 e7          	movsbl -0x19(%ebp),%edx
+c0101d73:	0f be 45 e7          	movsbl -0x19(%ebp),%eax
+c0101d77:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0101d7b:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101d7f:	c7 04 24 a9 65 10 c0 	movl   $0xc01065a9,(%esp)
+c0101d86:	e8 b1 e5 ff ff       	call   c010033c <cprintf>
+        break;
+c0101d8b:	e9 5a 01 00 00       	jmp    c0101eea <trap_dispatch+0x20a>
+    case IRQ_OFFSET + IRQ_KBD:
+        c = cons_getc();
+c0101d90:	e8 99 f8 ff ff       	call   c010162e <cons_getc>
+c0101d95:	88 45 e7             	mov    %al,-0x19(%ebp)
+        cprintf("kbd [%03d] %c\n", c, c);
+c0101d98:	0f be 55 e7          	movsbl -0x19(%ebp),%edx
+c0101d9c:	0f be 45 e7          	movsbl -0x19(%ebp),%eax
+c0101da0:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0101da4:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101da8:	c7 04 24 bb 65 10 c0 	movl   $0xc01065bb,(%esp)
+c0101daf:	e8 88 e5 ff ff       	call   c010033c <cprintf>
+	break;
+c0101db4:	e9 31 01 00 00       	jmp    c0101eea <trap_dispatch+0x20a>
+    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    case T_SWITCH_TOU:
+	if (tf->tf_cs != USER_CS) {
+c0101db9:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101dbc:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c0101dc0:	66 83 f8 1b          	cmp    $0x1b,%ax
+c0101dc4:	74 6d                	je     c0101e33 <trap_dispatch+0x153>
+	        switchk2u = *tf;
+c0101dc6:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101dc9:	ba 60 89 11 c0       	mov    $0xc0118960,%edx
+c0101dce:	89 c3                	mov    %eax,%ebx
+c0101dd0:	b8 13 00 00 00       	mov    $0x13,%eax
+c0101dd5:	89 d7                	mov    %edx,%edi
+c0101dd7:	89 de                	mov    %ebx,%esi
+c0101dd9:	89 c1                	mov    %eax,%ecx
+c0101ddb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+	        switchk2u.tf_cs = USER_CS;
+c0101ddd:	66 c7 05 9c 89 11 c0 	movw   $0x1b,0xc011899c
+c0101de4:	1b 00 
+	        switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;
+c0101de6:	66 c7 05 a8 89 11 c0 	movw   $0x23,0xc01189a8
+c0101ded:	23 00 
+c0101def:	0f b7 05 a8 89 11 c0 	movzwl 0xc01189a8,%eax
+c0101df6:	66 a3 88 89 11 c0    	mov    %ax,0xc0118988
+c0101dfc:	0f b7 05 88 89 11 c0 	movzwl 0xc0118988,%eax
+c0101e03:	66 a3 8c 89 11 c0    	mov    %ax,0xc011898c
+	        switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8;
+c0101e09:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e0c:	83 c0 44             	add    $0x44,%eax
+c0101e0f:	a3 a4 89 11 c0       	mov    %eax,0xc01189a4
+		switchk2u.tf_eflags |= FL_IOPL_MASK;
+c0101e14:	a1 a0 89 11 c0       	mov    0xc01189a0,%eax
+c0101e19:	80 cc 30             	or     $0x30,%ah
+c0101e1c:	a3 a0 89 11 c0       	mov    %eax,0xc01189a0
+		*((uint32_t *)tf - 1) = (uint32_t)&switchk2u;
+c0101e21:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e24:	8d 50 fc             	lea    -0x4(%eax),%edx
+c0101e27:	b8 60 89 11 c0       	mov    $0xc0118960,%eax
+c0101e2c:	89 02                	mov    %eax,(%edx)
+	}
+	break;
+c0101e2e:	e9 b7 00 00 00       	jmp    c0101eea <trap_dispatch+0x20a>
+c0101e33:	e9 b2 00 00 00       	jmp    c0101eea <trap_dispatch+0x20a>
+    case T_SWITCH_TOK:
+        if (tf->tf_cs != KERNEL_CS) {
+c0101e38:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e3b:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c0101e3f:	66 83 f8 08          	cmp    $0x8,%ax
+c0101e43:	74 6a                	je     c0101eaf <trap_dispatch+0x1cf>
+            tf->tf_cs = KERNEL_CS;
+c0101e45:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e48:	66 c7 40 3c 08 00    	movw   $0x8,0x3c(%eax)
+            tf->tf_ds = tf->tf_es = KERNEL_DS;
+c0101e4e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e51:	66 c7 40 28 10 00    	movw   $0x10,0x28(%eax)
+c0101e57:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e5a:	0f b7 50 28          	movzwl 0x28(%eax),%edx
+c0101e5e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e61:	66 89 50 2c          	mov    %dx,0x2c(%eax)
+            tf->tf_eflags &= ~FL_IOPL_MASK;
+c0101e65:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e68:	8b 40 40             	mov    0x40(%eax),%eax
+c0101e6b:	80 e4 cf             	and    $0xcf,%ah
+c0101e6e:	89 c2                	mov    %eax,%edx
+c0101e70:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e73:	89 50 40             	mov    %edx,0x40(%eax)
+            switchu2k = (struct trapframe *)(tf->tf_esp - (sizeof(struct trapframe) - 8));
+c0101e76:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e79:	8b 40 44             	mov    0x44(%eax),%eax
+c0101e7c:	83 e8 44             	sub    $0x44,%eax
+c0101e7f:	a3 ac 89 11 c0       	mov    %eax,0xc01189ac
+            memmove(switchu2k, tf, sizeof(struct trapframe) - 8);
+c0101e84:	a1 ac 89 11 c0       	mov    0xc01189ac,%eax
+c0101e89:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
+c0101e90:	00 
+c0101e91:	8b 55 08             	mov    0x8(%ebp),%edx
+c0101e94:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0101e98:	89 04 24             	mov    %eax,(%esp)
+c0101e9b:	e8 65 40 00 00       	call   c0105f05 <memmove>
+            *((uint32_t *)tf - 1) = (uint32_t)switchu2k;
+c0101ea0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101ea3:	8d 50 fc             	lea    -0x4(%eax),%edx
+c0101ea6:	a1 ac 89 11 c0       	mov    0xc01189ac,%eax
+c0101eab:	89 02                	mov    %eax,(%edx)
+        }
+        break;
+c0101ead:	eb 3b                	jmp    c0101eea <trap_dispatch+0x20a>
+c0101eaf:	eb 39                	jmp    c0101eea <trap_dispatch+0x20a>
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+    default:
+        // in kernel, it must be a mistake
+        if ((tf->tf_cs & 3) == 0) {
+c0101eb1:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101eb4:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c0101eb8:	0f b7 c0             	movzwl %ax,%eax
+c0101ebb:	83 e0 03             	and    $0x3,%eax
+c0101ebe:	85 c0                	test   %eax,%eax
+c0101ec0:	75 28                	jne    c0101eea <trap_dispatch+0x20a>
+            print_trapframe(tf);
+c0101ec2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101ec5:	89 04 24             	mov    %eax,(%esp)
+c0101ec8:	e8 97 fb ff ff       	call   c0101a64 <print_trapframe>
+            panic("unexpected trap in kernel.\n");
+c0101ecd:	c7 44 24 08 ca 65 10 	movl   $0xc01065ca,0x8(%esp)
+c0101ed4:	c0 
+c0101ed5:	c7 44 24 04 cb 00 00 	movl   $0xcb,0x4(%esp)
+c0101edc:	00 
+c0101edd:	c7 04 24 ee 63 10 c0 	movl   $0xc01063ee,(%esp)
+c0101ee4:	e8 d7 ed ff ff       	call   c0100cc0 <__panic>
+        break;
+
+    case IRQ_OFFSET + IRQ_IDE1:
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+c0101ee9:	90                   	nop
+        if ((tf->tf_cs & 3) == 0) {
+            print_trapframe(tf);
+            panic("unexpected trap in kernel.\n");
+        }
+    }
+}
+c0101eea:	83 c4 2c             	add    $0x2c,%esp
+c0101eed:	5b                   	pop    %ebx
+c0101eee:	5e                   	pop    %esi
+c0101eef:	5f                   	pop    %edi
+c0101ef0:	5d                   	pop    %ebp
+c0101ef1:	c3                   	ret    
+
+c0101ef2 <trap>:
+ * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
+ * the code in kern/trap/trapentry.S restores the old CPU state saved in the
+ * trapframe and then uses the iret instruction to return from the exception.
+ * */
+void
+trap(struct trapframe *tf) {
+c0101ef2:	55                   	push   %ebp
+c0101ef3:	89 e5                	mov    %esp,%ebp
+c0101ef5:	83 ec 18             	sub    $0x18,%esp
+    // dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+c0101ef8:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101efb:	89 04 24             	mov    %eax,(%esp)
+c0101efe:	e8 dd fd ff ff       	call   c0101ce0 <trap_dispatch>
+}
+c0101f03:	c9                   	leave  
+c0101f04:	c3                   	ret    
+
+c0101f05 <__alltraps>:
+.text
+.globl __alltraps
+__alltraps:
+    # push registers to build a trap frame
+    # therefore make the stack look like a struct trapframe
+    pushl %ds
+c0101f05:	1e                   	push   %ds
+    pushl %es
+c0101f06:	06                   	push   %es
+    pushl %fs
+c0101f07:	0f a0                	push   %fs
+    pushl %gs
+c0101f09:	0f a8                	push   %gs
+    pushal
+c0101f0b:	60                   	pusha  
+
+    # load GD_KDATA into %ds and %es to set up data segments for kernel
+    movl $GD_KDATA, %eax
+c0101f0c:	b8 10 00 00 00       	mov    $0x10,%eax
+    movw %ax, %ds
+c0101f11:	8e d8                	mov    %eax,%ds
+    movw %ax, %es
+c0101f13:	8e c0                	mov    %eax,%es
+
+    # push %esp to pass a pointer to the trapframe as an argument to trap()
+    pushl %esp
+c0101f15:	54                   	push   %esp
+
+    # call trap(tf), where tf=%esp
+    call trap
+c0101f16:	e8 d7 ff ff ff       	call   c0101ef2 <trap>
+
+    # pop the pushed stack pointer
+    popl %esp
+c0101f1b:	5c                   	pop    %esp
+
+c0101f1c <__trapret>:
+
+    # return falls through to trapret...
+.globl __trapret
+__trapret:
+    # restore registers from stack
+    popal
+c0101f1c:	61                   	popa   
+
+    # restore %ds, %es, %fs and %gs
+    popl %gs
+c0101f1d:	0f a9                	pop    %gs
+    popl %fs
+c0101f1f:	0f a1                	pop    %fs
+    popl %es
+c0101f21:	07                   	pop    %es
+    popl %ds
+c0101f22:	1f                   	pop    %ds
+
+    # get rid of the trap number and error code
+    addl $0x8, %esp
+c0101f23:	83 c4 08             	add    $0x8,%esp
+    iret
+c0101f26:	cf                   	iret   
+
+c0101f27 <vector0>:
+# handler
+.text
+.globl __alltraps
+.globl vector0
+vector0:
+  pushl $0
+c0101f27:	6a 00                	push   $0x0
+  pushl $0
+c0101f29:	6a 00                	push   $0x0
+  jmp __alltraps
+c0101f2b:	e9 d5 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f30 <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+c0101f30:	6a 00                	push   $0x0
+  pushl $1
+c0101f32:	6a 01                	push   $0x1
+  jmp __alltraps
+c0101f34:	e9 cc ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f39 <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+c0101f39:	6a 00                	push   $0x0
+  pushl $2
+c0101f3b:	6a 02                	push   $0x2
+  jmp __alltraps
+c0101f3d:	e9 c3 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f42 <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+c0101f42:	6a 00                	push   $0x0
+  pushl $3
+c0101f44:	6a 03                	push   $0x3
+  jmp __alltraps
+c0101f46:	e9 ba ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f4b <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+c0101f4b:	6a 00                	push   $0x0
+  pushl $4
+c0101f4d:	6a 04                	push   $0x4
+  jmp __alltraps
+c0101f4f:	e9 b1 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f54 <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+c0101f54:	6a 00                	push   $0x0
+  pushl $5
+c0101f56:	6a 05                	push   $0x5
+  jmp __alltraps
+c0101f58:	e9 a8 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f5d <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+c0101f5d:	6a 00                	push   $0x0
+  pushl $6
+c0101f5f:	6a 06                	push   $0x6
+  jmp __alltraps
+c0101f61:	e9 9f ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f66 <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+c0101f66:	6a 00                	push   $0x0
+  pushl $7
+c0101f68:	6a 07                	push   $0x7
+  jmp __alltraps
+c0101f6a:	e9 96 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f6f <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+c0101f6f:	6a 08                	push   $0x8
+  jmp __alltraps
+c0101f71:	e9 8f ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f76 <vector9>:
+.globl vector9
+vector9:
+  pushl $9
+c0101f76:	6a 09                	push   $0x9
+  jmp __alltraps
+c0101f78:	e9 88 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f7d <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+c0101f7d:	6a 0a                	push   $0xa
+  jmp __alltraps
+c0101f7f:	e9 81 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f84 <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+c0101f84:	6a 0b                	push   $0xb
+  jmp __alltraps
+c0101f86:	e9 7a ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f8b <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+c0101f8b:	6a 0c                	push   $0xc
+  jmp __alltraps
+c0101f8d:	e9 73 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f92 <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+c0101f92:	6a 0d                	push   $0xd
+  jmp __alltraps
+c0101f94:	e9 6c ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101f99 <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+c0101f99:	6a 0e                	push   $0xe
+  jmp __alltraps
+c0101f9b:	e9 65 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fa0 <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+c0101fa0:	6a 00                	push   $0x0
+  pushl $15
+c0101fa2:	6a 0f                	push   $0xf
+  jmp __alltraps
+c0101fa4:	e9 5c ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fa9 <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+c0101fa9:	6a 00                	push   $0x0
+  pushl $16
+c0101fab:	6a 10                	push   $0x10
+  jmp __alltraps
+c0101fad:	e9 53 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fb2 <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+c0101fb2:	6a 11                	push   $0x11
+  jmp __alltraps
+c0101fb4:	e9 4c ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fb9 <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+c0101fb9:	6a 00                	push   $0x0
+  pushl $18
+c0101fbb:	6a 12                	push   $0x12
+  jmp __alltraps
+c0101fbd:	e9 43 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fc2 <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+c0101fc2:	6a 00                	push   $0x0
+  pushl $19
+c0101fc4:	6a 13                	push   $0x13
+  jmp __alltraps
+c0101fc6:	e9 3a ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fcb <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+c0101fcb:	6a 00                	push   $0x0
+  pushl $20
+c0101fcd:	6a 14                	push   $0x14
+  jmp __alltraps
+c0101fcf:	e9 31 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fd4 <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+c0101fd4:	6a 00                	push   $0x0
+  pushl $21
+c0101fd6:	6a 15                	push   $0x15
+  jmp __alltraps
+c0101fd8:	e9 28 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fdd <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+c0101fdd:	6a 00                	push   $0x0
+  pushl $22
+c0101fdf:	6a 16                	push   $0x16
+  jmp __alltraps
+c0101fe1:	e9 1f ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fe6 <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+c0101fe6:	6a 00                	push   $0x0
+  pushl $23
+c0101fe8:	6a 17                	push   $0x17
+  jmp __alltraps
+c0101fea:	e9 16 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101fef <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+c0101fef:	6a 00                	push   $0x0
+  pushl $24
+c0101ff1:	6a 18                	push   $0x18
+  jmp __alltraps
+c0101ff3:	e9 0d ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0101ff8 <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+c0101ff8:	6a 00                	push   $0x0
+  pushl $25
+c0101ffa:	6a 19                	push   $0x19
+  jmp __alltraps
+c0101ffc:	e9 04 ff ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102001 <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+c0102001:	6a 00                	push   $0x0
+  pushl $26
+c0102003:	6a 1a                	push   $0x1a
+  jmp __alltraps
+c0102005:	e9 fb fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c010200a <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+c010200a:	6a 00                	push   $0x0
+  pushl $27
+c010200c:	6a 1b                	push   $0x1b
+  jmp __alltraps
+c010200e:	e9 f2 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102013 <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+c0102013:	6a 00                	push   $0x0
+  pushl $28
+c0102015:	6a 1c                	push   $0x1c
+  jmp __alltraps
+c0102017:	e9 e9 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c010201c <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+c010201c:	6a 00                	push   $0x0
+  pushl $29
+c010201e:	6a 1d                	push   $0x1d
+  jmp __alltraps
+c0102020:	e9 e0 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102025 <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+c0102025:	6a 00                	push   $0x0
+  pushl $30
+c0102027:	6a 1e                	push   $0x1e
+  jmp __alltraps
+c0102029:	e9 d7 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c010202e <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+c010202e:	6a 00                	push   $0x0
+  pushl $31
+c0102030:	6a 1f                	push   $0x1f
+  jmp __alltraps
+c0102032:	e9 ce fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102037 <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+c0102037:	6a 00                	push   $0x0
+  pushl $32
+c0102039:	6a 20                	push   $0x20
+  jmp __alltraps
+c010203b:	e9 c5 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102040 <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+c0102040:	6a 00                	push   $0x0
+  pushl $33
+c0102042:	6a 21                	push   $0x21
+  jmp __alltraps
+c0102044:	e9 bc fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102049 <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+c0102049:	6a 00                	push   $0x0
+  pushl $34
+c010204b:	6a 22                	push   $0x22
+  jmp __alltraps
+c010204d:	e9 b3 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102052 <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+c0102052:	6a 00                	push   $0x0
+  pushl $35
+c0102054:	6a 23                	push   $0x23
+  jmp __alltraps
+c0102056:	e9 aa fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c010205b <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+c010205b:	6a 00                	push   $0x0
+  pushl $36
+c010205d:	6a 24                	push   $0x24
+  jmp __alltraps
+c010205f:	e9 a1 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102064 <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+c0102064:	6a 00                	push   $0x0
+  pushl $37
+c0102066:	6a 25                	push   $0x25
+  jmp __alltraps
+c0102068:	e9 98 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c010206d <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+c010206d:	6a 00                	push   $0x0
+  pushl $38
+c010206f:	6a 26                	push   $0x26
+  jmp __alltraps
+c0102071:	e9 8f fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102076 <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+c0102076:	6a 00                	push   $0x0
+  pushl $39
+c0102078:	6a 27                	push   $0x27
+  jmp __alltraps
+c010207a:	e9 86 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c010207f <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+c010207f:	6a 00                	push   $0x0
+  pushl $40
+c0102081:	6a 28                	push   $0x28
+  jmp __alltraps
+c0102083:	e9 7d fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102088 <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+c0102088:	6a 00                	push   $0x0
+  pushl $41
+c010208a:	6a 29                	push   $0x29
+  jmp __alltraps
+c010208c:	e9 74 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102091 <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+c0102091:	6a 00                	push   $0x0
+  pushl $42
+c0102093:	6a 2a                	push   $0x2a
+  jmp __alltraps
+c0102095:	e9 6b fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c010209a <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+c010209a:	6a 00                	push   $0x0
+  pushl $43
+c010209c:	6a 2b                	push   $0x2b
+  jmp __alltraps
+c010209e:	e9 62 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020a3 <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+c01020a3:	6a 00                	push   $0x0
+  pushl $44
+c01020a5:	6a 2c                	push   $0x2c
+  jmp __alltraps
+c01020a7:	e9 59 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020ac <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+c01020ac:	6a 00                	push   $0x0
+  pushl $45
+c01020ae:	6a 2d                	push   $0x2d
+  jmp __alltraps
+c01020b0:	e9 50 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020b5 <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+c01020b5:	6a 00                	push   $0x0
+  pushl $46
+c01020b7:	6a 2e                	push   $0x2e
+  jmp __alltraps
+c01020b9:	e9 47 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020be <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+c01020be:	6a 00                	push   $0x0
+  pushl $47
+c01020c0:	6a 2f                	push   $0x2f
+  jmp __alltraps
+c01020c2:	e9 3e fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020c7 <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+c01020c7:	6a 00                	push   $0x0
+  pushl $48
+c01020c9:	6a 30                	push   $0x30
+  jmp __alltraps
+c01020cb:	e9 35 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020d0 <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+c01020d0:	6a 00                	push   $0x0
+  pushl $49
+c01020d2:	6a 31                	push   $0x31
+  jmp __alltraps
+c01020d4:	e9 2c fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020d9 <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+c01020d9:	6a 00                	push   $0x0
+  pushl $50
+c01020db:	6a 32                	push   $0x32
+  jmp __alltraps
+c01020dd:	e9 23 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020e2 <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+c01020e2:	6a 00                	push   $0x0
+  pushl $51
+c01020e4:	6a 33                	push   $0x33
+  jmp __alltraps
+c01020e6:	e9 1a fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020eb <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+c01020eb:	6a 00                	push   $0x0
+  pushl $52
+c01020ed:	6a 34                	push   $0x34
+  jmp __alltraps
+c01020ef:	e9 11 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020f4 <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+c01020f4:	6a 00                	push   $0x0
+  pushl $53
+c01020f6:	6a 35                	push   $0x35
+  jmp __alltraps
+c01020f8:	e9 08 fe ff ff       	jmp    c0101f05 <__alltraps>
+
+c01020fd <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+c01020fd:	6a 00                	push   $0x0
+  pushl $54
+c01020ff:	6a 36                	push   $0x36
+  jmp __alltraps
+c0102101:	e9 ff fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102106 <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+c0102106:	6a 00                	push   $0x0
+  pushl $55
+c0102108:	6a 37                	push   $0x37
+  jmp __alltraps
+c010210a:	e9 f6 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c010210f <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+c010210f:	6a 00                	push   $0x0
+  pushl $56
+c0102111:	6a 38                	push   $0x38
+  jmp __alltraps
+c0102113:	e9 ed fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102118 <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+c0102118:	6a 00                	push   $0x0
+  pushl $57
+c010211a:	6a 39                	push   $0x39
+  jmp __alltraps
+c010211c:	e9 e4 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102121 <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+c0102121:	6a 00                	push   $0x0
+  pushl $58
+c0102123:	6a 3a                	push   $0x3a
+  jmp __alltraps
+c0102125:	e9 db fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c010212a <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+c010212a:	6a 00                	push   $0x0
+  pushl $59
+c010212c:	6a 3b                	push   $0x3b
+  jmp __alltraps
+c010212e:	e9 d2 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102133 <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+c0102133:	6a 00                	push   $0x0
+  pushl $60
+c0102135:	6a 3c                	push   $0x3c
+  jmp __alltraps
+c0102137:	e9 c9 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c010213c <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+c010213c:	6a 00                	push   $0x0
+  pushl $61
+c010213e:	6a 3d                	push   $0x3d
+  jmp __alltraps
+c0102140:	e9 c0 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102145 <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+c0102145:	6a 00                	push   $0x0
+  pushl $62
+c0102147:	6a 3e                	push   $0x3e
+  jmp __alltraps
+c0102149:	e9 b7 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c010214e <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+c010214e:	6a 00                	push   $0x0
+  pushl $63
+c0102150:	6a 3f                	push   $0x3f
+  jmp __alltraps
+c0102152:	e9 ae fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102157 <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+c0102157:	6a 00                	push   $0x0
+  pushl $64
+c0102159:	6a 40                	push   $0x40
+  jmp __alltraps
+c010215b:	e9 a5 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102160 <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+c0102160:	6a 00                	push   $0x0
+  pushl $65
+c0102162:	6a 41                	push   $0x41
+  jmp __alltraps
+c0102164:	e9 9c fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102169 <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+c0102169:	6a 00                	push   $0x0
+  pushl $66
+c010216b:	6a 42                	push   $0x42
+  jmp __alltraps
+c010216d:	e9 93 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102172 <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+c0102172:	6a 00                	push   $0x0
+  pushl $67
+c0102174:	6a 43                	push   $0x43
+  jmp __alltraps
+c0102176:	e9 8a fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c010217b <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+c010217b:	6a 00                	push   $0x0
+  pushl $68
+c010217d:	6a 44                	push   $0x44
+  jmp __alltraps
+c010217f:	e9 81 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102184 <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+c0102184:	6a 00                	push   $0x0
+  pushl $69
+c0102186:	6a 45                	push   $0x45
+  jmp __alltraps
+c0102188:	e9 78 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c010218d <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+c010218d:	6a 00                	push   $0x0
+  pushl $70
+c010218f:	6a 46                	push   $0x46
+  jmp __alltraps
+c0102191:	e9 6f fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102196 <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+c0102196:	6a 00                	push   $0x0
+  pushl $71
+c0102198:	6a 47                	push   $0x47
+  jmp __alltraps
+c010219a:	e9 66 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c010219f <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+c010219f:	6a 00                	push   $0x0
+  pushl $72
+c01021a1:	6a 48                	push   $0x48
+  jmp __alltraps
+c01021a3:	e9 5d fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021a8 <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+c01021a8:	6a 00                	push   $0x0
+  pushl $73
+c01021aa:	6a 49                	push   $0x49
+  jmp __alltraps
+c01021ac:	e9 54 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021b1 <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+c01021b1:	6a 00                	push   $0x0
+  pushl $74
+c01021b3:	6a 4a                	push   $0x4a
+  jmp __alltraps
+c01021b5:	e9 4b fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021ba <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+c01021ba:	6a 00                	push   $0x0
+  pushl $75
+c01021bc:	6a 4b                	push   $0x4b
+  jmp __alltraps
+c01021be:	e9 42 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021c3 <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+c01021c3:	6a 00                	push   $0x0
+  pushl $76
+c01021c5:	6a 4c                	push   $0x4c
+  jmp __alltraps
+c01021c7:	e9 39 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021cc <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+c01021cc:	6a 00                	push   $0x0
+  pushl $77
+c01021ce:	6a 4d                	push   $0x4d
+  jmp __alltraps
+c01021d0:	e9 30 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021d5 <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+c01021d5:	6a 00                	push   $0x0
+  pushl $78
+c01021d7:	6a 4e                	push   $0x4e
+  jmp __alltraps
+c01021d9:	e9 27 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021de <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+c01021de:	6a 00                	push   $0x0
+  pushl $79
+c01021e0:	6a 4f                	push   $0x4f
+  jmp __alltraps
+c01021e2:	e9 1e fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021e7 <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+c01021e7:	6a 00                	push   $0x0
+  pushl $80
+c01021e9:	6a 50                	push   $0x50
+  jmp __alltraps
+c01021eb:	e9 15 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021f0 <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+c01021f0:	6a 00                	push   $0x0
+  pushl $81
+c01021f2:	6a 51                	push   $0x51
+  jmp __alltraps
+c01021f4:	e9 0c fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c01021f9 <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+c01021f9:	6a 00                	push   $0x0
+  pushl $82
+c01021fb:	6a 52                	push   $0x52
+  jmp __alltraps
+c01021fd:	e9 03 fd ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102202 <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+c0102202:	6a 00                	push   $0x0
+  pushl $83
+c0102204:	6a 53                	push   $0x53
+  jmp __alltraps
+c0102206:	e9 fa fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c010220b <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+c010220b:	6a 00                	push   $0x0
+  pushl $84
+c010220d:	6a 54                	push   $0x54
+  jmp __alltraps
+c010220f:	e9 f1 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102214 <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+c0102214:	6a 00                	push   $0x0
+  pushl $85
+c0102216:	6a 55                	push   $0x55
+  jmp __alltraps
+c0102218:	e9 e8 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c010221d <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+c010221d:	6a 00                	push   $0x0
+  pushl $86
+c010221f:	6a 56                	push   $0x56
+  jmp __alltraps
+c0102221:	e9 df fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102226 <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+c0102226:	6a 00                	push   $0x0
+  pushl $87
+c0102228:	6a 57                	push   $0x57
+  jmp __alltraps
+c010222a:	e9 d6 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c010222f <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+c010222f:	6a 00                	push   $0x0
+  pushl $88
+c0102231:	6a 58                	push   $0x58
+  jmp __alltraps
+c0102233:	e9 cd fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102238 <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+c0102238:	6a 00                	push   $0x0
+  pushl $89
+c010223a:	6a 59                	push   $0x59
+  jmp __alltraps
+c010223c:	e9 c4 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102241 <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+c0102241:	6a 00                	push   $0x0
+  pushl $90
+c0102243:	6a 5a                	push   $0x5a
+  jmp __alltraps
+c0102245:	e9 bb fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c010224a <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+c010224a:	6a 00                	push   $0x0
+  pushl $91
+c010224c:	6a 5b                	push   $0x5b
+  jmp __alltraps
+c010224e:	e9 b2 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102253 <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+c0102253:	6a 00                	push   $0x0
+  pushl $92
+c0102255:	6a 5c                	push   $0x5c
+  jmp __alltraps
+c0102257:	e9 a9 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c010225c <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+c010225c:	6a 00                	push   $0x0
+  pushl $93
+c010225e:	6a 5d                	push   $0x5d
+  jmp __alltraps
+c0102260:	e9 a0 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102265 <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+c0102265:	6a 00                	push   $0x0
+  pushl $94
+c0102267:	6a 5e                	push   $0x5e
+  jmp __alltraps
+c0102269:	e9 97 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c010226e <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+c010226e:	6a 00                	push   $0x0
+  pushl $95
+c0102270:	6a 5f                	push   $0x5f
+  jmp __alltraps
+c0102272:	e9 8e fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102277 <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+c0102277:	6a 00                	push   $0x0
+  pushl $96
+c0102279:	6a 60                	push   $0x60
+  jmp __alltraps
+c010227b:	e9 85 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102280 <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+c0102280:	6a 00                	push   $0x0
+  pushl $97
+c0102282:	6a 61                	push   $0x61
+  jmp __alltraps
+c0102284:	e9 7c fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102289 <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+c0102289:	6a 00                	push   $0x0
+  pushl $98
+c010228b:	6a 62                	push   $0x62
+  jmp __alltraps
+c010228d:	e9 73 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102292 <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+c0102292:	6a 00                	push   $0x0
+  pushl $99
+c0102294:	6a 63                	push   $0x63
+  jmp __alltraps
+c0102296:	e9 6a fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c010229b <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+c010229b:	6a 00                	push   $0x0
+  pushl $100
+c010229d:	6a 64                	push   $0x64
+  jmp __alltraps
+c010229f:	e9 61 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022a4 <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+c01022a4:	6a 00                	push   $0x0
+  pushl $101
+c01022a6:	6a 65                	push   $0x65
+  jmp __alltraps
+c01022a8:	e9 58 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022ad <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+c01022ad:	6a 00                	push   $0x0
+  pushl $102
+c01022af:	6a 66                	push   $0x66
+  jmp __alltraps
+c01022b1:	e9 4f fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022b6 <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+c01022b6:	6a 00                	push   $0x0
+  pushl $103
+c01022b8:	6a 67                	push   $0x67
+  jmp __alltraps
+c01022ba:	e9 46 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022bf <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+c01022bf:	6a 00                	push   $0x0
+  pushl $104
+c01022c1:	6a 68                	push   $0x68
+  jmp __alltraps
+c01022c3:	e9 3d fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022c8 <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+c01022c8:	6a 00                	push   $0x0
+  pushl $105
+c01022ca:	6a 69                	push   $0x69
+  jmp __alltraps
+c01022cc:	e9 34 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022d1 <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+c01022d1:	6a 00                	push   $0x0
+  pushl $106
+c01022d3:	6a 6a                	push   $0x6a
+  jmp __alltraps
+c01022d5:	e9 2b fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022da <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+c01022da:	6a 00                	push   $0x0
+  pushl $107
+c01022dc:	6a 6b                	push   $0x6b
+  jmp __alltraps
+c01022de:	e9 22 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022e3 <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+c01022e3:	6a 00                	push   $0x0
+  pushl $108
+c01022e5:	6a 6c                	push   $0x6c
+  jmp __alltraps
+c01022e7:	e9 19 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022ec <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+c01022ec:	6a 00                	push   $0x0
+  pushl $109
+c01022ee:	6a 6d                	push   $0x6d
+  jmp __alltraps
+c01022f0:	e9 10 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022f5 <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+c01022f5:	6a 00                	push   $0x0
+  pushl $110
+c01022f7:	6a 6e                	push   $0x6e
+  jmp __alltraps
+c01022f9:	e9 07 fc ff ff       	jmp    c0101f05 <__alltraps>
+
+c01022fe <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+c01022fe:	6a 00                	push   $0x0
+  pushl $111
+c0102300:	6a 6f                	push   $0x6f
+  jmp __alltraps
+c0102302:	e9 fe fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102307 <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+c0102307:	6a 00                	push   $0x0
+  pushl $112
+c0102309:	6a 70                	push   $0x70
+  jmp __alltraps
+c010230b:	e9 f5 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102310 <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+c0102310:	6a 00                	push   $0x0
+  pushl $113
+c0102312:	6a 71                	push   $0x71
+  jmp __alltraps
+c0102314:	e9 ec fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102319 <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+c0102319:	6a 00                	push   $0x0
+  pushl $114
+c010231b:	6a 72                	push   $0x72
+  jmp __alltraps
+c010231d:	e9 e3 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102322 <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+c0102322:	6a 00                	push   $0x0
+  pushl $115
+c0102324:	6a 73                	push   $0x73
+  jmp __alltraps
+c0102326:	e9 da fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c010232b <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+c010232b:	6a 00                	push   $0x0
+  pushl $116
+c010232d:	6a 74                	push   $0x74
+  jmp __alltraps
+c010232f:	e9 d1 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102334 <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+c0102334:	6a 00                	push   $0x0
+  pushl $117
+c0102336:	6a 75                	push   $0x75
+  jmp __alltraps
+c0102338:	e9 c8 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c010233d <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+c010233d:	6a 00                	push   $0x0
+  pushl $118
+c010233f:	6a 76                	push   $0x76
+  jmp __alltraps
+c0102341:	e9 bf fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102346 <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+c0102346:	6a 00                	push   $0x0
+  pushl $119
+c0102348:	6a 77                	push   $0x77
+  jmp __alltraps
+c010234a:	e9 b6 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c010234f <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+c010234f:	6a 00                	push   $0x0
+  pushl $120
+c0102351:	6a 78                	push   $0x78
+  jmp __alltraps
+c0102353:	e9 ad fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102358 <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+c0102358:	6a 00                	push   $0x0
+  pushl $121
+c010235a:	6a 79                	push   $0x79
+  jmp __alltraps
+c010235c:	e9 a4 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102361 <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+c0102361:	6a 00                	push   $0x0
+  pushl $122
+c0102363:	6a 7a                	push   $0x7a
+  jmp __alltraps
+c0102365:	e9 9b fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c010236a <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+c010236a:	6a 00                	push   $0x0
+  pushl $123
+c010236c:	6a 7b                	push   $0x7b
+  jmp __alltraps
+c010236e:	e9 92 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102373 <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+c0102373:	6a 00                	push   $0x0
+  pushl $124
+c0102375:	6a 7c                	push   $0x7c
+  jmp __alltraps
+c0102377:	e9 89 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c010237c <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+c010237c:	6a 00                	push   $0x0
+  pushl $125
+c010237e:	6a 7d                	push   $0x7d
+  jmp __alltraps
+c0102380:	e9 80 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102385 <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+c0102385:	6a 00                	push   $0x0
+  pushl $126
+c0102387:	6a 7e                	push   $0x7e
+  jmp __alltraps
+c0102389:	e9 77 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c010238e <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+c010238e:	6a 00                	push   $0x0
+  pushl $127
+c0102390:	6a 7f                	push   $0x7f
+  jmp __alltraps
+c0102392:	e9 6e fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102397 <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+c0102397:	6a 00                	push   $0x0
+  pushl $128
+c0102399:	68 80 00 00 00       	push   $0x80
+  jmp __alltraps
+c010239e:	e9 62 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c01023a3 <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+c01023a3:	6a 00                	push   $0x0
+  pushl $129
+c01023a5:	68 81 00 00 00       	push   $0x81
+  jmp __alltraps
+c01023aa:	e9 56 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c01023af <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+c01023af:	6a 00                	push   $0x0
+  pushl $130
+c01023b1:	68 82 00 00 00       	push   $0x82
+  jmp __alltraps
+c01023b6:	e9 4a fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c01023bb <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+c01023bb:	6a 00                	push   $0x0
+  pushl $131
+c01023bd:	68 83 00 00 00       	push   $0x83
+  jmp __alltraps
+c01023c2:	e9 3e fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c01023c7 <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+c01023c7:	6a 00                	push   $0x0
+  pushl $132
+c01023c9:	68 84 00 00 00       	push   $0x84
+  jmp __alltraps
+c01023ce:	e9 32 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c01023d3 <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+c01023d3:	6a 00                	push   $0x0
+  pushl $133
+c01023d5:	68 85 00 00 00       	push   $0x85
+  jmp __alltraps
+c01023da:	e9 26 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c01023df <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+c01023df:	6a 00                	push   $0x0
+  pushl $134
+c01023e1:	68 86 00 00 00       	push   $0x86
+  jmp __alltraps
+c01023e6:	e9 1a fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c01023eb <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+c01023eb:	6a 00                	push   $0x0
+  pushl $135
+c01023ed:	68 87 00 00 00       	push   $0x87
+  jmp __alltraps
+c01023f2:	e9 0e fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c01023f7 <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+c01023f7:	6a 00                	push   $0x0
+  pushl $136
+c01023f9:	68 88 00 00 00       	push   $0x88
+  jmp __alltraps
+c01023fe:	e9 02 fb ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102403 <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+c0102403:	6a 00                	push   $0x0
+  pushl $137
+c0102405:	68 89 00 00 00       	push   $0x89
+  jmp __alltraps
+c010240a:	e9 f6 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c010240f <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+c010240f:	6a 00                	push   $0x0
+  pushl $138
+c0102411:	68 8a 00 00 00       	push   $0x8a
+  jmp __alltraps
+c0102416:	e9 ea fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c010241b <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+c010241b:	6a 00                	push   $0x0
+  pushl $139
+c010241d:	68 8b 00 00 00       	push   $0x8b
+  jmp __alltraps
+c0102422:	e9 de fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102427 <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+c0102427:	6a 00                	push   $0x0
+  pushl $140
+c0102429:	68 8c 00 00 00       	push   $0x8c
+  jmp __alltraps
+c010242e:	e9 d2 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102433 <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+c0102433:	6a 00                	push   $0x0
+  pushl $141
+c0102435:	68 8d 00 00 00       	push   $0x8d
+  jmp __alltraps
+c010243a:	e9 c6 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c010243f <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+c010243f:	6a 00                	push   $0x0
+  pushl $142
+c0102441:	68 8e 00 00 00       	push   $0x8e
+  jmp __alltraps
+c0102446:	e9 ba fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c010244b <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+c010244b:	6a 00                	push   $0x0
+  pushl $143
+c010244d:	68 8f 00 00 00       	push   $0x8f
+  jmp __alltraps
+c0102452:	e9 ae fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102457 <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+c0102457:	6a 00                	push   $0x0
+  pushl $144
+c0102459:	68 90 00 00 00       	push   $0x90
+  jmp __alltraps
+c010245e:	e9 a2 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102463 <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+c0102463:	6a 00                	push   $0x0
+  pushl $145
+c0102465:	68 91 00 00 00       	push   $0x91
+  jmp __alltraps
+c010246a:	e9 96 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c010246f <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+c010246f:	6a 00                	push   $0x0
+  pushl $146
+c0102471:	68 92 00 00 00       	push   $0x92
+  jmp __alltraps
+c0102476:	e9 8a fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c010247b <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+c010247b:	6a 00                	push   $0x0
+  pushl $147
+c010247d:	68 93 00 00 00       	push   $0x93
+  jmp __alltraps
+c0102482:	e9 7e fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102487 <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+c0102487:	6a 00                	push   $0x0
+  pushl $148
+c0102489:	68 94 00 00 00       	push   $0x94
+  jmp __alltraps
+c010248e:	e9 72 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102493 <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+c0102493:	6a 00                	push   $0x0
+  pushl $149
+c0102495:	68 95 00 00 00       	push   $0x95
+  jmp __alltraps
+c010249a:	e9 66 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c010249f <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+c010249f:	6a 00                	push   $0x0
+  pushl $150
+c01024a1:	68 96 00 00 00       	push   $0x96
+  jmp __alltraps
+c01024a6:	e9 5a fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c01024ab <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+c01024ab:	6a 00                	push   $0x0
+  pushl $151
+c01024ad:	68 97 00 00 00       	push   $0x97
+  jmp __alltraps
+c01024b2:	e9 4e fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c01024b7 <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+c01024b7:	6a 00                	push   $0x0
+  pushl $152
+c01024b9:	68 98 00 00 00       	push   $0x98
+  jmp __alltraps
+c01024be:	e9 42 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c01024c3 <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+c01024c3:	6a 00                	push   $0x0
+  pushl $153
+c01024c5:	68 99 00 00 00       	push   $0x99
+  jmp __alltraps
+c01024ca:	e9 36 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c01024cf <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+c01024cf:	6a 00                	push   $0x0
+  pushl $154
+c01024d1:	68 9a 00 00 00       	push   $0x9a
+  jmp __alltraps
+c01024d6:	e9 2a fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c01024db <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+c01024db:	6a 00                	push   $0x0
+  pushl $155
+c01024dd:	68 9b 00 00 00       	push   $0x9b
+  jmp __alltraps
+c01024e2:	e9 1e fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c01024e7 <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+c01024e7:	6a 00                	push   $0x0
+  pushl $156
+c01024e9:	68 9c 00 00 00       	push   $0x9c
+  jmp __alltraps
+c01024ee:	e9 12 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c01024f3 <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+c01024f3:	6a 00                	push   $0x0
+  pushl $157
+c01024f5:	68 9d 00 00 00       	push   $0x9d
+  jmp __alltraps
+c01024fa:	e9 06 fa ff ff       	jmp    c0101f05 <__alltraps>
+
+c01024ff <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+c01024ff:	6a 00                	push   $0x0
+  pushl $158
+c0102501:	68 9e 00 00 00       	push   $0x9e
+  jmp __alltraps
+c0102506:	e9 fa f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010250b <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+c010250b:	6a 00                	push   $0x0
+  pushl $159
+c010250d:	68 9f 00 00 00       	push   $0x9f
+  jmp __alltraps
+c0102512:	e9 ee f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102517 <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+c0102517:	6a 00                	push   $0x0
+  pushl $160
+c0102519:	68 a0 00 00 00       	push   $0xa0
+  jmp __alltraps
+c010251e:	e9 e2 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102523 <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+c0102523:	6a 00                	push   $0x0
+  pushl $161
+c0102525:	68 a1 00 00 00       	push   $0xa1
+  jmp __alltraps
+c010252a:	e9 d6 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010252f <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+c010252f:	6a 00                	push   $0x0
+  pushl $162
+c0102531:	68 a2 00 00 00       	push   $0xa2
+  jmp __alltraps
+c0102536:	e9 ca f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010253b <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+c010253b:	6a 00                	push   $0x0
+  pushl $163
+c010253d:	68 a3 00 00 00       	push   $0xa3
+  jmp __alltraps
+c0102542:	e9 be f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102547 <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+c0102547:	6a 00                	push   $0x0
+  pushl $164
+c0102549:	68 a4 00 00 00       	push   $0xa4
+  jmp __alltraps
+c010254e:	e9 b2 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102553 <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+c0102553:	6a 00                	push   $0x0
+  pushl $165
+c0102555:	68 a5 00 00 00       	push   $0xa5
+  jmp __alltraps
+c010255a:	e9 a6 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010255f <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+c010255f:	6a 00                	push   $0x0
+  pushl $166
+c0102561:	68 a6 00 00 00       	push   $0xa6
+  jmp __alltraps
+c0102566:	e9 9a f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010256b <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+c010256b:	6a 00                	push   $0x0
+  pushl $167
+c010256d:	68 a7 00 00 00       	push   $0xa7
+  jmp __alltraps
+c0102572:	e9 8e f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102577 <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+c0102577:	6a 00                	push   $0x0
+  pushl $168
+c0102579:	68 a8 00 00 00       	push   $0xa8
+  jmp __alltraps
+c010257e:	e9 82 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102583 <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+c0102583:	6a 00                	push   $0x0
+  pushl $169
+c0102585:	68 a9 00 00 00       	push   $0xa9
+  jmp __alltraps
+c010258a:	e9 76 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010258f <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+c010258f:	6a 00                	push   $0x0
+  pushl $170
+c0102591:	68 aa 00 00 00       	push   $0xaa
+  jmp __alltraps
+c0102596:	e9 6a f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010259b <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+c010259b:	6a 00                	push   $0x0
+  pushl $171
+c010259d:	68 ab 00 00 00       	push   $0xab
+  jmp __alltraps
+c01025a2:	e9 5e f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01025a7 <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+c01025a7:	6a 00                	push   $0x0
+  pushl $172
+c01025a9:	68 ac 00 00 00       	push   $0xac
+  jmp __alltraps
+c01025ae:	e9 52 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01025b3 <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+c01025b3:	6a 00                	push   $0x0
+  pushl $173
+c01025b5:	68 ad 00 00 00       	push   $0xad
+  jmp __alltraps
+c01025ba:	e9 46 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01025bf <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+c01025bf:	6a 00                	push   $0x0
+  pushl $174
+c01025c1:	68 ae 00 00 00       	push   $0xae
+  jmp __alltraps
+c01025c6:	e9 3a f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01025cb <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+c01025cb:	6a 00                	push   $0x0
+  pushl $175
+c01025cd:	68 af 00 00 00       	push   $0xaf
+  jmp __alltraps
+c01025d2:	e9 2e f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01025d7 <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+c01025d7:	6a 00                	push   $0x0
+  pushl $176
+c01025d9:	68 b0 00 00 00       	push   $0xb0
+  jmp __alltraps
+c01025de:	e9 22 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01025e3 <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+c01025e3:	6a 00                	push   $0x0
+  pushl $177
+c01025e5:	68 b1 00 00 00       	push   $0xb1
+  jmp __alltraps
+c01025ea:	e9 16 f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01025ef <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+c01025ef:	6a 00                	push   $0x0
+  pushl $178
+c01025f1:	68 b2 00 00 00       	push   $0xb2
+  jmp __alltraps
+c01025f6:	e9 0a f9 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01025fb <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+c01025fb:	6a 00                	push   $0x0
+  pushl $179
+c01025fd:	68 b3 00 00 00       	push   $0xb3
+  jmp __alltraps
+c0102602:	e9 fe f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102607 <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+c0102607:	6a 00                	push   $0x0
+  pushl $180
+c0102609:	68 b4 00 00 00       	push   $0xb4
+  jmp __alltraps
+c010260e:	e9 f2 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102613 <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+c0102613:	6a 00                	push   $0x0
+  pushl $181
+c0102615:	68 b5 00 00 00       	push   $0xb5
+  jmp __alltraps
+c010261a:	e9 e6 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010261f <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+c010261f:	6a 00                	push   $0x0
+  pushl $182
+c0102621:	68 b6 00 00 00       	push   $0xb6
+  jmp __alltraps
+c0102626:	e9 da f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010262b <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+c010262b:	6a 00                	push   $0x0
+  pushl $183
+c010262d:	68 b7 00 00 00       	push   $0xb7
+  jmp __alltraps
+c0102632:	e9 ce f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102637 <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+c0102637:	6a 00                	push   $0x0
+  pushl $184
+c0102639:	68 b8 00 00 00       	push   $0xb8
+  jmp __alltraps
+c010263e:	e9 c2 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102643 <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+c0102643:	6a 00                	push   $0x0
+  pushl $185
+c0102645:	68 b9 00 00 00       	push   $0xb9
+  jmp __alltraps
+c010264a:	e9 b6 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010264f <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+c010264f:	6a 00                	push   $0x0
+  pushl $186
+c0102651:	68 ba 00 00 00       	push   $0xba
+  jmp __alltraps
+c0102656:	e9 aa f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010265b <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+c010265b:	6a 00                	push   $0x0
+  pushl $187
+c010265d:	68 bb 00 00 00       	push   $0xbb
+  jmp __alltraps
+c0102662:	e9 9e f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102667 <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+c0102667:	6a 00                	push   $0x0
+  pushl $188
+c0102669:	68 bc 00 00 00       	push   $0xbc
+  jmp __alltraps
+c010266e:	e9 92 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102673 <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+c0102673:	6a 00                	push   $0x0
+  pushl $189
+c0102675:	68 bd 00 00 00       	push   $0xbd
+  jmp __alltraps
+c010267a:	e9 86 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010267f <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+c010267f:	6a 00                	push   $0x0
+  pushl $190
+c0102681:	68 be 00 00 00       	push   $0xbe
+  jmp __alltraps
+c0102686:	e9 7a f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010268b <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+c010268b:	6a 00                	push   $0x0
+  pushl $191
+c010268d:	68 bf 00 00 00       	push   $0xbf
+  jmp __alltraps
+c0102692:	e9 6e f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102697 <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+c0102697:	6a 00                	push   $0x0
+  pushl $192
+c0102699:	68 c0 00 00 00       	push   $0xc0
+  jmp __alltraps
+c010269e:	e9 62 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01026a3 <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+c01026a3:	6a 00                	push   $0x0
+  pushl $193
+c01026a5:	68 c1 00 00 00       	push   $0xc1
+  jmp __alltraps
+c01026aa:	e9 56 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01026af <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+c01026af:	6a 00                	push   $0x0
+  pushl $194
+c01026b1:	68 c2 00 00 00       	push   $0xc2
+  jmp __alltraps
+c01026b6:	e9 4a f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01026bb <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+c01026bb:	6a 00                	push   $0x0
+  pushl $195
+c01026bd:	68 c3 00 00 00       	push   $0xc3
+  jmp __alltraps
+c01026c2:	e9 3e f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01026c7 <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+c01026c7:	6a 00                	push   $0x0
+  pushl $196
+c01026c9:	68 c4 00 00 00       	push   $0xc4
+  jmp __alltraps
+c01026ce:	e9 32 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01026d3 <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+c01026d3:	6a 00                	push   $0x0
+  pushl $197
+c01026d5:	68 c5 00 00 00       	push   $0xc5
+  jmp __alltraps
+c01026da:	e9 26 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01026df <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+c01026df:	6a 00                	push   $0x0
+  pushl $198
+c01026e1:	68 c6 00 00 00       	push   $0xc6
+  jmp __alltraps
+c01026e6:	e9 1a f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01026eb <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+c01026eb:	6a 00                	push   $0x0
+  pushl $199
+c01026ed:	68 c7 00 00 00       	push   $0xc7
+  jmp __alltraps
+c01026f2:	e9 0e f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01026f7 <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+c01026f7:	6a 00                	push   $0x0
+  pushl $200
+c01026f9:	68 c8 00 00 00       	push   $0xc8
+  jmp __alltraps
+c01026fe:	e9 02 f8 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102703 <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+c0102703:	6a 00                	push   $0x0
+  pushl $201
+c0102705:	68 c9 00 00 00       	push   $0xc9
+  jmp __alltraps
+c010270a:	e9 f6 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010270f <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+c010270f:	6a 00                	push   $0x0
+  pushl $202
+c0102711:	68 ca 00 00 00       	push   $0xca
+  jmp __alltraps
+c0102716:	e9 ea f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010271b <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+c010271b:	6a 00                	push   $0x0
+  pushl $203
+c010271d:	68 cb 00 00 00       	push   $0xcb
+  jmp __alltraps
+c0102722:	e9 de f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102727 <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+c0102727:	6a 00                	push   $0x0
+  pushl $204
+c0102729:	68 cc 00 00 00       	push   $0xcc
+  jmp __alltraps
+c010272e:	e9 d2 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102733 <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+c0102733:	6a 00                	push   $0x0
+  pushl $205
+c0102735:	68 cd 00 00 00       	push   $0xcd
+  jmp __alltraps
+c010273a:	e9 c6 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010273f <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+c010273f:	6a 00                	push   $0x0
+  pushl $206
+c0102741:	68 ce 00 00 00       	push   $0xce
+  jmp __alltraps
+c0102746:	e9 ba f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010274b <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+c010274b:	6a 00                	push   $0x0
+  pushl $207
+c010274d:	68 cf 00 00 00       	push   $0xcf
+  jmp __alltraps
+c0102752:	e9 ae f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102757 <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+c0102757:	6a 00                	push   $0x0
+  pushl $208
+c0102759:	68 d0 00 00 00       	push   $0xd0
+  jmp __alltraps
+c010275e:	e9 a2 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102763 <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+c0102763:	6a 00                	push   $0x0
+  pushl $209
+c0102765:	68 d1 00 00 00       	push   $0xd1
+  jmp __alltraps
+c010276a:	e9 96 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010276f <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+c010276f:	6a 00                	push   $0x0
+  pushl $210
+c0102771:	68 d2 00 00 00       	push   $0xd2
+  jmp __alltraps
+c0102776:	e9 8a f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010277b <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+c010277b:	6a 00                	push   $0x0
+  pushl $211
+c010277d:	68 d3 00 00 00       	push   $0xd3
+  jmp __alltraps
+c0102782:	e9 7e f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102787 <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+c0102787:	6a 00                	push   $0x0
+  pushl $212
+c0102789:	68 d4 00 00 00       	push   $0xd4
+  jmp __alltraps
+c010278e:	e9 72 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102793 <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+c0102793:	6a 00                	push   $0x0
+  pushl $213
+c0102795:	68 d5 00 00 00       	push   $0xd5
+  jmp __alltraps
+c010279a:	e9 66 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010279f <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+c010279f:	6a 00                	push   $0x0
+  pushl $214
+c01027a1:	68 d6 00 00 00       	push   $0xd6
+  jmp __alltraps
+c01027a6:	e9 5a f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01027ab <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+c01027ab:	6a 00                	push   $0x0
+  pushl $215
+c01027ad:	68 d7 00 00 00       	push   $0xd7
+  jmp __alltraps
+c01027b2:	e9 4e f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01027b7 <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+c01027b7:	6a 00                	push   $0x0
+  pushl $216
+c01027b9:	68 d8 00 00 00       	push   $0xd8
+  jmp __alltraps
+c01027be:	e9 42 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01027c3 <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+c01027c3:	6a 00                	push   $0x0
+  pushl $217
+c01027c5:	68 d9 00 00 00       	push   $0xd9
+  jmp __alltraps
+c01027ca:	e9 36 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01027cf <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+c01027cf:	6a 00                	push   $0x0
+  pushl $218
+c01027d1:	68 da 00 00 00       	push   $0xda
+  jmp __alltraps
+c01027d6:	e9 2a f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01027db <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+c01027db:	6a 00                	push   $0x0
+  pushl $219
+c01027dd:	68 db 00 00 00       	push   $0xdb
+  jmp __alltraps
+c01027e2:	e9 1e f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01027e7 <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+c01027e7:	6a 00                	push   $0x0
+  pushl $220
+c01027e9:	68 dc 00 00 00       	push   $0xdc
+  jmp __alltraps
+c01027ee:	e9 12 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01027f3 <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+c01027f3:	6a 00                	push   $0x0
+  pushl $221
+c01027f5:	68 dd 00 00 00       	push   $0xdd
+  jmp __alltraps
+c01027fa:	e9 06 f7 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01027ff <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+c01027ff:	6a 00                	push   $0x0
+  pushl $222
+c0102801:	68 de 00 00 00       	push   $0xde
+  jmp __alltraps
+c0102806:	e9 fa f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010280b <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+c010280b:	6a 00                	push   $0x0
+  pushl $223
+c010280d:	68 df 00 00 00       	push   $0xdf
+  jmp __alltraps
+c0102812:	e9 ee f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102817 <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+c0102817:	6a 00                	push   $0x0
+  pushl $224
+c0102819:	68 e0 00 00 00       	push   $0xe0
+  jmp __alltraps
+c010281e:	e9 e2 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102823 <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+c0102823:	6a 00                	push   $0x0
+  pushl $225
+c0102825:	68 e1 00 00 00       	push   $0xe1
+  jmp __alltraps
+c010282a:	e9 d6 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010282f <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+c010282f:	6a 00                	push   $0x0
+  pushl $226
+c0102831:	68 e2 00 00 00       	push   $0xe2
+  jmp __alltraps
+c0102836:	e9 ca f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010283b <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+c010283b:	6a 00                	push   $0x0
+  pushl $227
+c010283d:	68 e3 00 00 00       	push   $0xe3
+  jmp __alltraps
+c0102842:	e9 be f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102847 <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+c0102847:	6a 00                	push   $0x0
+  pushl $228
+c0102849:	68 e4 00 00 00       	push   $0xe4
+  jmp __alltraps
+c010284e:	e9 b2 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102853 <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+c0102853:	6a 00                	push   $0x0
+  pushl $229
+c0102855:	68 e5 00 00 00       	push   $0xe5
+  jmp __alltraps
+c010285a:	e9 a6 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010285f <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+c010285f:	6a 00                	push   $0x0
+  pushl $230
+c0102861:	68 e6 00 00 00       	push   $0xe6
+  jmp __alltraps
+c0102866:	e9 9a f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010286b <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+c010286b:	6a 00                	push   $0x0
+  pushl $231
+c010286d:	68 e7 00 00 00       	push   $0xe7
+  jmp __alltraps
+c0102872:	e9 8e f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102877 <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+c0102877:	6a 00                	push   $0x0
+  pushl $232
+c0102879:	68 e8 00 00 00       	push   $0xe8
+  jmp __alltraps
+c010287e:	e9 82 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102883 <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+c0102883:	6a 00                	push   $0x0
+  pushl $233
+c0102885:	68 e9 00 00 00       	push   $0xe9
+  jmp __alltraps
+c010288a:	e9 76 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010288f <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+c010288f:	6a 00                	push   $0x0
+  pushl $234
+c0102891:	68 ea 00 00 00       	push   $0xea
+  jmp __alltraps
+c0102896:	e9 6a f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010289b <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+c010289b:	6a 00                	push   $0x0
+  pushl $235
+c010289d:	68 eb 00 00 00       	push   $0xeb
+  jmp __alltraps
+c01028a2:	e9 5e f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01028a7 <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+c01028a7:	6a 00                	push   $0x0
+  pushl $236
+c01028a9:	68 ec 00 00 00       	push   $0xec
+  jmp __alltraps
+c01028ae:	e9 52 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01028b3 <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+c01028b3:	6a 00                	push   $0x0
+  pushl $237
+c01028b5:	68 ed 00 00 00       	push   $0xed
+  jmp __alltraps
+c01028ba:	e9 46 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01028bf <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+c01028bf:	6a 00                	push   $0x0
+  pushl $238
+c01028c1:	68 ee 00 00 00       	push   $0xee
+  jmp __alltraps
+c01028c6:	e9 3a f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01028cb <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+c01028cb:	6a 00                	push   $0x0
+  pushl $239
+c01028cd:	68 ef 00 00 00       	push   $0xef
+  jmp __alltraps
+c01028d2:	e9 2e f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01028d7 <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+c01028d7:	6a 00                	push   $0x0
+  pushl $240
+c01028d9:	68 f0 00 00 00       	push   $0xf0
+  jmp __alltraps
+c01028de:	e9 22 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01028e3 <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+c01028e3:	6a 00                	push   $0x0
+  pushl $241
+c01028e5:	68 f1 00 00 00       	push   $0xf1
+  jmp __alltraps
+c01028ea:	e9 16 f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01028ef <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+c01028ef:	6a 00                	push   $0x0
+  pushl $242
+c01028f1:	68 f2 00 00 00       	push   $0xf2
+  jmp __alltraps
+c01028f6:	e9 0a f6 ff ff       	jmp    c0101f05 <__alltraps>
+
+c01028fb <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+c01028fb:	6a 00                	push   $0x0
+  pushl $243
+c01028fd:	68 f3 00 00 00       	push   $0xf3
+  jmp __alltraps
+c0102902:	e9 fe f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102907 <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+c0102907:	6a 00                	push   $0x0
+  pushl $244
+c0102909:	68 f4 00 00 00       	push   $0xf4
+  jmp __alltraps
+c010290e:	e9 f2 f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102913 <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+c0102913:	6a 00                	push   $0x0
+  pushl $245
+c0102915:	68 f5 00 00 00       	push   $0xf5
+  jmp __alltraps
+c010291a:	e9 e6 f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010291f <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+c010291f:	6a 00                	push   $0x0
+  pushl $246
+c0102921:	68 f6 00 00 00       	push   $0xf6
+  jmp __alltraps
+c0102926:	e9 da f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010292b <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+c010292b:	6a 00                	push   $0x0
+  pushl $247
+c010292d:	68 f7 00 00 00       	push   $0xf7
+  jmp __alltraps
+c0102932:	e9 ce f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102937 <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+c0102937:	6a 00                	push   $0x0
+  pushl $248
+c0102939:	68 f8 00 00 00       	push   $0xf8
+  jmp __alltraps
+c010293e:	e9 c2 f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102943 <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+c0102943:	6a 00                	push   $0x0
+  pushl $249
+c0102945:	68 f9 00 00 00       	push   $0xf9
+  jmp __alltraps
+c010294a:	e9 b6 f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010294f <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+c010294f:	6a 00                	push   $0x0
+  pushl $250
+c0102951:	68 fa 00 00 00       	push   $0xfa
+  jmp __alltraps
+c0102956:	e9 aa f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010295b <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+c010295b:	6a 00                	push   $0x0
+  pushl $251
+c010295d:	68 fb 00 00 00       	push   $0xfb
+  jmp __alltraps
+c0102962:	e9 9e f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102967 <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+c0102967:	6a 00                	push   $0x0
+  pushl $252
+c0102969:	68 fc 00 00 00       	push   $0xfc
+  jmp __alltraps
+c010296e:	e9 92 f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102973 <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+c0102973:	6a 00                	push   $0x0
+  pushl $253
+c0102975:	68 fd 00 00 00       	push   $0xfd
+  jmp __alltraps
+c010297a:	e9 86 f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010297f <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+c010297f:	6a 00                	push   $0x0
+  pushl $254
+c0102981:	68 fe 00 00 00       	push   $0xfe
+  jmp __alltraps
+c0102986:	e9 7a f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c010298b <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+c010298b:	6a 00                	push   $0x0
+  pushl $255
+c010298d:	68 ff 00 00 00       	push   $0xff
+  jmp __alltraps
+c0102992:	e9 6e f5 ff ff       	jmp    c0101f05 <__alltraps>
+
+c0102997 <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+c0102997:	55                   	push   %ebp
+c0102998:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+c010299a:	8b 55 08             	mov    0x8(%ebp),%edx
+c010299d:	a1 c4 89 11 c0       	mov    0xc01189c4,%eax
+c01029a2:	29 c2                	sub    %eax,%edx
+c01029a4:	89 d0                	mov    %edx,%eax
+c01029a6:	c1 f8 02             	sar    $0x2,%eax
+c01029a9:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
+}
+c01029af:	5d                   	pop    %ebp
+c01029b0:	c3                   	ret    
+
+c01029b1 <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+c01029b1:	55                   	push   %ebp
+c01029b2:	89 e5                	mov    %esp,%ebp
+c01029b4:	83 ec 04             	sub    $0x4,%esp
+    return page2ppn(page) << PGSHIFT;
+c01029b7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01029ba:	89 04 24             	mov    %eax,(%esp)
+c01029bd:	e8 d5 ff ff ff       	call   c0102997 <page2ppn>
+c01029c2:	c1 e0 0c             	shl    $0xc,%eax
+}
+c01029c5:	c9                   	leave  
+c01029c6:	c3                   	ret    
+
+c01029c7 <page_ref>:
+pde2page(pde_t pde) {
+    return pa2page(PDE_ADDR(pde));
+}
+
+static inline int
+page_ref(struct Page *page) {
+c01029c7:	55                   	push   %ebp
+c01029c8:	89 e5                	mov    %esp,%ebp
+    return page->ref;
+c01029ca:	8b 45 08             	mov    0x8(%ebp),%eax
+c01029cd:	8b 00                	mov    (%eax),%eax
+}
+c01029cf:	5d                   	pop    %ebp
+c01029d0:	c3                   	ret    
+
+c01029d1 <set_page_ref>:
+
+static inline void
+set_page_ref(struct Page *page, int val) {
+c01029d1:	55                   	push   %ebp
+c01029d2:	89 e5                	mov    %esp,%ebp
+    page->ref = val;
+c01029d4:	8b 45 08             	mov    0x8(%ebp),%eax
+c01029d7:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01029da:	89 10                	mov    %edx,(%eax)
+}
+c01029dc:	5d                   	pop    %ebp
+c01029dd:	c3                   	ret    
+
+c01029de <default_init>:
+
+#define free_list (free_area.free_list)
+#define nr_free (free_area.nr_free)
+
+static void
+default_init(void) {
+c01029de:	55                   	push   %ebp
+c01029df:	89 e5                	mov    %esp,%ebp
+c01029e1:	83 ec 10             	sub    $0x10,%esp
+c01029e4:	c7 45 fc b0 89 11 c0 	movl   $0xc01189b0,-0x4(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c01029eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01029ee:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c01029f1:	89 50 04             	mov    %edx,0x4(%eax)
+c01029f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01029f7:	8b 50 04             	mov    0x4(%eax),%edx
+c01029fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01029fd:	89 10                	mov    %edx,(%eax)
+    list_init(&free_list);
+    nr_free = 0;
+c01029ff:	c7 05 b8 89 11 c0 00 	movl   $0x0,0xc01189b8
+c0102a06:	00 00 00 
+}
+c0102a09:	c9                   	leave  
+c0102a0a:	c3                   	ret    
+
+c0102a0b <default_init_memmap>:
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+c0102a0b:	55                   	push   %ebp
+c0102a0c:	89 e5                	mov    %esp,%ebp
+c0102a0e:	83 ec 48             	sub    $0x48,%esp
+    assert(n > 0);
+c0102a11:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0102a15:	75 24                	jne    c0102a3b <default_init_memmap+0x30>
+c0102a17:	c7 44 24 0c 90 67 10 	movl   $0xc0106790,0xc(%esp)
+c0102a1e:	c0 
+c0102a1f:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0102a26:	c0 
+c0102a27:	c7 44 24 04 46 00 00 	movl   $0x46,0x4(%esp)
+c0102a2e:	00 
+c0102a2f:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0102a36:	e8 85 e2 ff ff       	call   c0100cc0 <__panic>
+    struct Page *p = base;
+c0102a3b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102a3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    for (; p != base + n; p ++) {
+c0102a41:	e9 de 00 00 00       	jmp    c0102b24 <default_init_memmap+0x119>
+        assert(PageReserved(p));
+c0102a46:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102a49:	83 c0 04             	add    $0x4,%eax
+c0102a4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+c0102a53:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c0102a56:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102a59:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0102a5c:	0f a3 10             	bt     %edx,(%eax)
+c0102a5f:	19 c0                	sbb    %eax,%eax
+c0102a61:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    return oldbit != 0;
+c0102a64:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0102a68:	0f 95 c0             	setne  %al
+c0102a6b:	0f b6 c0             	movzbl %al,%eax
+c0102a6e:	85 c0                	test   %eax,%eax
+c0102a70:	75 24                	jne    c0102a96 <default_init_memmap+0x8b>
+c0102a72:	c7 44 24 0c c1 67 10 	movl   $0xc01067c1,0xc(%esp)
+c0102a79:	c0 
+c0102a7a:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0102a81:	c0 
+c0102a82:	c7 44 24 04 49 00 00 	movl   $0x49,0x4(%esp)
+c0102a89:	00 
+c0102a8a:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0102a91:	e8 2a e2 ff ff       	call   c0100cc0 <__panic>
+        p->flags = p->property = 0;
+c0102a96:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102a99:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+c0102aa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102aa3:	8b 50 08             	mov    0x8(%eax),%edx
+c0102aa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102aa9:	89 50 04             	mov    %edx,0x4(%eax)
+	SetPageProperty(p); //#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
+c0102aac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102aaf:	83 c0 04             	add    $0x4,%eax
+c0102ab2:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
+c0102ab9:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0102abc:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0102abf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0102ac2:	0f ab 10             	bts    %edx,(%eax)
+        set_page_ref(p, 0);
+c0102ac5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0102acc:	00 
+c0102acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102ad0:	89 04 24             	mov    %eax,(%esp)
+c0102ad3:	e8 f9 fe ff ff       	call   c01029d1 <set_page_ref>
+	list_add_before(&free_list, &(p->page_link));
+c0102ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102adb:	83 c0 0c             	add    $0xc,%eax
+c0102ade:	c7 45 dc b0 89 11 c0 	movl   $0xc01189b0,-0x24(%ebp)
+c0102ae5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+c0102ae8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0102aeb:	8b 00                	mov    (%eax),%eax
+c0102aed:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0102af0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c0102af3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0102af6:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0102af9:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c0102afc:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0102aff:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0102b02:	89 10                	mov    %edx,(%eax)
+c0102b04:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0102b07:	8b 10                	mov    (%eax),%edx
+c0102b09:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0102b0c:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c0102b0f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0102b12:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0102b15:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c0102b18:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0102b1b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0102b1e:	89 10                	mov    %edx,(%eax)
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+    assert(n > 0);
+    struct Page *p = base;
+    for (; p != base + n; p ++) {
+c0102b20:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
+c0102b24:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0102b27:	89 d0                	mov    %edx,%eax
+c0102b29:	c1 e0 02             	shl    $0x2,%eax
+c0102b2c:	01 d0                	add    %edx,%eax
+c0102b2e:	c1 e0 02             	shl    $0x2,%eax
+c0102b31:	89 c2                	mov    %eax,%edx
+c0102b33:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102b36:	01 d0                	add    %edx,%eax
+c0102b38:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0102b3b:	0f 85 05 ff ff ff    	jne    c0102a46 <default_init_memmap+0x3b>
+        p->flags = p->property = 0;
+	SetPageProperty(p); //#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
+        set_page_ref(p, 0);
+	list_add_before(&free_list, &(p->page_link));
+    }
+    base->property = n;
+c0102b41:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102b44:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0102b47:	89 50 08             	mov    %edx,0x8(%eax)
+    //SetPageProperty(base);
+    nr_free += n;
+c0102b4a:	8b 15 b8 89 11 c0    	mov    0xc01189b8,%edx
+c0102b50:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0102b53:	01 d0                	add    %edx,%eax
+c0102b55:	a3 b8 89 11 c0       	mov    %eax,0xc01189b8
+    //list_add(&free_list, &(base->page_link));
+}
+c0102b5a:	c9                   	leave  
+c0102b5b:	c3                   	ret    
+
+c0102b5c <default_alloc_pages>:
+
+static struct Page *
+default_alloc_pages(size_t n) {
+c0102b5c:	55                   	push   %ebp
+c0102b5d:	89 e5                	mov    %esp,%ebp
+c0102b5f:	83 ec 68             	sub    $0x68,%esp
+    assert(n > 0);
+c0102b62:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0102b66:	75 24                	jne    c0102b8c <default_alloc_pages+0x30>
+c0102b68:	c7 44 24 0c 90 67 10 	movl   $0xc0106790,0xc(%esp)
+c0102b6f:	c0 
+c0102b70:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0102b77:	c0 
+c0102b78:	c7 44 24 04 57 00 00 	movl   $0x57,0x4(%esp)
+c0102b7f:	00 
+c0102b80:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0102b87:	e8 34 e1 ff ff       	call   c0100cc0 <__panic>
+    if (n > nr_free) {
+c0102b8c:	a1 b8 89 11 c0       	mov    0xc01189b8,%eax
+c0102b91:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0102b94:	73 0a                	jae    c0102ba0 <default_alloc_pages+0x44>
+        return NULL;
+c0102b96:	b8 00 00 00 00       	mov    $0x0,%eax
+c0102b9b:	e9 37 01 00 00       	jmp    c0102cd7 <default_alloc_pages+0x17b>
+    }
+    list_entry_t *le = &free_list;
+c0102ba0:	c7 45 f4 b0 89 11 c0 	movl   $0xc01189b0,-0xc(%ebp)
+    list_entry_t *len;
+    while ((le = list_next(le)) != &free_list) {
+c0102ba7:	e9 0a 01 00 00       	jmp    c0102cb6 <default_alloc_pages+0x15a>
+        struct Page *p = le2page(le, page_link);
+c0102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102baf:	83 e8 0c             	sub    $0xc,%eax
+c0102bb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        if (p->property >= n) {
+c0102bb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102bb8:	8b 40 08             	mov    0x8(%eax),%eax
+c0102bbb:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0102bbe:	0f 82 f2 00 00 00    	jb     c0102cb6 <default_alloc_pages+0x15a>
+		int i;
+		for(i=0;i<n;i++){
+c0102bc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+c0102bcb:	eb 7c                	jmp    c0102c49 <default_alloc_pages+0xed>
+c0102bcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102bd0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0102bd3:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0102bd6:	8b 40 04             	mov    0x4(%eax),%eax
+		  len = list_next(le);
+c0102bd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+		  struct Page *pp = le2page(le, page_link);
+c0102bdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102bdf:	83 e8 0c             	sub    $0xc,%eax
+c0102be2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		  SetPageReserved(pp);
+c0102be5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0102be8:	83 c0 04             	add    $0x4,%eax
+c0102beb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c0102bf2:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0102bf5:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0102bf8:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0102bfb:	0f ab 10             	bts    %edx,(%eax)
+		  ClearPageProperty(pp);
+c0102bfe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0102c01:	83 c0 04             	add    $0x4,%eax
+c0102c04:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
+c0102c0b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ * @nr:     the bit to clear
+ * @addr:   the address to start counting from
+ * */
+static inline void
+clear_bit(int nr, volatile void *addr) {
+    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0102c0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0102c11:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0102c14:	0f b3 10             	btr    %edx,(%eax)
+c0102c17:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102c1a:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+c0102c1d:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0102c20:	8b 40 04             	mov    0x4(%eax),%eax
+c0102c23:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0102c26:	8b 12                	mov    (%edx),%edx
+c0102c28:	89 55 c8             	mov    %edx,-0x38(%ebp)
+c0102c2b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+c0102c2e:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0102c31:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+c0102c34:	89 50 04             	mov    %edx,0x4(%eax)
+    next->prev = prev;
+c0102c37:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0102c3a:	8b 55 c8             	mov    -0x38(%ebp),%edx
+c0102c3d:	89 10                	mov    %edx,(%eax)
+		  list_del(le);
+		  le = len;
+c0102c3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0102c42:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    list_entry_t *len;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        if (p->property >= n) {
+		int i;
+		for(i=0;i<n;i++){
+c0102c45:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+c0102c49:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102c4c:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0102c4f:	0f 82 78 ff ff ff    	jb     c0102bcd <default_alloc_pages+0x71>
+		  SetPageReserved(pp);
+		  ClearPageProperty(pp);
+		  list_del(le);
+		  le = len;
+		}
+		if(p->property>n){
+c0102c55:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102c58:	8b 40 08             	mov    0x8(%eax),%eax
+c0102c5b:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0102c5e:	76 12                	jbe    c0102c72 <default_alloc_pages+0x116>
+		  (le2page(le,page_link))->property = p->property - n;
+c0102c60:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102c63:	8d 50 f4             	lea    -0xc(%eax),%edx
+c0102c66:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102c69:	8b 40 08             	mov    0x8(%eax),%eax
+c0102c6c:	2b 45 08             	sub    0x8(%ebp),%eax
+c0102c6f:	89 42 08             	mov    %eax,0x8(%edx)
+		}
+		ClearPageProperty(p);
+c0102c72:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102c75:	83 c0 04             	add    $0x4,%eax
+c0102c78:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%ebp)
+c0102c7f:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c0102c82:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c0102c85:	8b 55 c0             	mov    -0x40(%ebp),%edx
+c0102c88:	0f b3 10             	btr    %edx,(%eax)
+		SetPageReserved(p);
+c0102c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102c8e:	83 c0 04             	add    $0x4,%eax
+c0102c91:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
+c0102c98:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0102c9b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0102c9e:	8b 55 b8             	mov    -0x48(%ebp),%edx
+c0102ca1:	0f ab 10             	bts    %edx,(%eax)
+		nr_free -= n;
+c0102ca4:	a1 b8 89 11 c0       	mov    0xc01189b8,%eax
+c0102ca9:	2b 45 08             	sub    0x8(%ebp),%eax
+c0102cac:	a3 b8 89 11 c0       	mov    %eax,0xc01189b8
+		return p;
+c0102cb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102cb4:	eb 21                	jmp    c0102cd7 <default_alloc_pages+0x17b>
+c0102cb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102cb9:	89 45 b0             	mov    %eax,-0x50(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0102cbc:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0102cbf:	8b 40 04             	mov    0x4(%eax),%eax
+    if (n > nr_free) {
+        return NULL;
+    }
+    list_entry_t *le = &free_list;
+    list_entry_t *len;
+    while ((le = list_next(le)) != &free_list) {
+c0102cc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0102cc5:	81 7d f4 b0 89 11 c0 	cmpl   $0xc01189b0,-0xc(%ebp)
+c0102ccc:	0f 85 da fe ff ff    	jne    c0102bac <default_alloc_pages+0x50>
+		SetPageReserved(p);
+		nr_free -= n;
+		return p;
+        }
+    }
+    return	NULL;
+c0102cd2:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0102cd7:	c9                   	leave  
+c0102cd8:	c3                   	ret    
+
+c0102cd9 <default_free_pages>:
+
+static void
+default_free_pages(struct Page *base, size_t n) {
+c0102cd9:	55                   	push   %ebp
+c0102cda:	89 e5                	mov    %esp,%ebp
+c0102cdc:	83 ec 68             	sub    $0x68,%esp
+    assert(n > 0);
+c0102cdf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0102ce3:	75 24                	jne    c0102d09 <default_free_pages+0x30>
+c0102ce5:	c7 44 24 0c 90 67 10 	movl   $0xc0106790,0xc(%esp)
+c0102cec:	c0 
+c0102ced:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0102cf4:	c0 
+c0102cf5:	c7 44 24 04 77 00 00 	movl   $0x77,0x4(%esp)
+c0102cfc:	00 
+c0102cfd:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0102d04:	e8 b7 df ff ff       	call   c0100cc0 <__panic>
+    assert(PageReserved(base));
+c0102d09:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102d0c:	83 c0 04             	add    $0x4,%eax
+c0102d0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c0102d16:	89 45 e8             	mov    %eax,-0x18(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c0102d19:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0102d1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0102d1f:	0f a3 10             	bt     %edx,(%eax)
+c0102d22:	19 c0                	sbb    %eax,%eax
+c0102d24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    return oldbit != 0;
+c0102d27:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0102d2b:	0f 95 c0             	setne  %al
+c0102d2e:	0f b6 c0             	movzbl %al,%eax
+c0102d31:	85 c0                	test   %eax,%eax
+c0102d33:	75 24                	jne    c0102d59 <default_free_pages+0x80>
+c0102d35:	c7 44 24 0c d1 67 10 	movl   $0xc01067d1,0xc(%esp)
+c0102d3c:	c0 
+c0102d3d:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0102d44:	c0 
+c0102d45:	c7 44 24 04 78 00 00 	movl   $0x78,0x4(%esp)
+c0102d4c:	00 
+c0102d4d:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0102d54:	e8 67 df ff ff       	call   c0100cc0 <__panic>
+
+    list_entry_t *le = &free_list;
+c0102d59:	c7 45 f4 b0 89 11 c0 	movl   $0xc01189b0,-0xc(%ebp)
+    struct Page * p;
+    while((le=list_next(le)) != &free_list) {
+c0102d60:	eb 13                	jmp    c0102d75 <default_free_pages+0x9c>
+      p = le2page(le, page_link);
+c0102d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102d65:	83 e8 0c             	sub    $0xc,%eax
+c0102d68:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      if(p>base){
+c0102d6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102d6e:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0102d71:	76 02                	jbe    c0102d75 <default_free_pages+0x9c>
+        break;
+c0102d73:	eb 18                	jmp    c0102d8d <default_free_pages+0xb4>
+c0102d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102d78:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0102d7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0102d7e:	8b 40 04             	mov    0x4(%eax),%eax
+    assert(n > 0);
+    assert(PageReserved(base));
+
+    list_entry_t *le = &free_list;
+    struct Page * p;
+    while((le=list_next(le)) != &free_list) {
+c0102d81:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0102d84:	81 7d f4 b0 89 11 c0 	cmpl   $0xc01189b0,-0xc(%ebp)
+c0102d8b:	75 d5                	jne    c0102d62 <default_free_pages+0x89>
+      if(p>base){
+        break;
+      }
+    }
+    //list_add_before(le, base->page_link);
+    for(p=base;p<base+n;p++){
+c0102d8d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102d90:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0102d93:	eb 4b                	jmp    c0102de0 <default_free_pages+0x107>
+      list_add_before(le, &(p->page_link));
+c0102d95:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102d98:	8d 50 0c             	lea    0xc(%eax),%edx
+c0102d9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102d9e:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0102da1:	89 55 d8             	mov    %edx,-0x28(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+c0102da4:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0102da7:	8b 00                	mov    (%eax),%eax
+c0102da9:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0102dac:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c0102daf:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0102db2:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0102db5:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+c0102db8:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0102dbb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0102dbe:	89 10                	mov    %edx,(%eax)
+c0102dc0:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0102dc3:	8b 10                	mov    (%eax),%edx
+c0102dc5:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0102dc8:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+c0102dcb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0102dce:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0102dd1:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+c0102dd4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0102dd7:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0102dda:	89 10                	mov    %edx,(%eax)
+      if(p>base){
+        break;
+      }
+    }
+    //list_add_before(le, base->page_link);
+    for(p=base;p<base+n;p++){
+c0102ddc:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)
+c0102de0:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0102de3:	89 d0                	mov    %edx,%eax
+c0102de5:	c1 e0 02             	shl    $0x2,%eax
+c0102de8:	01 d0                	add    %edx,%eax
+c0102dea:	c1 e0 02             	shl    $0x2,%eax
+c0102ded:	89 c2                	mov    %eax,%edx
+c0102def:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102df2:	01 d0                	add    %edx,%eax
+c0102df4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0102df7:	77 9c                	ja     c0102d95 <default_free_pages+0xbc>
+      list_add_before(le, &(p->page_link));
+    }
+    base->flags = 0;
+c0102df9:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102dfc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    set_page_ref(base, 0);
+c0102e03:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0102e0a:	00 
+c0102e0b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102e0e:	89 04 24             	mov    %eax,(%esp)
+c0102e11:	e8 bb fb ff ff       	call   c01029d1 <set_page_ref>
+    ClearPageProperty(base);
+c0102e16:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102e19:	83 c0 04             	add    $0x4,%eax
+c0102e1c:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
+c0102e23:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+ * @nr:     the bit to clear
+ * @addr:   the address to start counting from
+ * */
+static inline void
+clear_bit(int nr, volatile void *addr) {
+    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0102e26:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0102e29:	8b 55 c8             	mov    -0x38(%ebp),%edx
+c0102e2c:	0f b3 10             	btr    %edx,(%eax)
+    SetPageProperty(base);
+c0102e2f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102e32:	83 c0 04             	add    $0x4,%eax
+c0102e35:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%ebp)
+c0102e3c:	89 45 bc             	mov    %eax,-0x44(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0102e3f:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c0102e42:	8b 55 c0             	mov    -0x40(%ebp),%edx
+c0102e45:	0f ab 10             	bts    %edx,(%eax)
+    base->property = n;
+c0102e48:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102e4b:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0102e4e:	89 50 08             	mov    %edx,0x8(%eax)
+
+    p = le2page(le,page_link) ;
+c0102e51:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102e54:	83 e8 0c             	sub    $0xc,%eax
+c0102e57:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if( base+n == p ){
+c0102e5a:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0102e5d:	89 d0                	mov    %edx,%eax
+c0102e5f:	c1 e0 02             	shl    $0x2,%eax
+c0102e62:	01 d0                	add    %edx,%eax
+c0102e64:	c1 e0 02             	shl    $0x2,%eax
+c0102e67:	89 c2                	mov    %eax,%edx
+c0102e69:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102e6c:	01 d0                	add    %edx,%eax
+c0102e6e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0102e71:	75 1e                	jne    c0102e91 <default_free_pages+0x1b8>
+      base->property += p->property;
+c0102e73:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102e76:	8b 50 08             	mov    0x8(%eax),%edx
+c0102e79:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102e7c:	8b 40 08             	mov    0x8(%eax),%eax
+c0102e7f:	01 c2                	add    %eax,%edx
+c0102e81:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102e84:	89 50 08             	mov    %edx,0x8(%eax)
+      p->property = 0;
+c0102e87:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102e8a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+    }
+    le = list_prev(&(base->page_link));
+c0102e91:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102e94:	83 c0 0c             	add    $0xc,%eax
+c0102e97:	89 45 b8             	mov    %eax,-0x48(%ebp)
+ * list_prev - get the previous entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_prev(list_entry_t *listelm) {
+    return listelm->prev;
+c0102e9a:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0102e9d:	8b 00                	mov    (%eax),%eax
+c0102e9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    p = le2page(le, page_link);
+c0102ea2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102ea5:	83 e8 0c             	sub    $0xc,%eax
+c0102ea8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(le!=&free_list && p==base-1){
+c0102eab:	81 7d f4 b0 89 11 c0 	cmpl   $0xc01189b0,-0xc(%ebp)
+c0102eb2:	74 57                	je     c0102f0b <default_free_pages+0x232>
+c0102eb4:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102eb7:	83 e8 14             	sub    $0x14,%eax
+c0102eba:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0102ebd:	75 4c                	jne    c0102f0b <default_free_pages+0x232>
+      while(le!=&free_list){
+c0102ebf:	eb 41                	jmp    c0102f02 <default_free_pages+0x229>
+        if(p->property){
+c0102ec1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102ec4:	8b 40 08             	mov    0x8(%eax),%eax
+c0102ec7:	85 c0                	test   %eax,%eax
+c0102ec9:	74 20                	je     c0102eeb <default_free_pages+0x212>
+          p->property += base->property;
+c0102ecb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102ece:	8b 50 08             	mov    0x8(%eax),%edx
+c0102ed1:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102ed4:	8b 40 08             	mov    0x8(%eax),%eax
+c0102ed7:	01 c2                	add    %eax,%edx
+c0102ed9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102edc:	89 50 08             	mov    %edx,0x8(%eax)
+          base->property = 0;
+c0102edf:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102ee2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+          break;
+c0102ee9:	eb 20                	jmp    c0102f0b <default_free_pages+0x232>
+c0102eeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102eee:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+c0102ef1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0102ef4:	8b 00                	mov    (%eax),%eax
+        }
+        le = list_prev(le);
+c0102ef6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        p = le2page(le,page_link);
+c0102ef9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102efc:	83 e8 0c             	sub    $0xc,%eax
+c0102eff:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      p->property = 0;
+    }
+    le = list_prev(&(base->page_link));
+    p = le2page(le, page_link);
+    if(le!=&free_list && p==base-1){
+      while(le!=&free_list){
+c0102f02:	81 7d f4 b0 89 11 c0 	cmpl   $0xc01189b0,-0xc(%ebp)
+c0102f09:	75 b6                	jne    c0102ec1 <default_free_pages+0x1e8>
+        le = list_prev(le);
+        p = le2page(le,page_link);
+      }
+    }
+
+    nr_free += n;
+c0102f0b:	8b 15 b8 89 11 c0    	mov    0xc01189b8,%edx
+c0102f11:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0102f14:	01 d0                	add    %edx,%eax
+c0102f16:	a3 b8 89 11 c0       	mov    %eax,0xc01189b8
+    return ;
+c0102f1b:	90                   	nop
+}
+c0102f1c:	c9                   	leave  
+c0102f1d:	c3                   	ret    
+
+c0102f1e <default_nr_free_pages>:
+
+static size_t
+default_nr_free_pages(void) {
+c0102f1e:	55                   	push   %ebp
+c0102f1f:	89 e5                	mov    %esp,%ebp
+    return nr_free;
+c0102f21:	a1 b8 89 11 c0       	mov    0xc01189b8,%eax
+}
+c0102f26:	5d                   	pop    %ebp
+c0102f27:	c3                   	ret    
+
+c0102f28 <basic_check>:
+
+static void
+basic_check(void) {
+c0102f28:	55                   	push   %ebp
+c0102f29:	89 e5                	mov    %esp,%ebp
+c0102f2b:	83 ec 48             	sub    $0x48,%esp
+    struct Page *p0, *p1, *p2;
+    p0 = p1 = p2 = NULL;
+c0102f2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0102f35:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102f38:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0102f3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102f3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    assert((p0 = alloc_page()) != NULL);
+c0102f41:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0102f48:	e8 85 0e 00 00       	call   c0103dd2 <alloc_pages>
+c0102f4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0102f50:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0102f54:	75 24                	jne    c0102f7a <basic_check+0x52>
+c0102f56:	c7 44 24 0c e4 67 10 	movl   $0xc01067e4,0xc(%esp)
+c0102f5d:	c0 
+c0102f5e:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0102f65:	c0 
+c0102f66:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
+c0102f6d:	00 
+c0102f6e:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0102f75:	e8 46 dd ff ff       	call   c0100cc0 <__panic>
+    assert((p1 = alloc_page()) != NULL);
+c0102f7a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0102f81:	e8 4c 0e 00 00       	call   c0103dd2 <alloc_pages>
+c0102f86:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0102f89:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0102f8d:	75 24                	jne    c0102fb3 <basic_check+0x8b>
+c0102f8f:	c7 44 24 0c 00 68 10 	movl   $0xc0106800,0xc(%esp)
+c0102f96:	c0 
+c0102f97:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0102f9e:	c0 
+c0102f9f:	c7 44 24 04 ad 00 00 	movl   $0xad,0x4(%esp)
+c0102fa6:	00 
+c0102fa7:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0102fae:	e8 0d dd ff ff       	call   c0100cc0 <__panic>
+    assert((p2 = alloc_page()) != NULL);
+c0102fb3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0102fba:	e8 13 0e 00 00       	call   c0103dd2 <alloc_pages>
+c0102fbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0102fc2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0102fc6:	75 24                	jne    c0102fec <basic_check+0xc4>
+c0102fc8:	c7 44 24 0c 1c 68 10 	movl   $0xc010681c,0xc(%esp)
+c0102fcf:	c0 
+c0102fd0:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0102fd7:	c0 
+c0102fd8:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
+c0102fdf:	00 
+c0102fe0:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0102fe7:	e8 d4 dc ff ff       	call   c0100cc0 <__panic>
+
+    assert(p0 != p1 && p0 != p2 && p1 != p2);
+c0102fec:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102fef:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0102ff2:	74 10                	je     c0103004 <basic_check+0xdc>
+c0102ff4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0102ff7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0102ffa:	74 08                	je     c0103004 <basic_check+0xdc>
+c0102ffc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0102fff:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0103002:	75 24                	jne    c0103028 <basic_check+0x100>
+c0103004:	c7 44 24 0c 38 68 10 	movl   $0xc0106838,0xc(%esp)
+c010300b:	c0 
+c010300c:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103013:	c0 
+c0103014:	c7 44 24 04 b0 00 00 	movl   $0xb0,0x4(%esp)
+c010301b:	00 
+c010301c:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103023:	e8 98 dc ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
+c0103028:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010302b:	89 04 24             	mov    %eax,(%esp)
+c010302e:	e8 94 f9 ff ff       	call   c01029c7 <page_ref>
+c0103033:	85 c0                	test   %eax,%eax
+c0103035:	75 1e                	jne    c0103055 <basic_check+0x12d>
+c0103037:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010303a:	89 04 24             	mov    %eax,(%esp)
+c010303d:	e8 85 f9 ff ff       	call   c01029c7 <page_ref>
+c0103042:	85 c0                	test   %eax,%eax
+c0103044:	75 0f                	jne    c0103055 <basic_check+0x12d>
+c0103046:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103049:	89 04 24             	mov    %eax,(%esp)
+c010304c:	e8 76 f9 ff ff       	call   c01029c7 <page_ref>
+c0103051:	85 c0                	test   %eax,%eax
+c0103053:	74 24                	je     c0103079 <basic_check+0x151>
+c0103055:	c7 44 24 0c 5c 68 10 	movl   $0xc010685c,0xc(%esp)
+c010305c:	c0 
+c010305d:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103064:	c0 
+c0103065:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
+c010306c:	00 
+c010306d:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103074:	e8 47 dc ff ff       	call   c0100cc0 <__panic>
+
+    assert(page2pa(p0) < npage * PGSIZE);
+c0103079:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010307c:	89 04 24             	mov    %eax,(%esp)
+c010307f:	e8 2d f9 ff ff       	call   c01029b1 <page2pa>
+c0103084:	8b 15 c0 88 11 c0    	mov    0xc01188c0,%edx
+c010308a:	c1 e2 0c             	shl    $0xc,%edx
+c010308d:	39 d0                	cmp    %edx,%eax
+c010308f:	72 24                	jb     c01030b5 <basic_check+0x18d>
+c0103091:	c7 44 24 0c 98 68 10 	movl   $0xc0106898,0xc(%esp)
+c0103098:	c0 
+c0103099:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01030a0:	c0 
+c01030a1:	c7 44 24 04 b3 00 00 	movl   $0xb3,0x4(%esp)
+c01030a8:	00 
+c01030a9:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01030b0:	e8 0b dc ff ff       	call   c0100cc0 <__panic>
+    assert(page2pa(p1) < npage * PGSIZE);
+c01030b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01030b8:	89 04 24             	mov    %eax,(%esp)
+c01030bb:	e8 f1 f8 ff ff       	call   c01029b1 <page2pa>
+c01030c0:	8b 15 c0 88 11 c0    	mov    0xc01188c0,%edx
+c01030c6:	c1 e2 0c             	shl    $0xc,%edx
+c01030c9:	39 d0                	cmp    %edx,%eax
+c01030cb:	72 24                	jb     c01030f1 <basic_check+0x1c9>
+c01030cd:	c7 44 24 0c b5 68 10 	movl   $0xc01068b5,0xc(%esp)
+c01030d4:	c0 
+c01030d5:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01030dc:	c0 
+c01030dd:	c7 44 24 04 b4 00 00 	movl   $0xb4,0x4(%esp)
+c01030e4:	00 
+c01030e5:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01030ec:	e8 cf db ff ff       	call   c0100cc0 <__panic>
+    assert(page2pa(p2) < npage * PGSIZE);
+c01030f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01030f4:	89 04 24             	mov    %eax,(%esp)
+c01030f7:	e8 b5 f8 ff ff       	call   c01029b1 <page2pa>
+c01030fc:	8b 15 c0 88 11 c0    	mov    0xc01188c0,%edx
+c0103102:	c1 e2 0c             	shl    $0xc,%edx
+c0103105:	39 d0                	cmp    %edx,%eax
+c0103107:	72 24                	jb     c010312d <basic_check+0x205>
+c0103109:	c7 44 24 0c d2 68 10 	movl   $0xc01068d2,0xc(%esp)
+c0103110:	c0 
+c0103111:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103118:	c0 
+c0103119:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
+c0103120:	00 
+c0103121:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103128:	e8 93 db ff ff       	call   c0100cc0 <__panic>
+
+    list_entry_t free_list_store = free_list;
+c010312d:	a1 b0 89 11 c0       	mov    0xc01189b0,%eax
+c0103132:	8b 15 b4 89 11 c0    	mov    0xc01189b4,%edx
+c0103138:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010313b:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c010313e:	c7 45 e0 b0 89 11 c0 	movl   $0xc01189b0,-0x20(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c0103145:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103148:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c010314b:	89 50 04             	mov    %edx,0x4(%eax)
+c010314e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103151:	8b 50 04             	mov    0x4(%eax),%edx
+c0103154:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103157:	89 10                	mov    %edx,(%eax)
+c0103159:	c7 45 dc b0 89 11 c0 	movl   $0xc01189b0,-0x24(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+c0103160:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0103163:	8b 40 04             	mov    0x4(%eax),%eax
+c0103166:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+c0103169:	0f 94 c0             	sete   %al
+c010316c:	0f b6 c0             	movzbl %al,%eax
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+c010316f:	85 c0                	test   %eax,%eax
+c0103171:	75 24                	jne    c0103197 <basic_check+0x26f>
+c0103173:	c7 44 24 0c ef 68 10 	movl   $0xc01068ef,0xc(%esp)
+c010317a:	c0 
+c010317b:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103182:	c0 
+c0103183:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
+c010318a:	00 
+c010318b:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103192:	e8 29 db ff ff       	call   c0100cc0 <__panic>
+
+    unsigned int nr_free_store = nr_free;
+c0103197:	a1 b8 89 11 c0       	mov    0xc01189b8,%eax
+c010319c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    nr_free = 0;
+c010319f:	c7 05 b8 89 11 c0 00 	movl   $0x0,0xc01189b8
+c01031a6:	00 00 00 
+
+    assert(alloc_page() == NULL);
+c01031a9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01031b0:	e8 1d 0c 00 00       	call   c0103dd2 <alloc_pages>
+c01031b5:	85 c0                	test   %eax,%eax
+c01031b7:	74 24                	je     c01031dd <basic_check+0x2b5>
+c01031b9:	c7 44 24 0c 06 69 10 	movl   $0xc0106906,0xc(%esp)
+c01031c0:	c0 
+c01031c1:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01031c8:	c0 
+c01031c9:	c7 44 24 04 be 00 00 	movl   $0xbe,0x4(%esp)
+c01031d0:	00 
+c01031d1:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01031d8:	e8 e3 da ff ff       	call   c0100cc0 <__panic>
+
+    free_page(p0);
+c01031dd:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01031e4:	00 
+c01031e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01031e8:	89 04 24             	mov    %eax,(%esp)
+c01031eb:	e8 1a 0c 00 00       	call   c0103e0a <free_pages>
+    free_page(p1);
+c01031f0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01031f7:	00 
+c01031f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01031fb:	89 04 24             	mov    %eax,(%esp)
+c01031fe:	e8 07 0c 00 00       	call   c0103e0a <free_pages>
+    free_page(p2);
+c0103203:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010320a:	00 
+c010320b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010320e:	89 04 24             	mov    %eax,(%esp)
+c0103211:	e8 f4 0b 00 00       	call   c0103e0a <free_pages>
+    assert(nr_free == 3);
+c0103216:	a1 b8 89 11 c0       	mov    0xc01189b8,%eax
+c010321b:	83 f8 03             	cmp    $0x3,%eax
+c010321e:	74 24                	je     c0103244 <basic_check+0x31c>
+c0103220:	c7 44 24 0c 1b 69 10 	movl   $0xc010691b,0xc(%esp)
+c0103227:	c0 
+c0103228:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c010322f:	c0 
+c0103230:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
+c0103237:	00 
+c0103238:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c010323f:	e8 7c da ff ff       	call   c0100cc0 <__panic>
+
+    assert((p0 = alloc_page()) != NULL);
+c0103244:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010324b:	e8 82 0b 00 00       	call   c0103dd2 <alloc_pages>
+c0103250:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0103253:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0103257:	75 24                	jne    c010327d <basic_check+0x355>
+c0103259:	c7 44 24 0c e4 67 10 	movl   $0xc01067e4,0xc(%esp)
+c0103260:	c0 
+c0103261:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103268:	c0 
+c0103269:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
+c0103270:	00 
+c0103271:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103278:	e8 43 da ff ff       	call   c0100cc0 <__panic>
+    assert((p1 = alloc_page()) != NULL);
+c010327d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0103284:	e8 49 0b 00 00       	call   c0103dd2 <alloc_pages>
+c0103289:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010328c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0103290:	75 24                	jne    c01032b6 <basic_check+0x38e>
+c0103292:	c7 44 24 0c 00 68 10 	movl   $0xc0106800,0xc(%esp)
+c0103299:	c0 
+c010329a:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01032a1:	c0 
+c01032a2:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
+c01032a9:	00 
+c01032aa:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01032b1:	e8 0a da ff ff       	call   c0100cc0 <__panic>
+    assert((p2 = alloc_page()) != NULL);
+c01032b6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01032bd:	e8 10 0b 00 00       	call   c0103dd2 <alloc_pages>
+c01032c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01032c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01032c9:	75 24                	jne    c01032ef <basic_check+0x3c7>
+c01032cb:	c7 44 24 0c 1c 68 10 	movl   $0xc010681c,0xc(%esp)
+c01032d2:	c0 
+c01032d3:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01032da:	c0 
+c01032db:	c7 44 24 04 c7 00 00 	movl   $0xc7,0x4(%esp)
+c01032e2:	00 
+c01032e3:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01032ea:	e8 d1 d9 ff ff       	call   c0100cc0 <__panic>
+
+    assert(alloc_page() == NULL);
+c01032ef:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01032f6:	e8 d7 0a 00 00       	call   c0103dd2 <alloc_pages>
+c01032fb:	85 c0                	test   %eax,%eax
+c01032fd:	74 24                	je     c0103323 <basic_check+0x3fb>
+c01032ff:	c7 44 24 0c 06 69 10 	movl   $0xc0106906,0xc(%esp)
+c0103306:	c0 
+c0103307:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c010330e:	c0 
+c010330f:	c7 44 24 04 c9 00 00 	movl   $0xc9,0x4(%esp)
+c0103316:	00 
+c0103317:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c010331e:	e8 9d d9 ff ff       	call   c0100cc0 <__panic>
+
+    free_page(p0);
+c0103323:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010332a:	00 
+c010332b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010332e:	89 04 24             	mov    %eax,(%esp)
+c0103331:	e8 d4 0a 00 00       	call   c0103e0a <free_pages>
+c0103336:	c7 45 d8 b0 89 11 c0 	movl   $0xc01189b0,-0x28(%ebp)
+c010333d:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0103340:	8b 40 04             	mov    0x4(%eax),%eax
+c0103343:	39 45 d8             	cmp    %eax,-0x28(%ebp)
+c0103346:	0f 94 c0             	sete   %al
+c0103349:	0f b6 c0             	movzbl %al,%eax
+    assert(!list_empty(&free_list));
+c010334c:	85 c0                	test   %eax,%eax
+c010334e:	74 24                	je     c0103374 <basic_check+0x44c>
+c0103350:	c7 44 24 0c 28 69 10 	movl   $0xc0106928,0xc(%esp)
+c0103357:	c0 
+c0103358:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c010335f:	c0 
+c0103360:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
+c0103367:	00 
+c0103368:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c010336f:	e8 4c d9 ff ff       	call   c0100cc0 <__panic>
+
+    struct Page *p;
+    assert((p = alloc_page()) == p0);
+c0103374:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010337b:	e8 52 0a 00 00       	call   c0103dd2 <alloc_pages>
+c0103380:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0103383:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0103386:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0103389:	74 24                	je     c01033af <basic_check+0x487>
+c010338b:	c7 44 24 0c 40 69 10 	movl   $0xc0106940,0xc(%esp)
+c0103392:	c0 
+c0103393:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c010339a:	c0 
+c010339b:	c7 44 24 04 cf 00 00 	movl   $0xcf,0x4(%esp)
+c01033a2:	00 
+c01033a3:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01033aa:	e8 11 d9 ff ff       	call   c0100cc0 <__panic>
+    assert(alloc_page() == NULL);
+c01033af:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01033b6:	e8 17 0a 00 00       	call   c0103dd2 <alloc_pages>
+c01033bb:	85 c0                	test   %eax,%eax
+c01033bd:	74 24                	je     c01033e3 <basic_check+0x4bb>
+c01033bf:	c7 44 24 0c 06 69 10 	movl   $0xc0106906,0xc(%esp)
+c01033c6:	c0 
+c01033c7:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01033ce:	c0 
+c01033cf:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
+c01033d6:	00 
+c01033d7:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01033de:	e8 dd d8 ff ff       	call   c0100cc0 <__panic>
+
+    assert(nr_free == 0);
+c01033e3:	a1 b8 89 11 c0       	mov    0xc01189b8,%eax
+c01033e8:	85 c0                	test   %eax,%eax
+c01033ea:	74 24                	je     c0103410 <basic_check+0x4e8>
+c01033ec:	c7 44 24 0c 59 69 10 	movl   $0xc0106959,0xc(%esp)
+c01033f3:	c0 
+c01033f4:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01033fb:	c0 
+c01033fc:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
+c0103403:	00 
+c0103404:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c010340b:	e8 b0 d8 ff ff       	call   c0100cc0 <__panic>
+    free_list = free_list_store;
+c0103410:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0103413:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0103416:	a3 b0 89 11 c0       	mov    %eax,0xc01189b0
+c010341b:	89 15 b4 89 11 c0    	mov    %edx,0xc01189b4
+    nr_free = nr_free_store;
+c0103421:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103424:	a3 b8 89 11 c0       	mov    %eax,0xc01189b8
+
+    free_page(p);
+c0103429:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0103430:	00 
+c0103431:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0103434:	89 04 24             	mov    %eax,(%esp)
+c0103437:	e8 ce 09 00 00       	call   c0103e0a <free_pages>
+    free_page(p1);
+c010343c:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0103443:	00 
+c0103444:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103447:	89 04 24             	mov    %eax,(%esp)
+c010344a:	e8 bb 09 00 00       	call   c0103e0a <free_pages>
+    free_page(p2);
+c010344f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0103456:	00 
+c0103457:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010345a:	89 04 24             	mov    %eax,(%esp)
+c010345d:	e8 a8 09 00 00       	call   c0103e0a <free_pages>
+}
+c0103462:	c9                   	leave  
+c0103463:	c3                   	ret    
+
+c0103464 <default_check>:
+
+// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+c0103464:	55                   	push   %ebp
+c0103465:	89 e5                	mov    %esp,%ebp
+c0103467:	53                   	push   %ebx
+c0103468:	81 ec 94 00 00 00    	sub    $0x94,%esp
+    int count = 0, total = 0;
+c010346e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0103475:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    list_entry_t *le = &free_list;
+c010347c:	c7 45 ec b0 89 11 c0 	movl   $0xc01189b0,-0x14(%ebp)
+    while ((le = list_next(le)) != &free_list) {
+c0103483:	eb 6b                	jmp    c01034f0 <default_check+0x8c>
+        struct Page *p = le2page(le, page_link);
+c0103485:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103488:	83 e8 0c             	sub    $0xc,%eax
+c010348b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        assert(PageProperty(p));
+c010348e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103491:	83 c0 04             	add    $0x4,%eax
+c0103494:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
+c010349b:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c010349e:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c01034a1:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c01034a4:	0f a3 10             	bt     %edx,(%eax)
+c01034a7:	19 c0                	sbb    %eax,%eax
+c01034a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
+    return oldbit != 0;
+c01034ac:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
+c01034b0:	0f 95 c0             	setne  %al
+c01034b3:	0f b6 c0             	movzbl %al,%eax
+c01034b6:	85 c0                	test   %eax,%eax
+c01034b8:	75 24                	jne    c01034de <default_check+0x7a>
+c01034ba:	c7 44 24 0c 66 69 10 	movl   $0xc0106966,0xc(%esp)
+c01034c1:	c0 
+c01034c2:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01034c9:	c0 
+c01034ca:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
+c01034d1:	00 
+c01034d2:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01034d9:	e8 e2 d7 ff ff       	call   c0100cc0 <__panic>
+        count ++, total += p->property;
+c01034de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+c01034e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01034e5:	8b 50 08             	mov    0x8(%eax),%edx
+c01034e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01034eb:	01 d0                	add    %edx,%eax
+c01034ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01034f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01034f3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c01034f6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c01034f9:	8b 40 04             	mov    0x4(%eax),%eax
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+    int count = 0, total = 0;
+    list_entry_t *le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+c01034fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01034ff:	81 7d ec b0 89 11 c0 	cmpl   $0xc01189b0,-0x14(%ebp)
+c0103506:	0f 85 79 ff ff ff    	jne    c0103485 <default_check+0x21>
+        struct Page *p = le2page(le, page_link);
+        assert(PageProperty(p));
+        count ++, total += p->property;
+    }
+    assert(total == nr_free_pages());
+c010350c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
+c010350f:	e8 28 09 00 00       	call   c0103e3c <nr_free_pages>
+c0103514:	39 c3                	cmp    %eax,%ebx
+c0103516:	74 24                	je     c010353c <default_check+0xd8>
+c0103518:	c7 44 24 0c 76 69 10 	movl   $0xc0106976,0xc(%esp)
+c010351f:	c0 
+c0103520:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103527:	c0 
+c0103528:	c7 44 24 04 e6 00 00 	movl   $0xe6,0x4(%esp)
+c010352f:	00 
+c0103530:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103537:	e8 84 d7 ff ff       	call   c0100cc0 <__panic>
+
+    basic_check();
+c010353c:	e8 e7 f9 ff ff       	call   c0102f28 <basic_check>
+
+    struct Page *p0 = alloc_pages(5), *p1, *p2;
+c0103541:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
+c0103548:	e8 85 08 00 00       	call   c0103dd2 <alloc_pages>
+c010354d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    assert(p0 != NULL);
+c0103550:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0103554:	75 24                	jne    c010357a <default_check+0x116>
+c0103556:	c7 44 24 0c 8f 69 10 	movl   $0xc010698f,0xc(%esp)
+c010355d:	c0 
+c010355e:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103565:	c0 
+c0103566:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
+c010356d:	00 
+c010356e:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103575:	e8 46 d7 ff ff       	call   c0100cc0 <__panic>
+    assert(!PageProperty(p0));
+c010357a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010357d:	83 c0 04             	add    $0x4,%eax
+c0103580:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%ebp)
+c0103587:	89 45 bc             	mov    %eax,-0x44(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c010358a:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c010358d:	8b 55 c0             	mov    -0x40(%ebp),%edx
+c0103590:	0f a3 10             	bt     %edx,(%eax)
+c0103593:	19 c0                	sbb    %eax,%eax
+c0103595:	89 45 b8             	mov    %eax,-0x48(%ebp)
+    return oldbit != 0;
+c0103598:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+c010359c:	0f 95 c0             	setne  %al
+c010359f:	0f b6 c0             	movzbl %al,%eax
+c01035a2:	85 c0                	test   %eax,%eax
+c01035a4:	74 24                	je     c01035ca <default_check+0x166>
+c01035a6:	c7 44 24 0c 9a 69 10 	movl   $0xc010699a,0xc(%esp)
+c01035ad:	c0 
+c01035ae:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01035b5:	c0 
+c01035b6:	c7 44 24 04 ec 00 00 	movl   $0xec,0x4(%esp)
+c01035bd:	00 
+c01035be:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01035c5:	e8 f6 d6 ff ff       	call   c0100cc0 <__panic>
+
+    list_entry_t free_list_store = free_list;
+c01035ca:	a1 b0 89 11 c0       	mov    0xc01189b0,%eax
+c01035cf:	8b 15 b4 89 11 c0    	mov    0xc01189b4,%edx
+c01035d5:	89 45 80             	mov    %eax,-0x80(%ebp)
+c01035d8:	89 55 84             	mov    %edx,-0x7c(%ebp)
+c01035db:	c7 45 b4 b0 89 11 c0 	movl   $0xc01189b0,-0x4c(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+c01035e2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c01035e5:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+c01035e8:	89 50 04             	mov    %edx,0x4(%eax)
+c01035eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c01035ee:	8b 50 04             	mov    0x4(%eax),%edx
+c01035f1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c01035f4:	89 10                	mov    %edx,(%eax)
+c01035f6:	c7 45 b0 b0 89 11 c0 	movl   $0xc01189b0,-0x50(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+c01035fd:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0103600:	8b 40 04             	mov    0x4(%eax),%eax
+c0103603:	39 45 b0             	cmp    %eax,-0x50(%ebp)
+c0103606:	0f 94 c0             	sete   %al
+c0103609:	0f b6 c0             	movzbl %al,%eax
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+c010360c:	85 c0                	test   %eax,%eax
+c010360e:	75 24                	jne    c0103634 <default_check+0x1d0>
+c0103610:	c7 44 24 0c ef 68 10 	movl   $0xc01068ef,0xc(%esp)
+c0103617:	c0 
+c0103618:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c010361f:	c0 
+c0103620:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
+c0103627:	00 
+c0103628:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c010362f:	e8 8c d6 ff ff       	call   c0100cc0 <__panic>
+    assert(alloc_page() == NULL);
+c0103634:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010363b:	e8 92 07 00 00       	call   c0103dd2 <alloc_pages>
+c0103640:	85 c0                	test   %eax,%eax
+c0103642:	74 24                	je     c0103668 <default_check+0x204>
+c0103644:	c7 44 24 0c 06 69 10 	movl   $0xc0106906,0xc(%esp)
+c010364b:	c0 
+c010364c:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103653:	c0 
+c0103654:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
+c010365b:	00 
+c010365c:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103663:	e8 58 d6 ff ff       	call   c0100cc0 <__panic>
+
+    unsigned int nr_free_store = nr_free;
+c0103668:	a1 b8 89 11 c0       	mov    0xc01189b8,%eax
+c010366d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    nr_free = 0;
+c0103670:	c7 05 b8 89 11 c0 00 	movl   $0x0,0xc01189b8
+c0103677:	00 00 00 
+
+    free_pages(p0 + 2, 3);
+c010367a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010367d:	83 c0 28             	add    $0x28,%eax
+c0103680:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+c0103687:	00 
+c0103688:	89 04 24             	mov    %eax,(%esp)
+c010368b:	e8 7a 07 00 00       	call   c0103e0a <free_pages>
+    assert(alloc_pages(4) == NULL);
+c0103690:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+c0103697:	e8 36 07 00 00       	call   c0103dd2 <alloc_pages>
+c010369c:	85 c0                	test   %eax,%eax
+c010369e:	74 24                	je     c01036c4 <default_check+0x260>
+c01036a0:	c7 44 24 0c ac 69 10 	movl   $0xc01069ac,0xc(%esp)
+c01036a7:	c0 
+c01036a8:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01036af:	c0 
+c01036b0:	c7 44 24 04 f7 00 00 	movl   $0xf7,0x4(%esp)
+c01036b7:	00 
+c01036b8:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01036bf:	e8 fc d5 ff ff       	call   c0100cc0 <__panic>
+    assert(PageProperty(p0 + 2) && p0[2].property == 3);
+c01036c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01036c7:	83 c0 28             	add    $0x28,%eax
+c01036ca:	83 c0 04             	add    $0x4,%eax
+c01036cd:	c7 45 ac 01 00 00 00 	movl   $0x1,-0x54(%ebp)
+c01036d4:	89 45 a8             	mov    %eax,-0x58(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c01036d7:	8b 45 a8             	mov    -0x58(%ebp),%eax
+c01036da:	8b 55 ac             	mov    -0x54(%ebp),%edx
+c01036dd:	0f a3 10             	bt     %edx,(%eax)
+c01036e0:	19 c0                	sbb    %eax,%eax
+c01036e2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+    return oldbit != 0;
+c01036e5:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
+c01036e9:	0f 95 c0             	setne  %al
+c01036ec:	0f b6 c0             	movzbl %al,%eax
+c01036ef:	85 c0                	test   %eax,%eax
+c01036f1:	74 0e                	je     c0103701 <default_check+0x29d>
+c01036f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01036f6:	83 c0 28             	add    $0x28,%eax
+c01036f9:	8b 40 08             	mov    0x8(%eax),%eax
+c01036fc:	83 f8 03             	cmp    $0x3,%eax
+c01036ff:	74 24                	je     c0103725 <default_check+0x2c1>
+c0103701:	c7 44 24 0c c4 69 10 	movl   $0xc01069c4,0xc(%esp)
+c0103708:	c0 
+c0103709:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103710:	c0 
+c0103711:	c7 44 24 04 f8 00 00 	movl   $0xf8,0x4(%esp)
+c0103718:	00 
+c0103719:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103720:	e8 9b d5 ff ff       	call   c0100cc0 <__panic>
+    assert((p1 = alloc_pages(3)) != NULL);
+c0103725:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+c010372c:	e8 a1 06 00 00       	call   c0103dd2 <alloc_pages>
+c0103731:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0103734:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c0103738:	75 24                	jne    c010375e <default_check+0x2fa>
+c010373a:	c7 44 24 0c f0 69 10 	movl   $0xc01069f0,0xc(%esp)
+c0103741:	c0 
+c0103742:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103749:	c0 
+c010374a:	c7 44 24 04 f9 00 00 	movl   $0xf9,0x4(%esp)
+c0103751:	00 
+c0103752:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103759:	e8 62 d5 ff ff       	call   c0100cc0 <__panic>
+    assert(alloc_page() == NULL);
+c010375e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0103765:	e8 68 06 00 00       	call   c0103dd2 <alloc_pages>
+c010376a:	85 c0                	test   %eax,%eax
+c010376c:	74 24                	je     c0103792 <default_check+0x32e>
+c010376e:	c7 44 24 0c 06 69 10 	movl   $0xc0106906,0xc(%esp)
+c0103775:	c0 
+c0103776:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c010377d:	c0 
+c010377e:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
+c0103785:	00 
+c0103786:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c010378d:	e8 2e d5 ff ff       	call   c0100cc0 <__panic>
+    assert(p0 + 2 == p1);
+c0103792:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0103795:	83 c0 28             	add    $0x28,%eax
+c0103798:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+c010379b:	74 24                	je     c01037c1 <default_check+0x35d>
+c010379d:	c7 44 24 0c 0e 6a 10 	movl   $0xc0106a0e,0xc(%esp)
+c01037a4:	c0 
+c01037a5:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01037ac:	c0 
+c01037ad:	c7 44 24 04 fb 00 00 	movl   $0xfb,0x4(%esp)
+c01037b4:	00 
+c01037b5:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01037bc:	e8 ff d4 ff ff       	call   c0100cc0 <__panic>
+
+    p2 = p0 + 1;
+c01037c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01037c4:	83 c0 14             	add    $0x14,%eax
+c01037c7:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    free_page(p0);
+c01037ca:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01037d1:	00 
+c01037d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01037d5:	89 04 24             	mov    %eax,(%esp)
+c01037d8:	e8 2d 06 00 00       	call   c0103e0a <free_pages>
+    free_pages(p1, 3);
+c01037dd:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+c01037e4:	00 
+c01037e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01037e8:	89 04 24             	mov    %eax,(%esp)
+c01037eb:	e8 1a 06 00 00       	call   c0103e0a <free_pages>
+    assert(PageProperty(p0) && p0->property == 1);
+c01037f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01037f3:	83 c0 04             	add    $0x4,%eax
+c01037f6:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
+c01037fd:	89 45 9c             	mov    %eax,-0x64(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c0103800:	8b 45 9c             	mov    -0x64(%ebp),%eax
+c0103803:	8b 55 a0             	mov    -0x60(%ebp),%edx
+c0103806:	0f a3 10             	bt     %edx,(%eax)
+c0103809:	19 c0                	sbb    %eax,%eax
+c010380b:	89 45 98             	mov    %eax,-0x68(%ebp)
+    return oldbit != 0;
+c010380e:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
+c0103812:	0f 95 c0             	setne  %al
+c0103815:	0f b6 c0             	movzbl %al,%eax
+c0103818:	85 c0                	test   %eax,%eax
+c010381a:	74 0b                	je     c0103827 <default_check+0x3c3>
+c010381c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010381f:	8b 40 08             	mov    0x8(%eax),%eax
+c0103822:	83 f8 01             	cmp    $0x1,%eax
+c0103825:	74 24                	je     c010384b <default_check+0x3e7>
+c0103827:	c7 44 24 0c 1c 6a 10 	movl   $0xc0106a1c,0xc(%esp)
+c010382e:	c0 
+c010382f:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103836:	c0 
+c0103837:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
+c010383e:	00 
+c010383f:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103846:	e8 75 d4 ff ff       	call   c0100cc0 <__panic>
+    assert(PageProperty(p1) && p1->property == 3);
+c010384b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010384e:	83 c0 04             	add    $0x4,%eax
+c0103851:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
+c0103858:	89 45 90             	mov    %eax,-0x70(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+c010385b:	8b 45 90             	mov    -0x70(%ebp),%eax
+c010385e:	8b 55 94             	mov    -0x6c(%ebp),%edx
+c0103861:	0f a3 10             	bt     %edx,(%eax)
+c0103864:	19 c0                	sbb    %eax,%eax
+c0103866:	89 45 8c             	mov    %eax,-0x74(%ebp)
+    return oldbit != 0;
+c0103869:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
+c010386d:	0f 95 c0             	setne  %al
+c0103870:	0f b6 c0             	movzbl %al,%eax
+c0103873:	85 c0                	test   %eax,%eax
+c0103875:	74 0b                	je     c0103882 <default_check+0x41e>
+c0103877:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010387a:	8b 40 08             	mov    0x8(%eax),%eax
+c010387d:	83 f8 03             	cmp    $0x3,%eax
+c0103880:	74 24                	je     c01038a6 <default_check+0x442>
+c0103882:	c7 44 24 0c 44 6a 10 	movl   $0xc0106a44,0xc(%esp)
+c0103889:	c0 
+c010388a:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103891:	c0 
+c0103892:	c7 44 24 04 01 01 00 	movl   $0x101,0x4(%esp)
+c0103899:	00 
+c010389a:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01038a1:	e8 1a d4 ff ff       	call   c0100cc0 <__panic>
+
+    assert((p0 = alloc_page()) == p2 - 1);
+c01038a6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01038ad:	e8 20 05 00 00       	call   c0103dd2 <alloc_pages>
+c01038b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01038b5:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01038b8:	83 e8 14             	sub    $0x14,%eax
+c01038bb:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+c01038be:	74 24                	je     c01038e4 <default_check+0x480>
+c01038c0:	c7 44 24 0c 6a 6a 10 	movl   $0xc0106a6a,0xc(%esp)
+c01038c7:	c0 
+c01038c8:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01038cf:	c0 
+c01038d0:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
+c01038d7:	00 
+c01038d8:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01038df:	e8 dc d3 ff ff       	call   c0100cc0 <__panic>
+    free_page(p0);
+c01038e4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01038eb:	00 
+c01038ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01038ef:	89 04 24             	mov    %eax,(%esp)
+c01038f2:	e8 13 05 00 00       	call   c0103e0a <free_pages>
+    assert((p0 = alloc_pages(2)) == p2 + 1);
+c01038f7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+c01038fe:	e8 cf 04 00 00       	call   c0103dd2 <alloc_pages>
+c0103903:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0103906:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0103909:	83 c0 14             	add    $0x14,%eax
+c010390c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+c010390f:	74 24                	je     c0103935 <default_check+0x4d1>
+c0103911:	c7 44 24 0c 88 6a 10 	movl   $0xc0106a88,0xc(%esp)
+c0103918:	c0 
+c0103919:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103920:	c0 
+c0103921:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
+c0103928:	00 
+c0103929:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103930:	e8 8b d3 ff ff       	call   c0100cc0 <__panic>
+
+    free_pages(p0, 2);
+c0103935:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+c010393c:	00 
+c010393d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0103940:	89 04 24             	mov    %eax,(%esp)
+c0103943:	e8 c2 04 00 00       	call   c0103e0a <free_pages>
+    free_page(p2);
+c0103948:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010394f:	00 
+c0103950:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0103953:	89 04 24             	mov    %eax,(%esp)
+c0103956:	e8 af 04 00 00       	call   c0103e0a <free_pages>
+
+    assert((p0 = alloc_pages(5)) != NULL);
+c010395b:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
+c0103962:	e8 6b 04 00 00       	call   c0103dd2 <alloc_pages>
+c0103967:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010396a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c010396e:	75 24                	jne    c0103994 <default_check+0x530>
+c0103970:	c7 44 24 0c a8 6a 10 	movl   $0xc0106aa8,0xc(%esp)
+c0103977:	c0 
+c0103978:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c010397f:	c0 
+c0103980:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
+c0103987:	00 
+c0103988:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c010398f:	e8 2c d3 ff ff       	call   c0100cc0 <__panic>
+    assert(alloc_page() == NULL);
+c0103994:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010399b:	e8 32 04 00 00       	call   c0103dd2 <alloc_pages>
+c01039a0:	85 c0                	test   %eax,%eax
+c01039a2:	74 24                	je     c01039c8 <default_check+0x564>
+c01039a4:	c7 44 24 0c 06 69 10 	movl   $0xc0106906,0xc(%esp)
+c01039ab:	c0 
+c01039ac:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01039b3:	c0 
+c01039b4:	c7 44 24 04 0b 01 00 	movl   $0x10b,0x4(%esp)
+c01039bb:	00 
+c01039bc:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01039c3:	e8 f8 d2 ff ff       	call   c0100cc0 <__panic>
+
+    assert(nr_free == 0);
+c01039c8:	a1 b8 89 11 c0       	mov    0xc01189b8,%eax
+c01039cd:	85 c0                	test   %eax,%eax
+c01039cf:	74 24                	je     c01039f5 <default_check+0x591>
+c01039d1:	c7 44 24 0c 59 69 10 	movl   $0xc0106959,0xc(%esp)
+c01039d8:	c0 
+c01039d9:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c01039e0:	c0 
+c01039e1:	c7 44 24 04 0d 01 00 	movl   $0x10d,0x4(%esp)
+c01039e8:	00 
+c01039e9:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c01039f0:	e8 cb d2 ff ff       	call   c0100cc0 <__panic>
+    nr_free = nr_free_store;
+c01039f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01039f8:	a3 b8 89 11 c0       	mov    %eax,0xc01189b8
+
+    free_list = free_list_store;
+c01039fd:	8b 45 80             	mov    -0x80(%ebp),%eax
+c0103a00:	8b 55 84             	mov    -0x7c(%ebp),%edx
+c0103a03:	a3 b0 89 11 c0       	mov    %eax,0xc01189b0
+c0103a08:	89 15 b4 89 11 c0    	mov    %edx,0xc01189b4
+    free_pages(p0, 5);
+c0103a0e:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
+c0103a15:	00 
+c0103a16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0103a19:	89 04 24             	mov    %eax,(%esp)
+c0103a1c:	e8 e9 03 00 00       	call   c0103e0a <free_pages>
+
+    le = &free_list;
+c0103a21:	c7 45 ec b0 89 11 c0 	movl   $0xc01189b0,-0x14(%ebp)
+    while ((le = list_next(le)) != &free_list) {
+c0103a28:	eb 1d                	jmp    c0103a47 <default_check+0x5e3>
+        struct Page *p = le2page(le, page_link);
+c0103a2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103a2d:	83 e8 0c             	sub    $0xc,%eax
+c0103a30:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        count --, total -= p->property;
+c0103a33:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c0103a37:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0103a3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0103a3d:	8b 40 08             	mov    0x8(%eax),%eax
+c0103a40:	29 c2                	sub    %eax,%edx
+c0103a42:	89 d0                	mov    %edx,%eax
+c0103a44:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103a47:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103a4a:	89 45 88             	mov    %eax,-0x78(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+c0103a4d:	8b 45 88             	mov    -0x78(%ebp),%eax
+c0103a50:	8b 40 04             	mov    0x4(%eax),%eax
+
+    free_list = free_list_store;
+    free_pages(p0, 5);
+
+    le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+c0103a53:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0103a56:	81 7d ec b0 89 11 c0 	cmpl   $0xc01189b0,-0x14(%ebp)
+c0103a5d:	75 cb                	jne    c0103a2a <default_check+0x5c6>
+        struct Page *p = le2page(le, page_link);
+        count --, total -= p->property;
+    }
+    assert(count == 0);
+c0103a5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103a63:	74 24                	je     c0103a89 <default_check+0x625>
+c0103a65:	c7 44 24 0c c6 6a 10 	movl   $0xc0106ac6,0xc(%esp)
+c0103a6c:	c0 
+c0103a6d:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103a74:	c0 
+c0103a75:	c7 44 24 04 18 01 00 	movl   $0x118,0x4(%esp)
+c0103a7c:	00 
+c0103a7d:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103a84:	e8 37 d2 ff ff       	call   c0100cc0 <__panic>
+    assert(total == 0);
+c0103a89:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0103a8d:	74 24                	je     c0103ab3 <default_check+0x64f>
+c0103a8f:	c7 44 24 0c d1 6a 10 	movl   $0xc0106ad1,0xc(%esp)
+c0103a96:	c0 
+c0103a97:	c7 44 24 08 96 67 10 	movl   $0xc0106796,0x8(%esp)
+c0103a9e:	c0 
+c0103a9f:	c7 44 24 04 19 01 00 	movl   $0x119,0x4(%esp)
+c0103aa6:	00 
+c0103aa7:	c7 04 24 ab 67 10 c0 	movl   $0xc01067ab,(%esp)
+c0103aae:	e8 0d d2 ff ff       	call   c0100cc0 <__panic>
+}
+c0103ab3:	81 c4 94 00 00 00    	add    $0x94,%esp
+c0103ab9:	5b                   	pop    %ebx
+c0103aba:	5d                   	pop    %ebp
+c0103abb:	c3                   	ret    
+
+c0103abc <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+c0103abc:	55                   	push   %ebp
+c0103abd:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+c0103abf:	8b 55 08             	mov    0x8(%ebp),%edx
+c0103ac2:	a1 c4 89 11 c0       	mov    0xc01189c4,%eax
+c0103ac7:	29 c2                	sub    %eax,%edx
+c0103ac9:	89 d0                	mov    %edx,%eax
+c0103acb:	c1 f8 02             	sar    $0x2,%eax
+c0103ace:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
+}
+c0103ad4:	5d                   	pop    %ebp
+c0103ad5:	c3                   	ret    
+
+c0103ad6 <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+c0103ad6:	55                   	push   %ebp
+c0103ad7:	89 e5                	mov    %esp,%ebp
+c0103ad9:	83 ec 04             	sub    $0x4,%esp
+    return page2ppn(page) << PGSHIFT;
+c0103adc:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103adf:	89 04 24             	mov    %eax,(%esp)
+c0103ae2:	e8 d5 ff ff ff       	call   c0103abc <page2ppn>
+c0103ae7:	c1 e0 0c             	shl    $0xc,%eax
+}
+c0103aea:	c9                   	leave  
+c0103aeb:	c3                   	ret    
+
+c0103aec <pa2page>:
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+c0103aec:	55                   	push   %ebp
+c0103aed:	89 e5                	mov    %esp,%ebp
+c0103aef:	83 ec 18             	sub    $0x18,%esp
+    if (PPN(pa) >= npage) {
+c0103af2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103af5:	c1 e8 0c             	shr    $0xc,%eax
+c0103af8:	89 c2                	mov    %eax,%edx
+c0103afa:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0103aff:	39 c2                	cmp    %eax,%edx
+c0103b01:	72 1c                	jb     c0103b1f <pa2page+0x33>
+        panic("pa2page called with invalid pa");
+c0103b03:	c7 44 24 08 0c 6b 10 	movl   $0xc0106b0c,0x8(%esp)
+c0103b0a:	c0 
+c0103b0b:	c7 44 24 04 5a 00 00 	movl   $0x5a,0x4(%esp)
+c0103b12:	00 
+c0103b13:	c7 04 24 2b 6b 10 c0 	movl   $0xc0106b2b,(%esp)
+c0103b1a:	e8 a1 d1 ff ff       	call   c0100cc0 <__panic>
+    }
+    return &pages[PPN(pa)];
+c0103b1f:	8b 0d c4 89 11 c0    	mov    0xc01189c4,%ecx
+c0103b25:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103b28:	c1 e8 0c             	shr    $0xc,%eax
+c0103b2b:	89 c2                	mov    %eax,%edx
+c0103b2d:	89 d0                	mov    %edx,%eax
+c0103b2f:	c1 e0 02             	shl    $0x2,%eax
+c0103b32:	01 d0                	add    %edx,%eax
+c0103b34:	c1 e0 02             	shl    $0x2,%eax
+c0103b37:	01 c8                	add    %ecx,%eax
+}
+c0103b39:	c9                   	leave  
+c0103b3a:	c3                   	ret    
+
+c0103b3b <page2kva>:
+
+static inline void *
+page2kva(struct Page *page) {
+c0103b3b:	55                   	push   %ebp
+c0103b3c:	89 e5                	mov    %esp,%ebp
+c0103b3e:	83 ec 28             	sub    $0x28,%esp
+    return KADDR(page2pa(page));
+c0103b41:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103b44:	89 04 24             	mov    %eax,(%esp)
+c0103b47:	e8 8a ff ff ff       	call   c0103ad6 <page2pa>
+c0103b4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103b52:	c1 e8 0c             	shr    $0xc,%eax
+c0103b55:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103b58:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0103b5d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c0103b60:	72 23                	jb     c0103b85 <page2kva+0x4a>
+c0103b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103b65:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0103b69:	c7 44 24 08 3c 6b 10 	movl   $0xc0106b3c,0x8(%esp)
+c0103b70:	c0 
+c0103b71:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
+c0103b78:	00 
+c0103b79:	c7 04 24 2b 6b 10 c0 	movl   $0xc0106b2b,(%esp)
+c0103b80:	e8 3b d1 ff ff       	call   c0100cc0 <__panic>
+c0103b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103b88:	2d 00 00 00 40       	sub    $0x40000000,%eax
+}
+c0103b8d:	c9                   	leave  
+c0103b8e:	c3                   	ret    
+
+c0103b8f <pte2page>:
+kva2page(void *kva) {
+    return pa2page(PADDR(kva));
+}
+
+static inline struct Page *
+pte2page(pte_t pte) {
+c0103b8f:	55                   	push   %ebp
+c0103b90:	89 e5                	mov    %esp,%ebp
+c0103b92:	83 ec 18             	sub    $0x18,%esp
+    if (!(pte & PTE_P)) {
+c0103b95:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103b98:	83 e0 01             	and    $0x1,%eax
+c0103b9b:	85 c0                	test   %eax,%eax
+c0103b9d:	75 1c                	jne    c0103bbb <pte2page+0x2c>
+        panic("pte2page called with invalid pte");
+c0103b9f:	c7 44 24 08 60 6b 10 	movl   $0xc0106b60,0x8(%esp)
+c0103ba6:	c0 
+c0103ba7:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
+c0103bae:	00 
+c0103baf:	c7 04 24 2b 6b 10 c0 	movl   $0xc0106b2b,(%esp)
+c0103bb6:	e8 05 d1 ff ff       	call   c0100cc0 <__panic>
+    }
+    return pa2page(PTE_ADDR(pte));
+c0103bbb:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103bbe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0103bc3:	89 04 24             	mov    %eax,(%esp)
+c0103bc6:	e8 21 ff ff ff       	call   c0103aec <pa2page>
+}
+c0103bcb:	c9                   	leave  
+c0103bcc:	c3                   	ret    
+
+c0103bcd <page_ref>:
+pde2page(pde_t pde) {
+    return pa2page(PDE_ADDR(pde));
+}
+
+static inline int
+page_ref(struct Page *page) {
+c0103bcd:	55                   	push   %ebp
+c0103bce:	89 e5                	mov    %esp,%ebp
+    return page->ref;
+c0103bd0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103bd3:	8b 00                	mov    (%eax),%eax
+}
+c0103bd5:	5d                   	pop    %ebp
+c0103bd6:	c3                   	ret    
+
+c0103bd7 <set_page_ref>:
+
+static inline void
+set_page_ref(struct Page *page, int val) {
+c0103bd7:	55                   	push   %ebp
+c0103bd8:	89 e5                	mov    %esp,%ebp
+    page->ref = val;
+c0103bda:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103bdd:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0103be0:	89 10                	mov    %edx,(%eax)
+}
+c0103be2:	5d                   	pop    %ebp
+c0103be3:	c3                   	ret    
+
+c0103be4 <page_ref_inc>:
+
+static inline int
+page_ref_inc(struct Page *page) {
+c0103be4:	55                   	push   %ebp
+c0103be5:	89 e5                	mov    %esp,%ebp
+    page->ref += 1;
+c0103be7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103bea:	8b 00                	mov    (%eax),%eax
+c0103bec:	8d 50 01             	lea    0x1(%eax),%edx
+c0103bef:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103bf2:	89 10                	mov    %edx,(%eax)
+    return page->ref;
+c0103bf4:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103bf7:	8b 00                	mov    (%eax),%eax
+}
+c0103bf9:	5d                   	pop    %ebp
+c0103bfa:	c3                   	ret    
+
+c0103bfb <page_ref_dec>:
+
+static inline int
+page_ref_dec(struct Page *page) {
+c0103bfb:	55                   	push   %ebp
+c0103bfc:	89 e5                	mov    %esp,%ebp
+    page->ref -= 1;
+c0103bfe:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103c01:	8b 00                	mov    (%eax),%eax
+c0103c03:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0103c06:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103c09:	89 10                	mov    %edx,(%eax)
+    return page->ref;
+c0103c0b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103c0e:	8b 00                	mov    (%eax),%eax
+}
+c0103c10:	5d                   	pop    %ebp
+c0103c11:	c3                   	ret    
+
+c0103c12 <__intr_save>:
+#include <x86.h>
+#include <intr.h>
+#include <mmu.h>
+
+static inline bool
+__intr_save(void) {
+c0103c12:	55                   	push   %ebp
+c0103c13:	89 e5                	mov    %esp,%ebp
+c0103c15:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+c0103c18:	9c                   	pushf  
+c0103c19:	58                   	pop    %eax
+c0103c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+c0103c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+c0103c20:	25 00 02 00 00       	and    $0x200,%eax
+c0103c25:	85 c0                	test   %eax,%eax
+c0103c27:	74 0c                	je     c0103c35 <__intr_save+0x23>
+        intr_disable();
+c0103c29:	e8 75 da ff ff       	call   c01016a3 <intr_disable>
+        return 1;
+c0103c2e:	b8 01 00 00 00       	mov    $0x1,%eax
+c0103c33:	eb 05                	jmp    c0103c3a <__intr_save+0x28>
+    }
+    return 0;
+c0103c35:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0103c3a:	c9                   	leave  
+c0103c3b:	c3                   	ret    
+
+c0103c3c <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+c0103c3c:	55                   	push   %ebp
+c0103c3d:	89 e5                	mov    %esp,%ebp
+c0103c3f:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+c0103c42:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0103c46:	74 05                	je     c0103c4d <__intr_restore+0x11>
+        intr_enable();
+c0103c48:	e8 50 da ff ff       	call   c010169d <intr_enable>
+    }
+}
+c0103c4d:	c9                   	leave  
+c0103c4e:	c3                   	ret    
+
+c0103c4f <lgdt>:
+/* *
+ * lgdt - load the global descriptor table register and reset the
+ * data/code segement registers for kernel.
+ * */
+static inline void
+lgdt(struct pseudodesc *pd) {
+c0103c4f:	55                   	push   %ebp
+c0103c50:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lgdt (%0)" :: "r" (pd));
+c0103c52:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103c55:	0f 01 10             	lgdtl  (%eax)
+    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
+c0103c58:	b8 23 00 00 00       	mov    $0x23,%eax
+c0103c5d:	8e e8                	mov    %eax,%gs
+    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
+c0103c5f:	b8 23 00 00 00       	mov    $0x23,%eax
+c0103c64:	8e e0                	mov    %eax,%fs
+    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
+c0103c66:	b8 10 00 00 00       	mov    $0x10,%eax
+c0103c6b:	8e c0                	mov    %eax,%es
+    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
+c0103c6d:	b8 10 00 00 00       	mov    $0x10,%eax
+c0103c72:	8e d8                	mov    %eax,%ds
+    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+c0103c74:	b8 10 00 00 00       	mov    $0x10,%eax
+c0103c79:	8e d0                	mov    %eax,%ss
+    // reload cs
+    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+c0103c7b:	ea 82 3c 10 c0 08 00 	ljmp   $0x8,$0xc0103c82
+}
+c0103c82:	5d                   	pop    %ebp
+c0103c83:	c3                   	ret    
+
+c0103c84 <load_esp0>:
+ * load_esp0 - change the ESP0 in default task state segment,
+ * so that we can use different kernel stack when we trap frame
+ * user to kernel.
+ * */
+void
+load_esp0(uintptr_t esp0) {
+c0103c84:	55                   	push   %ebp
+c0103c85:	89 e5                	mov    %esp,%ebp
+    ts.ts_esp0 = esp0;
+c0103c87:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103c8a:	a3 e4 88 11 c0       	mov    %eax,0xc01188e4
+}
+c0103c8f:	5d                   	pop    %ebp
+c0103c90:	c3                   	ret    
+
+c0103c91 <gdt_init>:
+
+/* gdt_init - initialize the default GDT and TSS */
+static void
+gdt_init(void) {
+c0103c91:	55                   	push   %ebp
+c0103c92:	89 e5                	mov    %esp,%ebp
+c0103c94:	83 ec 14             	sub    $0x14,%esp
+    // set boot kernel stack and default SS0
+    load_esp0((uintptr_t)bootstacktop);
+c0103c97:	b8 00 70 11 c0       	mov    $0xc0117000,%eax
+c0103c9c:	89 04 24             	mov    %eax,(%esp)
+c0103c9f:	e8 e0 ff ff ff       	call   c0103c84 <load_esp0>
+    ts.ts_ss0 = KERNEL_DS;
+c0103ca4:	66 c7 05 e8 88 11 c0 	movw   $0x10,0xc01188e8
+c0103cab:	10 00 
+
+    // initialize the TSS filed of the gdt
+    gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
+c0103cad:	66 c7 05 28 7a 11 c0 	movw   $0x68,0xc0117a28
+c0103cb4:	68 00 
+c0103cb6:	b8 e0 88 11 c0       	mov    $0xc01188e0,%eax
+c0103cbb:	66 a3 2a 7a 11 c0    	mov    %ax,0xc0117a2a
+c0103cc1:	b8 e0 88 11 c0       	mov    $0xc01188e0,%eax
+c0103cc6:	c1 e8 10             	shr    $0x10,%eax
+c0103cc9:	a2 2c 7a 11 c0       	mov    %al,0xc0117a2c
+c0103cce:	0f b6 05 2d 7a 11 c0 	movzbl 0xc0117a2d,%eax
+c0103cd5:	83 e0 f0             	and    $0xfffffff0,%eax
+c0103cd8:	83 c8 09             	or     $0x9,%eax
+c0103cdb:	a2 2d 7a 11 c0       	mov    %al,0xc0117a2d
+c0103ce0:	0f b6 05 2d 7a 11 c0 	movzbl 0xc0117a2d,%eax
+c0103ce7:	83 e0 ef             	and    $0xffffffef,%eax
+c0103cea:	a2 2d 7a 11 c0       	mov    %al,0xc0117a2d
+c0103cef:	0f b6 05 2d 7a 11 c0 	movzbl 0xc0117a2d,%eax
+c0103cf6:	83 e0 9f             	and    $0xffffff9f,%eax
+c0103cf9:	a2 2d 7a 11 c0       	mov    %al,0xc0117a2d
+c0103cfe:	0f b6 05 2d 7a 11 c0 	movzbl 0xc0117a2d,%eax
+c0103d05:	83 c8 80             	or     $0xffffff80,%eax
+c0103d08:	a2 2d 7a 11 c0       	mov    %al,0xc0117a2d
+c0103d0d:	0f b6 05 2e 7a 11 c0 	movzbl 0xc0117a2e,%eax
+c0103d14:	83 e0 f0             	and    $0xfffffff0,%eax
+c0103d17:	a2 2e 7a 11 c0       	mov    %al,0xc0117a2e
+c0103d1c:	0f b6 05 2e 7a 11 c0 	movzbl 0xc0117a2e,%eax
+c0103d23:	83 e0 ef             	and    $0xffffffef,%eax
+c0103d26:	a2 2e 7a 11 c0       	mov    %al,0xc0117a2e
+c0103d2b:	0f b6 05 2e 7a 11 c0 	movzbl 0xc0117a2e,%eax
+c0103d32:	83 e0 df             	and    $0xffffffdf,%eax
+c0103d35:	a2 2e 7a 11 c0       	mov    %al,0xc0117a2e
+c0103d3a:	0f b6 05 2e 7a 11 c0 	movzbl 0xc0117a2e,%eax
+c0103d41:	83 c8 40             	or     $0x40,%eax
+c0103d44:	a2 2e 7a 11 c0       	mov    %al,0xc0117a2e
+c0103d49:	0f b6 05 2e 7a 11 c0 	movzbl 0xc0117a2e,%eax
+c0103d50:	83 e0 7f             	and    $0x7f,%eax
+c0103d53:	a2 2e 7a 11 c0       	mov    %al,0xc0117a2e
+c0103d58:	b8 e0 88 11 c0       	mov    $0xc01188e0,%eax
+c0103d5d:	c1 e8 18             	shr    $0x18,%eax
+c0103d60:	a2 2f 7a 11 c0       	mov    %al,0xc0117a2f
+
+    // reload all segment registers
+    lgdt(&gdt_pd);
+c0103d65:	c7 04 24 30 7a 11 c0 	movl   $0xc0117a30,(%esp)
+c0103d6c:	e8 de fe ff ff       	call   c0103c4f <lgdt>
+c0103d71:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%ebp)
+    asm volatile ("cli" ::: "memory");
+}
+
+static inline void
+ltr(uint16_t sel) {
+    asm volatile ("ltr %0" :: "r" (sel) : "memory");
+c0103d77:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+c0103d7b:	0f 00 d8             	ltr    %ax
+
+    // load the TSS
+    ltr(GD_TSS);
+}
+c0103d7e:	c9                   	leave  
+c0103d7f:	c3                   	ret    
+
+c0103d80 <init_pmm_manager>:
+
+//init_pmm_manager - initialize a pmm_manager instance
+static void
+init_pmm_manager(void) {
+c0103d80:	55                   	push   %ebp
+c0103d81:	89 e5                	mov    %esp,%ebp
+c0103d83:	83 ec 18             	sub    $0x18,%esp
+    pmm_manager = &default_pmm_manager;
+c0103d86:	c7 05 bc 89 11 c0 f0 	movl   $0xc0106af0,0xc01189bc
+c0103d8d:	6a 10 c0 
+    cprintf("memory management: %s\n", pmm_manager->name);
+c0103d90:	a1 bc 89 11 c0       	mov    0xc01189bc,%eax
+c0103d95:	8b 00                	mov    (%eax),%eax
+c0103d97:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103d9b:	c7 04 24 8c 6b 10 c0 	movl   $0xc0106b8c,(%esp)
+c0103da2:	e8 95 c5 ff ff       	call   c010033c <cprintf>
+    pmm_manager->init();
+c0103da7:	a1 bc 89 11 c0       	mov    0xc01189bc,%eax
+c0103dac:	8b 40 04             	mov    0x4(%eax),%eax
+c0103daf:	ff d0                	call   *%eax
+}
+c0103db1:	c9                   	leave  
+c0103db2:	c3                   	ret    
+
+c0103db3 <init_memmap>:
+
+//init_memmap - call pmm->init_memmap to build Page struct for free memory  
+static void
+init_memmap(struct Page *base, size_t n) {
+c0103db3:	55                   	push   %ebp
+c0103db4:	89 e5                	mov    %esp,%ebp
+c0103db6:	83 ec 18             	sub    $0x18,%esp
+    pmm_manager->init_memmap(base, n);
+c0103db9:	a1 bc 89 11 c0       	mov    0xc01189bc,%eax
+c0103dbe:	8b 40 08             	mov    0x8(%eax),%eax
+c0103dc1:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0103dc4:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0103dc8:	8b 55 08             	mov    0x8(%ebp),%edx
+c0103dcb:	89 14 24             	mov    %edx,(%esp)
+c0103dce:	ff d0                	call   *%eax
+}
+c0103dd0:	c9                   	leave  
+c0103dd1:	c3                   	ret    
+
+c0103dd2 <alloc_pages>:
+
+//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
+struct Page *
+alloc_pages(size_t n) {
+c0103dd2:	55                   	push   %ebp
+c0103dd3:	89 e5                	mov    %esp,%ebp
+c0103dd5:	83 ec 28             	sub    $0x28,%esp
+    struct Page *page=NULL;
+c0103dd8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c0103ddf:	e8 2e fe ff ff       	call   c0103c12 <__intr_save>
+c0103de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    {
+        page = pmm_manager->alloc_pages(n);
+c0103de7:	a1 bc 89 11 c0       	mov    0xc01189bc,%eax
+c0103dec:	8b 40 0c             	mov    0xc(%eax),%eax
+c0103def:	8b 55 08             	mov    0x8(%ebp),%edx
+c0103df2:	89 14 24             	mov    %edx,(%esp)
+c0103df5:	ff d0                	call   *%eax
+c0103df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    }
+    local_intr_restore(intr_flag);
+c0103dfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103dfd:	89 04 24             	mov    %eax,(%esp)
+c0103e00:	e8 37 fe ff ff       	call   c0103c3c <__intr_restore>
+    return page;
+c0103e05:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0103e08:	c9                   	leave  
+c0103e09:	c3                   	ret    
+
+c0103e0a <free_pages>:
+
+//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
+void
+free_pages(struct Page *base, size_t n) {
+c0103e0a:	55                   	push   %ebp
+c0103e0b:	89 e5                	mov    %esp,%ebp
+c0103e0d:	83 ec 28             	sub    $0x28,%esp
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c0103e10:	e8 fd fd ff ff       	call   c0103c12 <__intr_save>
+c0103e15:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        pmm_manager->free_pages(base, n);
+c0103e18:	a1 bc 89 11 c0       	mov    0xc01189bc,%eax
+c0103e1d:	8b 40 10             	mov    0x10(%eax),%eax
+c0103e20:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0103e23:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0103e27:	8b 55 08             	mov    0x8(%ebp),%edx
+c0103e2a:	89 14 24             	mov    %edx,(%esp)
+c0103e2d:	ff d0                	call   *%eax
+    }
+    local_intr_restore(intr_flag);
+c0103e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103e32:	89 04 24             	mov    %eax,(%esp)
+c0103e35:	e8 02 fe ff ff       	call   c0103c3c <__intr_restore>
+}
+c0103e3a:	c9                   	leave  
+c0103e3b:	c3                   	ret    
+
+c0103e3c <nr_free_pages>:
+
+//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
+//of current free memory
+size_t
+nr_free_pages(void) {
+c0103e3c:	55                   	push   %ebp
+c0103e3d:	89 e5                	mov    %esp,%ebp
+c0103e3f:	83 ec 28             	sub    $0x28,%esp
+    size_t ret;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+c0103e42:	e8 cb fd ff ff       	call   c0103c12 <__intr_save>
+c0103e47:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        ret = pmm_manager->nr_free_pages();
+c0103e4a:	a1 bc 89 11 c0       	mov    0xc01189bc,%eax
+c0103e4f:	8b 40 14             	mov    0x14(%eax),%eax
+c0103e52:	ff d0                	call   *%eax
+c0103e54:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    }
+    local_intr_restore(intr_flag);
+c0103e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103e5a:	89 04 24             	mov    %eax,(%esp)
+c0103e5d:	e8 da fd ff ff       	call   c0103c3c <__intr_restore>
+    return ret;
+c0103e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+c0103e65:	c9                   	leave  
+c0103e66:	c3                   	ret    
+
+c0103e67 <page_init>:
+
+/* pmm_init - initialize the physical memory management */
+static void
+page_init(void) {
+c0103e67:	55                   	push   %ebp
+c0103e68:	89 e5                	mov    %esp,%ebp
+c0103e6a:	57                   	push   %edi
+c0103e6b:	56                   	push   %esi
+c0103e6c:	53                   	push   %ebx
+c0103e6d:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+c0103e73:	c7 45 c4 00 80 00 c0 	movl   $0xc0008000,-0x3c(%ebp)
+    uint64_t maxpa = 0;
+c0103e7a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+c0103e81:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+
+    cprintf("e820map:\n");
+c0103e88:	c7 04 24 a3 6b 10 c0 	movl   $0xc0106ba3,(%esp)
+c0103e8f:	e8 a8 c4 ff ff       	call   c010033c <cprintf>
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+c0103e94:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c0103e9b:	e9 15 01 00 00       	jmp    c0103fb5 <page_init+0x14e>
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+c0103ea0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103ea3:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103ea6:	89 d0                	mov    %edx,%eax
+c0103ea8:	c1 e0 02             	shl    $0x2,%eax
+c0103eab:	01 d0                	add    %edx,%eax
+c0103ead:	c1 e0 02             	shl    $0x2,%eax
+c0103eb0:	01 c8                	add    %ecx,%eax
+c0103eb2:	8b 50 08             	mov    0x8(%eax),%edx
+c0103eb5:	8b 40 04             	mov    0x4(%eax),%eax
+c0103eb8:	89 45 b8             	mov    %eax,-0x48(%ebp)
+c0103ebb:	89 55 bc             	mov    %edx,-0x44(%ebp)
+c0103ebe:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103ec1:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103ec4:	89 d0                	mov    %edx,%eax
+c0103ec6:	c1 e0 02             	shl    $0x2,%eax
+c0103ec9:	01 d0                	add    %edx,%eax
+c0103ecb:	c1 e0 02             	shl    $0x2,%eax
+c0103ece:	01 c8                	add    %ecx,%eax
+c0103ed0:	8b 48 0c             	mov    0xc(%eax),%ecx
+c0103ed3:	8b 58 10             	mov    0x10(%eax),%ebx
+c0103ed6:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0103ed9:	8b 55 bc             	mov    -0x44(%ebp),%edx
+c0103edc:	01 c8                	add    %ecx,%eax
+c0103ede:	11 da                	adc    %ebx,%edx
+c0103ee0:	89 45 b0             	mov    %eax,-0x50(%ebp)
+c0103ee3:	89 55 b4             	mov    %edx,-0x4c(%ebp)
+        cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
+c0103ee6:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103ee9:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103eec:	89 d0                	mov    %edx,%eax
+c0103eee:	c1 e0 02             	shl    $0x2,%eax
+c0103ef1:	01 d0                	add    %edx,%eax
+c0103ef3:	c1 e0 02             	shl    $0x2,%eax
+c0103ef6:	01 c8                	add    %ecx,%eax
+c0103ef8:	83 c0 14             	add    $0x14,%eax
+c0103efb:	8b 00                	mov    (%eax),%eax
+c0103efd:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
+c0103f03:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0103f06:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+c0103f09:	83 c0 ff             	add    $0xffffffff,%eax
+c0103f0c:	83 d2 ff             	adc    $0xffffffff,%edx
+c0103f0f:	89 c6                	mov    %eax,%esi
+c0103f11:	89 d7                	mov    %edx,%edi
+c0103f13:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103f16:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103f19:	89 d0                	mov    %edx,%eax
+c0103f1b:	c1 e0 02             	shl    $0x2,%eax
+c0103f1e:	01 d0                	add    %edx,%eax
+c0103f20:	c1 e0 02             	shl    $0x2,%eax
+c0103f23:	01 c8                	add    %ecx,%eax
+c0103f25:	8b 48 0c             	mov    0xc(%eax),%ecx
+c0103f28:	8b 58 10             	mov    0x10(%eax),%ebx
+c0103f2b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
+c0103f31:	89 44 24 1c          	mov    %eax,0x1c(%esp)
+c0103f35:	89 74 24 14          	mov    %esi,0x14(%esp)
+c0103f39:	89 7c 24 18          	mov    %edi,0x18(%esp)
+c0103f3d:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0103f40:	8b 55 bc             	mov    -0x44(%ebp),%edx
+c0103f43:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0103f47:	89 54 24 10          	mov    %edx,0x10(%esp)
+c0103f4b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+c0103f4f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+c0103f53:	c7 04 24 b0 6b 10 c0 	movl   $0xc0106bb0,(%esp)
+c0103f5a:	e8 dd c3 ff ff       	call   c010033c <cprintf>
+                memmap->map[i].size, begin, end - 1, memmap->map[i].type);
+        if (memmap->map[i].type == E820_ARM) {
+c0103f5f:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103f62:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103f65:	89 d0                	mov    %edx,%eax
+c0103f67:	c1 e0 02             	shl    $0x2,%eax
+c0103f6a:	01 d0                	add    %edx,%eax
+c0103f6c:	c1 e0 02             	shl    $0x2,%eax
+c0103f6f:	01 c8                	add    %ecx,%eax
+c0103f71:	83 c0 14             	add    $0x14,%eax
+c0103f74:	8b 00                	mov    (%eax),%eax
+c0103f76:	83 f8 01             	cmp    $0x1,%eax
+c0103f79:	75 36                	jne    c0103fb1 <page_init+0x14a>
+            if (maxpa < end && begin < KMEMSIZE) {
+c0103f7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103f7e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0103f81:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
+c0103f84:	77 2b                	ja     c0103fb1 <page_init+0x14a>
+c0103f86:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
+c0103f89:	72 05                	jb     c0103f90 <page_init+0x129>
+c0103f8b:	3b 45 b0             	cmp    -0x50(%ebp),%eax
+c0103f8e:	73 21                	jae    c0103fb1 <page_init+0x14a>
+c0103f90:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+c0103f94:	77 1b                	ja     c0103fb1 <page_init+0x14a>
+c0103f96:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+c0103f9a:	72 09                	jb     c0103fa5 <page_init+0x13e>
+c0103f9c:	81 7d b8 ff ff ff 37 	cmpl   $0x37ffffff,-0x48(%ebp)
+c0103fa3:	77 0c                	ja     c0103fb1 <page_init+0x14a>
+                maxpa = end;
+c0103fa5:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0103fa8:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+c0103fab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0103fae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+    uint64_t maxpa = 0;
+
+    cprintf("e820map:\n");
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+c0103fb1:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+c0103fb5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0103fb8:	8b 00                	mov    (%eax),%eax
+c0103fba:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+c0103fbd:	0f 8f dd fe ff ff    	jg     c0103ea0 <page_init+0x39>
+            if (maxpa < end && begin < KMEMSIZE) {
+                maxpa = end;
+            }
+        }
+    }
+    if (maxpa > KMEMSIZE) {
+c0103fc3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0103fc7:	72 1d                	jb     c0103fe6 <page_init+0x17f>
+c0103fc9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0103fcd:	77 09                	ja     c0103fd8 <page_init+0x171>
+c0103fcf:	81 7d e0 00 00 00 38 	cmpl   $0x38000000,-0x20(%ebp)
+c0103fd6:	76 0e                	jbe    c0103fe6 <page_init+0x17f>
+        maxpa = KMEMSIZE;
+c0103fd8:	c7 45 e0 00 00 00 38 	movl   $0x38000000,-0x20(%ebp)
+c0103fdf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    }
+
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+c0103fe6:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103fe9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0103fec:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+c0103ff0:	c1 ea 0c             	shr    $0xc,%edx
+c0103ff3:	a3 c0 88 11 c0       	mov    %eax,0xc01188c0
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+c0103ff8:	c7 45 ac 00 10 00 00 	movl   $0x1000,-0x54(%ebp)
+c0103fff:	b8 c8 89 11 c0       	mov    $0xc01189c8,%eax
+c0104004:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0104007:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c010400a:	01 d0                	add    %edx,%eax
+c010400c:	89 45 a8             	mov    %eax,-0x58(%ebp)
+c010400f:	8b 45 a8             	mov    -0x58(%ebp),%eax
+c0104012:	ba 00 00 00 00       	mov    $0x0,%edx
+c0104017:	f7 75 ac             	divl   -0x54(%ebp)
+c010401a:	89 d0                	mov    %edx,%eax
+c010401c:	8b 55 a8             	mov    -0x58(%ebp),%edx
+c010401f:	29 c2                	sub    %eax,%edx
+c0104021:	89 d0                	mov    %edx,%eax
+c0104023:	a3 c4 89 11 c0       	mov    %eax,0xc01189c4
+
+    for (i = 0; i < npage; i ++) {
+c0104028:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c010402f:	eb 2f                	jmp    c0104060 <page_init+0x1f9>
+        SetPageReserved(pages + i);
+c0104031:	8b 0d c4 89 11 c0    	mov    0xc01189c4,%ecx
+c0104037:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c010403a:	89 d0                	mov    %edx,%eax
+c010403c:	c1 e0 02             	shl    $0x2,%eax
+c010403f:	01 d0                	add    %edx,%eax
+c0104041:	c1 e0 02             	shl    $0x2,%eax
+c0104044:	01 c8                	add    %ecx,%eax
+c0104046:	83 c0 04             	add    $0x4,%eax
+c0104049:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
+c0104050:	89 45 8c             	mov    %eax,-0x74(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+c0104053:	8b 45 8c             	mov    -0x74(%ebp),%eax
+c0104056:	8b 55 90             	mov    -0x70(%ebp),%edx
+c0104059:	0f ab 10             	bts    %edx,(%eax)
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+
+    for (i = 0; i < npage; i ++) {
+c010405c:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+c0104060:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0104063:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0104068:	39 c2                	cmp    %eax,%edx
+c010406a:	72 c5                	jb     c0104031 <page_init+0x1ca>
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+c010406c:	8b 15 c0 88 11 c0    	mov    0xc01188c0,%edx
+c0104072:	89 d0                	mov    %edx,%eax
+c0104074:	c1 e0 02             	shl    $0x2,%eax
+c0104077:	01 d0                	add    %edx,%eax
+c0104079:	c1 e0 02             	shl    $0x2,%eax
+c010407c:	89 c2                	mov    %eax,%edx
+c010407e:	a1 c4 89 11 c0       	mov    0xc01189c4,%eax
+c0104083:	01 d0                	add    %edx,%eax
+c0104085:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+c0104088:	81 7d a4 ff ff ff bf 	cmpl   $0xbfffffff,-0x5c(%ebp)
+c010408f:	77 23                	ja     c01040b4 <page_init+0x24d>
+c0104091:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c0104094:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104098:	c7 44 24 08 e0 6b 10 	movl   $0xc0106be0,0x8(%esp)
+c010409f:	c0 
+c01040a0:	c7 44 24 04 db 00 00 	movl   $0xdb,0x4(%esp)
+c01040a7:	00 
+c01040a8:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01040af:	e8 0c cc ff ff       	call   c0100cc0 <__panic>
+c01040b4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c01040b7:	05 00 00 00 40       	add    $0x40000000,%eax
+c01040bc:	89 45 a0             	mov    %eax,-0x60(%ebp)
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+c01040bf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c01040c6:	e9 74 01 00 00       	jmp    c010423f <page_init+0x3d8>
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+c01040cb:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c01040ce:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01040d1:	89 d0                	mov    %edx,%eax
+c01040d3:	c1 e0 02             	shl    $0x2,%eax
+c01040d6:	01 d0                	add    %edx,%eax
+c01040d8:	c1 e0 02             	shl    $0x2,%eax
+c01040db:	01 c8                	add    %ecx,%eax
+c01040dd:	8b 50 08             	mov    0x8(%eax),%edx
+c01040e0:	8b 40 04             	mov    0x4(%eax),%eax
+c01040e3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c01040e6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c01040e9:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c01040ec:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01040ef:	89 d0                	mov    %edx,%eax
+c01040f1:	c1 e0 02             	shl    $0x2,%eax
+c01040f4:	01 d0                	add    %edx,%eax
+c01040f6:	c1 e0 02             	shl    $0x2,%eax
+c01040f9:	01 c8                	add    %ecx,%eax
+c01040fb:	8b 48 0c             	mov    0xc(%eax),%ecx
+c01040fe:	8b 58 10             	mov    0x10(%eax),%ebx
+c0104101:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0104104:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0104107:	01 c8                	add    %ecx,%eax
+c0104109:	11 da                	adc    %ebx,%edx
+c010410b:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c010410e:	89 55 cc             	mov    %edx,-0x34(%ebp)
+        if (memmap->map[i].type == E820_ARM) {
+c0104111:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0104114:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0104117:	89 d0                	mov    %edx,%eax
+c0104119:	c1 e0 02             	shl    $0x2,%eax
+c010411c:	01 d0                	add    %edx,%eax
+c010411e:	c1 e0 02             	shl    $0x2,%eax
+c0104121:	01 c8                	add    %ecx,%eax
+c0104123:	83 c0 14             	add    $0x14,%eax
+c0104126:	8b 00                	mov    (%eax),%eax
+c0104128:	83 f8 01             	cmp    $0x1,%eax
+c010412b:	0f 85 0a 01 00 00    	jne    c010423b <page_init+0x3d4>
+            if (begin < freemem) {
+c0104131:	8b 45 a0             	mov    -0x60(%ebp),%eax
+c0104134:	ba 00 00 00 00       	mov    $0x0,%edx
+c0104139:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c010413c:	72 17                	jb     c0104155 <page_init+0x2ee>
+c010413e:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c0104141:	77 05                	ja     c0104148 <page_init+0x2e1>
+c0104143:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+c0104146:	76 0d                	jbe    c0104155 <page_init+0x2ee>
+                begin = freemem;
+c0104148:	8b 45 a0             	mov    -0x60(%ebp),%eax
+c010414b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010414e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+            }
+            if (end > KMEMSIZE) {
+c0104155:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c0104159:	72 1d                	jb     c0104178 <page_init+0x311>
+c010415b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c010415f:	77 09                	ja     c010416a <page_init+0x303>
+c0104161:	81 7d c8 00 00 00 38 	cmpl   $0x38000000,-0x38(%ebp)
+c0104168:	76 0e                	jbe    c0104178 <page_init+0x311>
+                end = KMEMSIZE;
+c010416a:	c7 45 c8 00 00 00 38 	movl   $0x38000000,-0x38(%ebp)
+c0104171:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
+            }
+            if (begin < end) {
+c0104178:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010417b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c010417e:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c0104181:	0f 87 b4 00 00 00    	ja     c010423b <page_init+0x3d4>
+c0104187:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c010418a:	72 09                	jb     c0104195 <page_init+0x32e>
+c010418c:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+c010418f:	0f 83 a6 00 00 00    	jae    c010423b <page_init+0x3d4>
+                begin = ROUNDUP(begin, PGSIZE);
+c0104195:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
+c010419c:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c010419f:	8b 45 9c             	mov    -0x64(%ebp),%eax
+c01041a2:	01 d0                	add    %edx,%eax
+c01041a4:	83 e8 01             	sub    $0x1,%eax
+c01041a7:	89 45 98             	mov    %eax,-0x68(%ebp)
+c01041aa:	8b 45 98             	mov    -0x68(%ebp),%eax
+c01041ad:	ba 00 00 00 00       	mov    $0x0,%edx
+c01041b2:	f7 75 9c             	divl   -0x64(%ebp)
+c01041b5:	89 d0                	mov    %edx,%eax
+c01041b7:	8b 55 98             	mov    -0x68(%ebp),%edx
+c01041ba:	29 c2                	sub    %eax,%edx
+c01041bc:	89 d0                	mov    %edx,%eax
+c01041be:	ba 00 00 00 00       	mov    $0x0,%edx
+c01041c3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c01041c6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+                end = ROUNDDOWN(end, PGSIZE);
+c01041c9:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c01041cc:	89 45 94             	mov    %eax,-0x6c(%ebp)
+c01041cf:	8b 45 94             	mov    -0x6c(%ebp),%eax
+c01041d2:	ba 00 00 00 00       	mov    $0x0,%edx
+c01041d7:	89 c7                	mov    %eax,%edi
+c01041d9:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
+c01041df:	89 7d 80             	mov    %edi,-0x80(%ebp)
+c01041e2:	89 d0                	mov    %edx,%eax
+c01041e4:	83 e0 00             	and    $0x0,%eax
+c01041e7:	89 45 84             	mov    %eax,-0x7c(%ebp)
+c01041ea:	8b 45 80             	mov    -0x80(%ebp),%eax
+c01041ed:	8b 55 84             	mov    -0x7c(%ebp),%edx
+c01041f0:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c01041f3:	89 55 cc             	mov    %edx,-0x34(%ebp)
+                if (begin < end) {
+c01041f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01041f9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01041fc:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c01041ff:	77 3a                	ja     c010423b <page_init+0x3d4>
+c0104201:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c0104204:	72 05                	jb     c010420b <page_init+0x3a4>
+c0104206:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+c0104209:	73 30                	jae    c010423b <page_init+0x3d4>
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+c010420b:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+c010420e:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
+c0104211:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0104214:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0104217:	29 c8                	sub    %ecx,%eax
+c0104219:	19 da                	sbb    %ebx,%edx
+c010421b:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+c010421f:	c1 ea 0c             	shr    $0xc,%edx
+c0104222:	89 c3                	mov    %eax,%ebx
+c0104224:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0104227:	89 04 24             	mov    %eax,(%esp)
+c010422a:	e8 bd f8 ff ff       	call   c0103aec <pa2page>
+c010422f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+c0104233:	89 04 24             	mov    %eax,(%esp)
+c0104236:	e8 78 fb ff ff       	call   c0103db3 <init_memmap>
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+c010423b:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+c010423f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0104242:	8b 00                	mov    (%eax),%eax
+c0104244:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+c0104247:	0f 8f 7e fe ff ff    	jg     c01040cb <page_init+0x264>
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+                }
+            }
+        }
+    }
+}
+c010424d:	81 c4 9c 00 00 00    	add    $0x9c,%esp
+c0104253:	5b                   	pop    %ebx
+c0104254:	5e                   	pop    %esi
+c0104255:	5f                   	pop    %edi
+c0104256:	5d                   	pop    %ebp
+c0104257:	c3                   	ret    
+
+c0104258 <enable_paging>:
+
+static void
+enable_paging(void) {
+c0104258:	55                   	push   %ebp
+c0104259:	89 e5                	mov    %esp,%ebp
+c010425b:	83 ec 10             	sub    $0x10,%esp
+    lcr3(boot_cr3);
+c010425e:	a1 c0 89 11 c0       	mov    0xc01189c0,%eax
+c0104263:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
+}
+
+static inline void
+lcr3(uintptr_t cr3) {
+    asm volatile ("mov %0, %%cr3" :: "r" (cr3) : "memory");
+c0104266:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0104269:	0f 22 d8             	mov    %eax,%cr3
+}
+
+static inline uintptr_t
+rcr0(void) {
+    uintptr_t cr0;
+    asm volatile ("mov %%cr0, %0" : "=r" (cr0) :: "memory");
+c010426c:	0f 20 c0             	mov    %cr0,%eax
+c010426f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return cr0;
+c0104272:	8b 45 f4             	mov    -0xc(%ebp),%eax
+
+    // turn on paging
+    uint32_t cr0 = rcr0();
+c0104275:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP;
+c0104278:	81 4d fc 2f 00 05 80 	orl    $0x8005002f,-0x4(%ebp)
+    cr0 &= ~(CR0_TS | CR0_EM);
+c010427f:	83 65 fc f3          	andl   $0xfffffff3,-0x4(%ebp)
+c0104283:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104286:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    asm volatile ("pushl %0; popfl" :: "r" (eflags));
+}
+
+static inline void
+lcr0(uintptr_t cr0) {
+    asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
+c0104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010428c:	0f 22 c0             	mov    %eax,%cr0
+    lcr0(cr0);
+}
+c010428f:	c9                   	leave  
+c0104290:	c3                   	ret    
+
+c0104291 <boot_map_segment>:
+//  la:   linear address of this memory need to map (after x86 segment map)
+//  size: memory size
+//  pa:   physical address of this memory
+//  perm: permission of this memory  
+static void
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+c0104291:	55                   	push   %ebp
+c0104292:	89 e5                	mov    %esp,%ebp
+c0104294:	83 ec 38             	sub    $0x38,%esp
+    assert(PGOFF(la) == PGOFF(pa));
+c0104297:	8b 45 14             	mov    0x14(%ebp),%eax
+c010429a:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010429d:	31 d0                	xor    %edx,%eax
+c010429f:	25 ff 0f 00 00       	and    $0xfff,%eax
+c01042a4:	85 c0                	test   %eax,%eax
+c01042a6:	74 24                	je     c01042cc <boot_map_segment+0x3b>
+c01042a8:	c7 44 24 0c 12 6c 10 	movl   $0xc0106c12,0xc(%esp)
+c01042af:	c0 
+c01042b0:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c01042b7:	c0 
+c01042b8:	c7 44 24 04 04 01 00 	movl   $0x104,0x4(%esp)
+c01042bf:	00 
+c01042c0:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01042c7:	e8 f4 c9 ff ff       	call   c0100cc0 <__panic>
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+c01042cc:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
+c01042d3:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01042d6:	25 ff 0f 00 00       	and    $0xfff,%eax
+c01042db:	89 c2                	mov    %eax,%edx
+c01042dd:	8b 45 10             	mov    0x10(%ebp),%eax
+c01042e0:	01 c2                	add    %eax,%edx
+c01042e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01042e5:	01 d0                	add    %edx,%eax
+c01042e7:	83 e8 01             	sub    $0x1,%eax
+c01042ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01042ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01042f0:	ba 00 00 00 00       	mov    $0x0,%edx
+c01042f5:	f7 75 f0             	divl   -0x10(%ebp)
+c01042f8:	89 d0                	mov    %edx,%eax
+c01042fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c01042fd:	29 c2                	sub    %eax,%edx
+c01042ff:	89 d0                	mov    %edx,%eax
+c0104301:	c1 e8 0c             	shr    $0xc,%eax
+c0104304:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    la = ROUNDDOWN(la, PGSIZE);
+c0104307:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010430a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010430d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0104310:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104315:	89 45 0c             	mov    %eax,0xc(%ebp)
+    pa = ROUNDDOWN(pa, PGSIZE);
+c0104318:	8b 45 14             	mov    0x14(%ebp),%eax
+c010431b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010431e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104321:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104326:	89 45 14             	mov    %eax,0x14(%ebp)
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+c0104329:	eb 6b                	jmp    c0104396 <boot_map_segment+0x105>
+        pte_t *ptep = get_pte(pgdir, la, 1);
+c010432b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+c0104332:	00 
+c0104333:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104336:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010433a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010433d:	89 04 24             	mov    %eax,(%esp)
+c0104340:	e8 cc 01 00 00       	call   c0104511 <get_pte>
+c0104345:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        assert(ptep != NULL);
+c0104348:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c010434c:	75 24                	jne    c0104372 <boot_map_segment+0xe1>
+c010434e:	c7 44 24 0c 3e 6c 10 	movl   $0xc0106c3e,0xc(%esp)
+c0104355:	c0 
+c0104356:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c010435d:	c0 
+c010435e:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
+c0104365:	00 
+c0104366:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c010436d:	e8 4e c9 ff ff       	call   c0100cc0 <__panic>
+        *ptep = pa | PTE_P | perm;
+c0104372:	8b 45 18             	mov    0x18(%ebp),%eax
+c0104375:	8b 55 14             	mov    0x14(%ebp),%edx
+c0104378:	09 d0                	or     %edx,%eax
+c010437a:	83 c8 01             	or     $0x1,%eax
+c010437d:	89 c2                	mov    %eax,%edx
+c010437f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104382:	89 10                	mov    %edx,(%eax)
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+    assert(PGOFF(la) == PGOFF(pa));
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+    la = ROUNDDOWN(la, PGSIZE);
+    pa = ROUNDDOWN(pa, PGSIZE);
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+c0104384:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+c0104388:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
+c010438f:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
+c0104396:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010439a:	75 8f                	jne    c010432b <boot_map_segment+0x9a>
+        pte_t *ptep = get_pte(pgdir, la, 1);
+        assert(ptep != NULL);
+        *ptep = pa | PTE_P | perm;
+    }
+}
+c010439c:	c9                   	leave  
+c010439d:	c3                   	ret    
+
+c010439e <boot_alloc_page>:
+
+//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
+// return value: the kernel virtual address of this allocated page
+//note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
+static void *
+boot_alloc_page(void) {
+c010439e:	55                   	push   %ebp
+c010439f:	89 e5                	mov    %esp,%ebp
+c01043a1:	83 ec 28             	sub    $0x28,%esp
+    struct Page *p = alloc_page();
+c01043a4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01043ab:	e8 22 fa ff ff       	call   c0103dd2 <alloc_pages>
+c01043b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (p == NULL) {
+c01043b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01043b7:	75 1c                	jne    c01043d5 <boot_alloc_page+0x37>
+        panic("boot_alloc_page failed.\n");
+c01043b9:	c7 44 24 08 4b 6c 10 	movl   $0xc0106c4b,0x8(%esp)
+c01043c0:	c0 
+c01043c1:	c7 44 24 04 16 01 00 	movl   $0x116,0x4(%esp)
+c01043c8:	00 
+c01043c9:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01043d0:	e8 eb c8 ff ff       	call   c0100cc0 <__panic>
+    }
+    return page2kva(p);
+c01043d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01043d8:	89 04 24             	mov    %eax,(%esp)
+c01043db:	e8 5b f7 ff ff       	call   c0103b3b <page2kva>
+}
+c01043e0:	c9                   	leave  
+c01043e1:	c3                   	ret    
+
+c01043e2 <pmm_init>:
+
+//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
+//         - check the correctness of pmm & paging mechanism, print PDT&PT
+void
+pmm_init(void) {
+c01043e2:	55                   	push   %ebp
+c01043e3:	89 e5                	mov    %esp,%ebp
+c01043e5:	83 ec 38             	sub    $0x38,%esp
+    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
+    //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
+    //First we should init a physical memory manager(pmm) based on the framework.
+    //Then pmm can alloc/free the physical memory. 
+    //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
+    init_pmm_manager();
+c01043e8:	e8 93 f9 ff ff       	call   c0103d80 <init_pmm_manager>
+
+    // detect physical memory space, reserve already used memory,
+    // then use pmm->init_memmap to create free page list
+    page_init();
+c01043ed:	e8 75 fa ff ff       	call   c0103e67 <page_init>
+
+    //use pmm->check to verify the correctness of the alloc/free function in a pmm
+    check_alloc_page();
+c01043f2:	e8 66 04 00 00       	call   c010485d <check_alloc_page>
+
+    // create boot_pgdir, an initial page directory(Page Directory Table, PDT)
+    boot_pgdir = boot_alloc_page();
+c01043f7:	e8 a2 ff ff ff       	call   c010439e <boot_alloc_page>
+c01043fc:	a3 c4 88 11 c0       	mov    %eax,0xc01188c4
+    memset(boot_pgdir, 0, PGSIZE);
+c0104401:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104406:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+c010440d:	00 
+c010440e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0104415:	00 
+c0104416:	89 04 24             	mov    %eax,(%esp)
+c0104419:	e8 a8 1a 00 00       	call   c0105ec6 <memset>
+    boot_cr3 = PADDR(boot_pgdir);
+c010441e:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104423:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104426:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+c010442d:	77 23                	ja     c0104452 <pmm_init+0x70>
+c010442f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104432:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104436:	c7 44 24 08 e0 6b 10 	movl   $0xc0106be0,0x8(%esp)
+c010443d:	c0 
+c010443e:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
+c0104445:	00 
+c0104446:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c010444d:	e8 6e c8 ff ff       	call   c0100cc0 <__panic>
+c0104452:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104455:	05 00 00 00 40       	add    $0x40000000,%eax
+c010445a:	a3 c0 89 11 c0       	mov    %eax,0xc01189c0
+
+    check_pgdir();
+c010445f:	e8 17 04 00 00       	call   c010487b <check_pgdir>
+
+    static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
+
+    // recursively insert boot_pgdir in itself
+    // to form a virtual page table at virtual address VPT
+    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
+c0104464:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104469:	8d 90 ac 0f 00 00    	lea    0xfac(%eax),%edx
+c010446f:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104474:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104477:	81 7d f0 ff ff ff bf 	cmpl   $0xbfffffff,-0x10(%ebp)
+c010447e:	77 23                	ja     c01044a3 <pmm_init+0xc1>
+c0104480:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104483:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104487:	c7 44 24 08 e0 6b 10 	movl   $0xc0106be0,0x8(%esp)
+c010448e:	c0 
+c010448f:	c7 44 24 04 38 01 00 	movl   $0x138,0x4(%esp)
+c0104496:	00 
+c0104497:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c010449e:	e8 1d c8 ff ff       	call   c0100cc0 <__panic>
+c01044a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01044a6:	05 00 00 00 40       	add    $0x40000000,%eax
+c01044ab:	83 c8 03             	or     $0x3,%eax
+c01044ae:	89 02                	mov    %eax,(%edx)
+
+    // map all physical memory to linear memory with base linear addr KERNBASE
+    //linear_addr KERNBASE~KERNBASE+KMEMSIZE = phy_addr 0~KMEMSIZE
+    //But shouldn't use this map until enable_paging() & gdt_init() finished.
+    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
+c01044b0:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c01044b5:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
+c01044bc:	00 
+c01044bd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+c01044c4:	00 
+c01044c5:	c7 44 24 08 00 00 00 	movl   $0x38000000,0x8(%esp)
+c01044cc:	38 
+c01044cd:	c7 44 24 04 00 00 00 	movl   $0xc0000000,0x4(%esp)
+c01044d4:	c0 
+c01044d5:	89 04 24             	mov    %eax,(%esp)
+c01044d8:	e8 b4 fd ff ff       	call   c0104291 <boot_map_segment>
+
+    //temporary map: 
+    //virtual_addr 3G~3G+4M = linear_addr 0~4M = linear_addr 3G~3G+4M = phy_addr 0~4M     
+    boot_pgdir[0] = boot_pgdir[PDX(KERNBASE)];
+c01044dd:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c01044e2:	8b 15 c4 88 11 c0    	mov    0xc01188c4,%edx
+c01044e8:	8b 92 00 0c 00 00    	mov    0xc00(%edx),%edx
+c01044ee:	89 10                	mov    %edx,(%eax)
+
+    enable_paging();
+c01044f0:	e8 63 fd ff ff       	call   c0104258 <enable_paging>
+
+    //reload gdt(third time,the last time) to map all physical memory
+    //virtual_addr 0~4G=liear_addr 0~4G
+    //then set kernel stack(ss:esp) in TSS, setup TSS in gdt, load TSS
+    gdt_init();
+c01044f5:	e8 97 f7 ff ff       	call   c0103c91 <gdt_init>
+
+    //disable the map of virtual_addr 0~4M
+    boot_pgdir[0] = 0;
+c01044fa:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c01044ff:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    //now the basic virtual memory map(see memalyout.h) is established.
+    //check the correctness of the basic virtual memory map.
+    check_boot_pgdir();
+c0104505:	e8 0c 0a 00 00       	call   c0104f16 <check_boot_pgdir>
+
+    print_pgdir();
+c010450a:	e8 99 0e 00 00       	call   c01053a8 <print_pgdir>
+
+}
+c010450f:	c9                   	leave  
+c0104510:	c3                   	ret    
+
+c0104511 <get_pte>:
+//  pgdir:  the kernel virtual base address of PDT
+//  la:     the linear address need to map
+//  create: a logical value to decide if alloc a page for PT
+// return vaule: the kernel virtual address of this pte
+pte_t *
+get_pte(pde_t *pgdir, uintptr_t la, bool create) {
+c0104511:	55                   	push   %ebp
+c0104512:	89 e5                	mov    %esp,%ebp
+c0104514:	83 ec 38             	sub    $0x38,%esp
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
+     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+     */
+
+    pde_t *pdep = &pgdir[PDX(la)];   // (1) find page directory entry
+c0104517:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010451a:	c1 e8 16             	shr    $0x16,%eax
+c010451d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0104524:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104527:	01 d0                	add    %edx,%eax
+c0104529:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (!(*pdep & PTE_P)) {              // (2) check if entry is not present
+c010452c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010452f:	8b 00                	mov    (%eax),%eax
+c0104531:	83 e0 01             	and    $0x1,%eax
+c0104534:	85 c0                	test   %eax,%eax
+c0104536:	0f 85 af 00 00 00    	jne    c01045eb <get_pte+0xda>
+	struct Page* page;                    // (3) check if creating is needed, then alloc page for page table
+                          // CAUTION: this page is used for page table, not for common data page
+	if (!create || (page = alloc_page()) == NULL) {
+c010453c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0104540:	74 15                	je     c0104557 <get_pte+0x46>
+c0104542:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0104549:	e8 84 f8 ff ff       	call   c0103dd2 <alloc_pages>
+c010454e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104551:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0104555:	75 0a                	jne    c0104561 <get_pte+0x50>
+            return NULL;
+c0104557:	b8 00 00 00 00       	mov    $0x0,%eax
+c010455c:	e9 e6 00 00 00       	jmp    c0104647 <get_pte+0x136>
+        }                          
+	set_page_ref(page, 1);		  // (4) set page reference
+c0104561:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0104568:	00 
+c0104569:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010456c:	89 04 24             	mov    %eax,(%esp)
+c010456f:	e8 63 f6 ff ff       	call   c0103bd7 <set_page_ref>
+        uintptr_t pa = page2pa(page); // (5) get linear address of page
+c0104574:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104577:	89 04 24             	mov    %eax,(%esp)
+c010457a:	e8 57 f5 ff ff       	call   c0103ad6 <page2pa>
+c010457f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        memset(KADDR(pa),0,PGSIZE);                  // (6) clear page content using memset
+c0104582:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104585:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0104588:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010458b:	c1 e8 0c             	shr    $0xc,%eax
+c010458e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0104591:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0104596:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+c0104599:	72 23                	jb     c01045be <get_pte+0xad>
+c010459b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010459e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c01045a2:	c7 44 24 08 3c 6b 10 	movl   $0xc0106b3c,0x8(%esp)
+c01045a9:	c0 
+c01045aa:	c7 44 24 04 7d 01 00 	movl   $0x17d,0x4(%esp)
+c01045b1:	00 
+c01045b2:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01045b9:	e8 02 c7 ff ff       	call   c0100cc0 <__panic>
+c01045be:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01045c1:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c01045c6:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+c01045cd:	00 
+c01045ce:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c01045d5:	00 
+c01045d6:	89 04 24             	mov    %eax,(%esp)
+c01045d9:	e8 e8 18 00 00       	call   c0105ec6 <memset>
+        *pdep = pa | PTE_U | PTE_W | PTE_P;                // (7) set page directory entry's permission
+c01045de:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01045e1:	83 c8 07             	or     $0x7,%eax
+c01045e4:	89 c2                	mov    %eax,%edx
+c01045e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01045e9:	89 10                	mov    %edx,(%eax)
+    }
+    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];          // (8) return page table entry
+c01045eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01045ee:	8b 00                	mov    (%eax),%eax
+c01045f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c01045f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01045f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01045fb:	c1 e8 0c             	shr    $0xc,%eax
+c01045fe:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0104601:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0104606:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+c0104609:	72 23                	jb     c010462e <get_pte+0x11d>
+c010460b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010460e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104612:	c7 44 24 08 3c 6b 10 	movl   $0xc0106b3c,0x8(%esp)
+c0104619:	c0 
+c010461a:	c7 44 24 04 80 01 00 	movl   $0x180,0x4(%esp)
+c0104621:	00 
+c0104622:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104629:	e8 92 c6 ff ff       	call   c0100cc0 <__panic>
+c010462e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104631:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0104636:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0104639:	c1 ea 0c             	shr    $0xc,%edx
+c010463c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
+c0104642:	c1 e2 02             	shl    $0x2,%edx
+c0104645:	01 d0                	add    %edx,%eax
+
+}
+c0104647:	c9                   	leave  
+c0104648:	c3                   	ret    
+
+c0104649 <get_page>:
+
+//get_page - get related Page struct for linear address la using PDT pgdir
+struct Page *
+get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
+c0104649:	55                   	push   %ebp
+c010464a:	89 e5                	mov    %esp,%ebp
+c010464c:	83 ec 28             	sub    $0x28,%esp
+    pte_t *ptep = get_pte(pgdir, la, 0);
+c010464f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104656:	00 
+c0104657:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010465a:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010465e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104661:	89 04 24             	mov    %eax,(%esp)
+c0104664:	e8 a8 fe ff ff       	call   c0104511 <get_pte>
+c0104669:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep_store != NULL) {
+c010466c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0104670:	74 08                	je     c010467a <get_page+0x31>
+        *ptep_store = ptep;
+c0104672:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104675:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0104678:	89 10                	mov    %edx,(%eax)
+    }
+    if (ptep != NULL && *ptep & PTE_P) {
+c010467a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010467e:	74 1b                	je     c010469b <get_page+0x52>
+c0104680:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104683:	8b 00                	mov    (%eax),%eax
+c0104685:	83 e0 01             	and    $0x1,%eax
+c0104688:	85 c0                	test   %eax,%eax
+c010468a:	74 0f                	je     c010469b <get_page+0x52>
+        return pa2page(*ptep);
+c010468c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010468f:	8b 00                	mov    (%eax),%eax
+c0104691:	89 04 24             	mov    %eax,(%esp)
+c0104694:	e8 53 f4 ff ff       	call   c0103aec <pa2page>
+c0104699:	eb 05                	jmp    c01046a0 <get_page+0x57>
+    }
+    return NULL;
+c010469b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01046a0:	c9                   	leave  
+c01046a1:	c3                   	ret    
+
+c01046a2 <page_remove_pte>:
+
+//page_remove_pte - free an Page sturct which is related linear address la
+//                - and clean(invalidate) pte which is related linear address la
+//note: PT is changed, so the TLB need to be invalidate 
+static inline void
+page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
+c01046a2:	55                   	push   %ebp
+c01046a3:	89 e5                	mov    %esp,%ebp
+c01046a5:	83 ec 28             	sub    $0x28,%esp
+     *                        edited are the ones currently in use by the processor.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     */
+
+    if (*ptep & PTE_P) {                      //(1) check if this page table entry is present
+c01046a8:	8b 45 10             	mov    0x10(%ebp),%eax
+c01046ab:	8b 00                	mov    (%eax),%eax
+c01046ad:	83 e0 01             	and    $0x1,%eax
+c01046b0:	85 c0                	test   %eax,%eax
+c01046b2:	74 4d                	je     c0104701 <page_remove_pte+0x5f>
+        struct Page *page = pte2page(*ptep); //(2) find corresponding page to pte
+c01046b4:	8b 45 10             	mov    0x10(%ebp),%eax
+c01046b7:	8b 00                	mov    (%eax),%eax
+c01046b9:	89 04 24             	mov    %eax,(%esp)
+c01046bc:	e8 ce f4 ff ff       	call   c0103b8f <pte2page>
+c01046c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        if (page_ref_dec(page) == 0) {
+c01046c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01046c7:	89 04 24             	mov    %eax,(%esp)
+c01046ca:	e8 2c f5 ff ff       	call   c0103bfb <page_ref_dec>
+c01046cf:	85 c0                	test   %eax,%eax
+c01046d1:	75 13                	jne    c01046e6 <page_remove_pte+0x44>
+            free_page(page);
+c01046d3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01046da:	00 
+c01046db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01046de:	89 04 24             	mov    %eax,(%esp)
+c01046e1:	e8 24 f7 ff ff       	call   c0103e0a <free_pages>
+        }
+        *ptep = 0;
+c01046e6:	8b 45 10             	mov    0x10(%ebp),%eax
+c01046e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+        tlb_invalidate(pgdir, la);
+c01046ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01046f2:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01046f6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01046f9:	89 04 24             	mov    %eax,(%esp)
+c01046fc:	e8 ff 00 00 00       	call   c0104800 <tlb_invalidate>
+                                  //(4) and free this page when page reference reachs 0
+                                  //(5) clear second page table entry
+                                  //(6) flush tlb
+    }
+
+}
+c0104701:	c9                   	leave  
+c0104702:	c3                   	ret    
+
+c0104703 <page_remove>:
+
+//page_remove - free an Page which is related linear address la and has an validated pte
+void
+page_remove(pde_t *pgdir, uintptr_t la) {
+c0104703:	55                   	push   %ebp
+c0104704:	89 e5                	mov    %esp,%ebp
+c0104706:	83 ec 28             	sub    $0x28,%esp
+    pte_t *ptep = get_pte(pgdir, la, 0);
+c0104709:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104710:	00 
+c0104711:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104714:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0104718:	8b 45 08             	mov    0x8(%ebp),%eax
+c010471b:	89 04 24             	mov    %eax,(%esp)
+c010471e:	e8 ee fd ff ff       	call   c0104511 <get_pte>
+c0104723:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep != NULL) {
+c0104726:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010472a:	74 19                	je     c0104745 <page_remove+0x42>
+        page_remove_pte(pgdir, la, ptep);
+c010472c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010472f:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0104733:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104736:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010473a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010473d:	89 04 24             	mov    %eax,(%esp)
+c0104740:	e8 5d ff ff ff       	call   c01046a2 <page_remove_pte>
+    }
+}
+c0104745:	c9                   	leave  
+c0104746:	c3                   	ret    
+
+c0104747 <page_insert>:
+//  la:    the linear address need to map
+//  perm:  the permission of this Page which is setted in related pte
+// return value: always 0
+//note: PT is changed, so the TLB need to be invalidate 
+int
+page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
+c0104747:	55                   	push   %ebp
+c0104748:	89 e5                	mov    %esp,%ebp
+c010474a:	83 ec 28             	sub    $0x28,%esp
+    pte_t *ptep = get_pte(pgdir, la, 1);
+c010474d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+c0104754:	00 
+c0104755:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104758:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010475c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010475f:	89 04 24             	mov    %eax,(%esp)
+c0104762:	e8 aa fd ff ff       	call   c0104511 <get_pte>
+c0104767:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep == NULL) {
+c010476a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010476e:	75 0a                	jne    c010477a <page_insert+0x33>
+        return -E_NO_MEM;
+c0104770:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+c0104775:	e9 84 00 00 00       	jmp    c01047fe <page_insert+0xb7>
+    }
+    page_ref_inc(page);
+c010477a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010477d:	89 04 24             	mov    %eax,(%esp)
+c0104780:	e8 5f f4 ff ff       	call   c0103be4 <page_ref_inc>
+    if (*ptep & PTE_P) {
+c0104785:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104788:	8b 00                	mov    (%eax),%eax
+c010478a:	83 e0 01             	and    $0x1,%eax
+c010478d:	85 c0                	test   %eax,%eax
+c010478f:	74 3e                	je     c01047cf <page_insert+0x88>
+        struct Page *p = pte2page(*ptep);
+c0104791:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104794:	8b 00                	mov    (%eax),%eax
+c0104796:	89 04 24             	mov    %eax,(%esp)
+c0104799:	e8 f1 f3 ff ff       	call   c0103b8f <pte2page>
+c010479e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (p == page) {
+c01047a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01047a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c01047a7:	75 0d                	jne    c01047b6 <page_insert+0x6f>
+            page_ref_dec(page);
+c01047a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01047ac:	89 04 24             	mov    %eax,(%esp)
+c01047af:	e8 47 f4 ff ff       	call   c0103bfb <page_ref_dec>
+c01047b4:	eb 19                	jmp    c01047cf <page_insert+0x88>
+        }
+        else {
+            page_remove_pte(pgdir, la, ptep);
+c01047b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01047b9:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01047bd:	8b 45 10             	mov    0x10(%ebp),%eax
+c01047c0:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01047c4:	8b 45 08             	mov    0x8(%ebp),%eax
+c01047c7:	89 04 24             	mov    %eax,(%esp)
+c01047ca:	e8 d3 fe ff ff       	call   c01046a2 <page_remove_pte>
+        }
+    }
+    *ptep = page2pa(page) | PTE_P | perm;
+c01047cf:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01047d2:	89 04 24             	mov    %eax,(%esp)
+c01047d5:	e8 fc f2 ff ff       	call   c0103ad6 <page2pa>
+c01047da:	0b 45 14             	or     0x14(%ebp),%eax
+c01047dd:	83 c8 01             	or     $0x1,%eax
+c01047e0:	89 c2                	mov    %eax,%edx
+c01047e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01047e5:	89 10                	mov    %edx,(%eax)
+    tlb_invalidate(pgdir, la);
+c01047e7:	8b 45 10             	mov    0x10(%ebp),%eax
+c01047ea:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01047ee:	8b 45 08             	mov    0x8(%ebp),%eax
+c01047f1:	89 04 24             	mov    %eax,(%esp)
+c01047f4:	e8 07 00 00 00       	call   c0104800 <tlb_invalidate>
+    return 0;
+c01047f9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01047fe:	c9                   	leave  
+c01047ff:	c3                   	ret    
+
+c0104800 <tlb_invalidate>:
+
+// invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+void
+tlb_invalidate(pde_t *pgdir, uintptr_t la) {
+c0104800:	55                   	push   %ebp
+c0104801:	89 e5                	mov    %esp,%ebp
+c0104803:	83 ec 28             	sub    $0x28,%esp
+}
+
+static inline uintptr_t
+rcr3(void) {
+    uintptr_t cr3;
+    asm volatile ("mov %%cr3, %0" : "=r" (cr3) :: "memory");
+c0104806:	0f 20 d8             	mov    %cr3,%eax
+c0104809:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    return cr3;
+c010480c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    if (rcr3() == PADDR(pgdir)) {
+c010480f:	89 c2                	mov    %eax,%edx
+c0104811:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104814:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104817:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+c010481e:	77 23                	ja     c0104843 <tlb_invalidate+0x43>
+c0104820:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104823:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104827:	c7 44 24 08 e0 6b 10 	movl   $0xc0106be0,0x8(%esp)
+c010482e:	c0 
+c010482f:	c7 44 24 04 e0 01 00 	movl   $0x1e0,0x4(%esp)
+c0104836:	00 
+c0104837:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c010483e:	e8 7d c4 ff ff       	call   c0100cc0 <__panic>
+c0104843:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104846:	05 00 00 00 40       	add    $0x40000000,%eax
+c010484b:	39 c2                	cmp    %eax,%edx
+c010484d:	75 0c                	jne    c010485b <tlb_invalidate+0x5b>
+        invlpg((void *)la);
+c010484f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104852:	89 45 ec             	mov    %eax,-0x14(%ebp)
+}
+
+static inline void
+invlpg(void *addr) {
+    asm volatile ("invlpg (%0)" :: "r" (addr) : "memory");
+c0104855:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104858:	0f 01 38             	invlpg (%eax)
+    }
+}
+c010485b:	c9                   	leave  
+c010485c:	c3                   	ret    
+
+c010485d <check_alloc_page>:
+
+static void
+check_alloc_page(void) {
+c010485d:	55                   	push   %ebp
+c010485e:	89 e5                	mov    %esp,%ebp
+c0104860:	83 ec 18             	sub    $0x18,%esp
+    pmm_manager->check();
+c0104863:	a1 bc 89 11 c0       	mov    0xc01189bc,%eax
+c0104868:	8b 40 18             	mov    0x18(%eax),%eax
+c010486b:	ff d0                	call   *%eax
+    cprintf("check_alloc_page() succeeded!\n");
+c010486d:	c7 04 24 64 6c 10 c0 	movl   $0xc0106c64,(%esp)
+c0104874:	e8 c3 ba ff ff       	call   c010033c <cprintf>
+}
+c0104879:	c9                   	leave  
+c010487a:	c3                   	ret    
+
+c010487b <check_pgdir>:
+
+static void
+check_pgdir(void) {
+c010487b:	55                   	push   %ebp
+c010487c:	89 e5                	mov    %esp,%ebp
+c010487e:	83 ec 38             	sub    $0x38,%esp
+    assert(npage <= KMEMSIZE / PGSIZE);
+c0104881:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0104886:	3d 00 80 03 00       	cmp    $0x38000,%eax
+c010488b:	76 24                	jbe    c01048b1 <check_pgdir+0x36>
+c010488d:	c7 44 24 0c 83 6c 10 	movl   $0xc0106c83,0xc(%esp)
+c0104894:	c0 
+c0104895:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c010489c:	c0 
+c010489d:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
+c01048a4:	00 
+c01048a5:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01048ac:	e8 0f c4 ff ff       	call   c0100cc0 <__panic>
+    assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
+c01048b1:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c01048b6:	85 c0                	test   %eax,%eax
+c01048b8:	74 0e                	je     c01048c8 <check_pgdir+0x4d>
+c01048ba:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c01048bf:	25 ff 0f 00 00       	and    $0xfff,%eax
+c01048c4:	85 c0                	test   %eax,%eax
+c01048c6:	74 24                	je     c01048ec <check_pgdir+0x71>
+c01048c8:	c7 44 24 0c a0 6c 10 	movl   $0xc0106ca0,0xc(%esp)
+c01048cf:	c0 
+c01048d0:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c01048d7:	c0 
+c01048d8:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
+c01048df:	00 
+c01048e0:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01048e7:	e8 d4 c3 ff ff       	call   c0100cc0 <__panic>
+    assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
+c01048ec:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c01048f1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c01048f8:	00 
+c01048f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0104900:	00 
+c0104901:	89 04 24             	mov    %eax,(%esp)
+c0104904:	e8 40 fd ff ff       	call   c0104649 <get_page>
+c0104909:	85 c0                	test   %eax,%eax
+c010490b:	74 24                	je     c0104931 <check_pgdir+0xb6>
+c010490d:	c7 44 24 0c d8 6c 10 	movl   $0xc0106cd8,0xc(%esp)
+c0104914:	c0 
+c0104915:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c010491c:	c0 
+c010491d:	c7 44 24 04 ef 01 00 	movl   $0x1ef,0x4(%esp)
+c0104924:	00 
+c0104925:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c010492c:	e8 8f c3 ff ff       	call   c0100cc0 <__panic>
+
+    struct Page *p1, *p2;
+    p1 = alloc_page();
+c0104931:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0104938:	e8 95 f4 ff ff       	call   c0103dd2 <alloc_pages>
+c010493d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
+c0104940:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104945:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+c010494c:	00 
+c010494d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104954:	00 
+c0104955:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0104958:	89 54 24 04          	mov    %edx,0x4(%esp)
+c010495c:	89 04 24             	mov    %eax,(%esp)
+c010495f:	e8 e3 fd ff ff       	call   c0104747 <page_insert>
+c0104964:	85 c0                	test   %eax,%eax
+c0104966:	74 24                	je     c010498c <check_pgdir+0x111>
+c0104968:	c7 44 24 0c 00 6d 10 	movl   $0xc0106d00,0xc(%esp)
+c010496f:	c0 
+c0104970:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104977:	c0 
+c0104978:	c7 44 24 04 f3 01 00 	movl   $0x1f3,0x4(%esp)
+c010497f:	00 
+c0104980:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104987:	e8 34 c3 ff ff       	call   c0100cc0 <__panic>
+
+    pte_t *ptep;
+    assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
+c010498c:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104991:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104998:	00 
+c0104999:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c01049a0:	00 
+c01049a1:	89 04 24             	mov    %eax,(%esp)
+c01049a4:	e8 68 fb ff ff       	call   c0104511 <get_pte>
+c01049a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01049ac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01049b0:	75 24                	jne    c01049d6 <check_pgdir+0x15b>
+c01049b2:	c7 44 24 0c 2c 6d 10 	movl   $0xc0106d2c,0xc(%esp)
+c01049b9:	c0 
+c01049ba:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c01049c1:	c0 
+c01049c2:	c7 44 24 04 f6 01 00 	movl   $0x1f6,0x4(%esp)
+c01049c9:	00 
+c01049ca:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01049d1:	e8 ea c2 ff ff       	call   c0100cc0 <__panic>
+    assert(pa2page(*ptep) == p1);
+c01049d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01049d9:	8b 00                	mov    (%eax),%eax
+c01049db:	89 04 24             	mov    %eax,(%esp)
+c01049de:	e8 09 f1 ff ff       	call   c0103aec <pa2page>
+c01049e3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c01049e6:	74 24                	je     c0104a0c <check_pgdir+0x191>
+c01049e8:	c7 44 24 0c 59 6d 10 	movl   $0xc0106d59,0xc(%esp)
+c01049ef:	c0 
+c01049f0:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c01049f7:	c0 
+c01049f8:	c7 44 24 04 f7 01 00 	movl   $0x1f7,0x4(%esp)
+c01049ff:	00 
+c0104a00:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104a07:	e8 b4 c2 ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p1) == 1);
+c0104a0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104a0f:	89 04 24             	mov    %eax,(%esp)
+c0104a12:	e8 b6 f1 ff ff       	call   c0103bcd <page_ref>
+c0104a17:	83 f8 01             	cmp    $0x1,%eax
+c0104a1a:	74 24                	je     c0104a40 <check_pgdir+0x1c5>
+c0104a1c:	c7 44 24 0c 6e 6d 10 	movl   $0xc0106d6e,0xc(%esp)
+c0104a23:	c0 
+c0104a24:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104a2b:	c0 
+c0104a2c:	c7 44 24 04 f8 01 00 	movl   $0x1f8,0x4(%esp)
+c0104a33:	00 
+c0104a34:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104a3b:	e8 80 c2 ff ff       	call   c0100cc0 <__panic>
+
+    ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
+c0104a40:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104a45:	8b 00                	mov    (%eax),%eax
+c0104a47:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104a4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0104a4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104a52:	c1 e8 0c             	shr    $0xc,%eax
+c0104a55:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0104a58:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0104a5d:	39 45 e8             	cmp    %eax,-0x18(%ebp)
+c0104a60:	72 23                	jb     c0104a85 <check_pgdir+0x20a>
+c0104a62:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104a65:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104a69:	c7 44 24 08 3c 6b 10 	movl   $0xc0106b3c,0x8(%esp)
+c0104a70:	c0 
+c0104a71:	c7 44 24 04 fa 01 00 	movl   $0x1fa,0x4(%esp)
+c0104a78:	00 
+c0104a79:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104a80:	e8 3b c2 ff ff       	call   c0100cc0 <__panic>
+c0104a85:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104a88:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0104a8d:	83 c0 04             	add    $0x4,%eax
+c0104a90:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
+c0104a93:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104a98:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104a9f:	00 
+c0104aa0:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c0104aa7:	00 
+c0104aa8:	89 04 24             	mov    %eax,(%esp)
+c0104aab:	e8 61 fa ff ff       	call   c0104511 <get_pte>
+c0104ab0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0104ab3:	74 24                	je     c0104ad9 <check_pgdir+0x25e>
+c0104ab5:	c7 44 24 0c 80 6d 10 	movl   $0xc0106d80,0xc(%esp)
+c0104abc:	c0 
+c0104abd:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104ac4:	c0 
+c0104ac5:	c7 44 24 04 fb 01 00 	movl   $0x1fb,0x4(%esp)
+c0104acc:	00 
+c0104acd:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104ad4:	e8 e7 c1 ff ff       	call   c0100cc0 <__panic>
+
+    p2 = alloc_page();
+c0104ad9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0104ae0:	e8 ed f2 ff ff       	call   c0103dd2 <alloc_pages>
+c0104ae5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
+c0104ae8:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104aed:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
+c0104af4:	00 
+c0104af5:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+c0104afc:	00 
+c0104afd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0104b00:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0104b04:	89 04 24             	mov    %eax,(%esp)
+c0104b07:	e8 3b fc ff ff       	call   c0104747 <page_insert>
+c0104b0c:	85 c0                	test   %eax,%eax
+c0104b0e:	74 24                	je     c0104b34 <check_pgdir+0x2b9>
+c0104b10:	c7 44 24 0c a8 6d 10 	movl   $0xc0106da8,0xc(%esp)
+c0104b17:	c0 
+c0104b18:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104b1f:	c0 
+c0104b20:	c7 44 24 04 fe 01 00 	movl   $0x1fe,0x4(%esp)
+c0104b27:	00 
+c0104b28:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104b2f:	e8 8c c1 ff ff       	call   c0100cc0 <__panic>
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+c0104b34:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104b39:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104b40:	00 
+c0104b41:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c0104b48:	00 
+c0104b49:	89 04 24             	mov    %eax,(%esp)
+c0104b4c:	e8 c0 f9 ff ff       	call   c0104511 <get_pte>
+c0104b51:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104b54:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0104b58:	75 24                	jne    c0104b7e <check_pgdir+0x303>
+c0104b5a:	c7 44 24 0c e0 6d 10 	movl   $0xc0106de0,0xc(%esp)
+c0104b61:	c0 
+c0104b62:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104b69:	c0 
+c0104b6a:	c7 44 24 04 ff 01 00 	movl   $0x1ff,0x4(%esp)
+c0104b71:	00 
+c0104b72:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104b79:	e8 42 c1 ff ff       	call   c0100cc0 <__panic>
+    assert(*ptep & PTE_U);
+c0104b7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104b81:	8b 00                	mov    (%eax),%eax
+c0104b83:	83 e0 04             	and    $0x4,%eax
+c0104b86:	85 c0                	test   %eax,%eax
+c0104b88:	75 24                	jne    c0104bae <check_pgdir+0x333>
+c0104b8a:	c7 44 24 0c 10 6e 10 	movl   $0xc0106e10,0xc(%esp)
+c0104b91:	c0 
+c0104b92:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104b99:	c0 
+c0104b9a:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+c0104ba1:	00 
+c0104ba2:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104ba9:	e8 12 c1 ff ff       	call   c0100cc0 <__panic>
+    assert(*ptep & PTE_W);
+c0104bae:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104bb1:	8b 00                	mov    (%eax),%eax
+c0104bb3:	83 e0 02             	and    $0x2,%eax
+c0104bb6:	85 c0                	test   %eax,%eax
+c0104bb8:	75 24                	jne    c0104bde <check_pgdir+0x363>
+c0104bba:	c7 44 24 0c 1e 6e 10 	movl   $0xc0106e1e,0xc(%esp)
+c0104bc1:	c0 
+c0104bc2:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104bc9:	c0 
+c0104bca:	c7 44 24 04 01 02 00 	movl   $0x201,0x4(%esp)
+c0104bd1:	00 
+c0104bd2:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104bd9:	e8 e2 c0 ff ff       	call   c0100cc0 <__panic>
+    assert(boot_pgdir[0] & PTE_U);
+c0104bde:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104be3:	8b 00                	mov    (%eax),%eax
+c0104be5:	83 e0 04             	and    $0x4,%eax
+c0104be8:	85 c0                	test   %eax,%eax
+c0104bea:	75 24                	jne    c0104c10 <check_pgdir+0x395>
+c0104bec:	c7 44 24 0c 2c 6e 10 	movl   $0xc0106e2c,0xc(%esp)
+c0104bf3:	c0 
+c0104bf4:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104bfb:	c0 
+c0104bfc:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+c0104c03:	00 
+c0104c04:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104c0b:	e8 b0 c0 ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p2) == 1);
+c0104c10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104c13:	89 04 24             	mov    %eax,(%esp)
+c0104c16:	e8 b2 ef ff ff       	call   c0103bcd <page_ref>
+c0104c1b:	83 f8 01             	cmp    $0x1,%eax
+c0104c1e:	74 24                	je     c0104c44 <check_pgdir+0x3c9>
+c0104c20:	c7 44 24 0c 42 6e 10 	movl   $0xc0106e42,0xc(%esp)
+c0104c27:	c0 
+c0104c28:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104c2f:	c0 
+c0104c30:	c7 44 24 04 03 02 00 	movl   $0x203,0x4(%esp)
+c0104c37:	00 
+c0104c38:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104c3f:	e8 7c c0 ff ff       	call   c0100cc0 <__panic>
+
+    assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
+c0104c44:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104c49:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+c0104c50:	00 
+c0104c51:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+c0104c58:	00 
+c0104c59:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0104c5c:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0104c60:	89 04 24             	mov    %eax,(%esp)
+c0104c63:	e8 df fa ff ff       	call   c0104747 <page_insert>
+c0104c68:	85 c0                	test   %eax,%eax
+c0104c6a:	74 24                	je     c0104c90 <check_pgdir+0x415>
+c0104c6c:	c7 44 24 0c 54 6e 10 	movl   $0xc0106e54,0xc(%esp)
+c0104c73:	c0 
+c0104c74:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104c7b:	c0 
+c0104c7c:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
+c0104c83:	00 
+c0104c84:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104c8b:	e8 30 c0 ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p1) == 2);
+c0104c90:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104c93:	89 04 24             	mov    %eax,(%esp)
+c0104c96:	e8 32 ef ff ff       	call   c0103bcd <page_ref>
+c0104c9b:	83 f8 02             	cmp    $0x2,%eax
+c0104c9e:	74 24                	je     c0104cc4 <check_pgdir+0x449>
+c0104ca0:	c7 44 24 0c 80 6e 10 	movl   $0xc0106e80,0xc(%esp)
+c0104ca7:	c0 
+c0104ca8:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104caf:	c0 
+c0104cb0:	c7 44 24 04 06 02 00 	movl   $0x206,0x4(%esp)
+c0104cb7:	00 
+c0104cb8:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104cbf:	e8 fc bf ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p2) == 0);
+c0104cc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104cc7:	89 04 24             	mov    %eax,(%esp)
+c0104cca:	e8 fe ee ff ff       	call   c0103bcd <page_ref>
+c0104ccf:	85 c0                	test   %eax,%eax
+c0104cd1:	74 24                	je     c0104cf7 <check_pgdir+0x47c>
+c0104cd3:	c7 44 24 0c 92 6e 10 	movl   $0xc0106e92,0xc(%esp)
+c0104cda:	c0 
+c0104cdb:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104ce2:	c0 
+c0104ce3:	c7 44 24 04 07 02 00 	movl   $0x207,0x4(%esp)
+c0104cea:	00 
+c0104ceb:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104cf2:	e8 c9 bf ff ff       	call   c0100cc0 <__panic>
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+c0104cf7:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104cfc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104d03:	00 
+c0104d04:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c0104d0b:	00 
+c0104d0c:	89 04 24             	mov    %eax,(%esp)
+c0104d0f:	e8 fd f7 ff ff       	call   c0104511 <get_pte>
+c0104d14:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104d17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0104d1b:	75 24                	jne    c0104d41 <check_pgdir+0x4c6>
+c0104d1d:	c7 44 24 0c e0 6d 10 	movl   $0xc0106de0,0xc(%esp)
+c0104d24:	c0 
+c0104d25:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104d2c:	c0 
+c0104d2d:	c7 44 24 04 08 02 00 	movl   $0x208,0x4(%esp)
+c0104d34:	00 
+c0104d35:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104d3c:	e8 7f bf ff ff       	call   c0100cc0 <__panic>
+    assert(pa2page(*ptep) == p1);
+c0104d41:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104d44:	8b 00                	mov    (%eax),%eax
+c0104d46:	89 04 24             	mov    %eax,(%esp)
+c0104d49:	e8 9e ed ff ff       	call   c0103aec <pa2page>
+c0104d4e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0104d51:	74 24                	je     c0104d77 <check_pgdir+0x4fc>
+c0104d53:	c7 44 24 0c 59 6d 10 	movl   $0xc0106d59,0xc(%esp)
+c0104d5a:	c0 
+c0104d5b:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104d62:	c0 
+c0104d63:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
+c0104d6a:	00 
+c0104d6b:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104d72:	e8 49 bf ff ff       	call   c0100cc0 <__panic>
+    assert((*ptep & PTE_U) == 0);
+c0104d77:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104d7a:	8b 00                	mov    (%eax),%eax
+c0104d7c:	83 e0 04             	and    $0x4,%eax
+c0104d7f:	85 c0                	test   %eax,%eax
+c0104d81:	74 24                	je     c0104da7 <check_pgdir+0x52c>
+c0104d83:	c7 44 24 0c a4 6e 10 	movl   $0xc0106ea4,0xc(%esp)
+c0104d8a:	c0 
+c0104d8b:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104d92:	c0 
+c0104d93:	c7 44 24 04 0a 02 00 	movl   $0x20a,0x4(%esp)
+c0104d9a:	00 
+c0104d9b:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104da2:	e8 19 bf ff ff       	call   c0100cc0 <__panic>
+
+    page_remove(boot_pgdir, 0x0);
+c0104da7:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104dac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0104db3:	00 
+c0104db4:	89 04 24             	mov    %eax,(%esp)
+c0104db7:	e8 47 f9 ff ff       	call   c0104703 <page_remove>
+    assert(page_ref(p1) == 1);
+c0104dbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104dbf:	89 04 24             	mov    %eax,(%esp)
+c0104dc2:	e8 06 ee ff ff       	call   c0103bcd <page_ref>
+c0104dc7:	83 f8 01             	cmp    $0x1,%eax
+c0104dca:	74 24                	je     c0104df0 <check_pgdir+0x575>
+c0104dcc:	c7 44 24 0c 6e 6d 10 	movl   $0xc0106d6e,0xc(%esp)
+c0104dd3:	c0 
+c0104dd4:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104ddb:	c0 
+c0104ddc:	c7 44 24 04 0d 02 00 	movl   $0x20d,0x4(%esp)
+c0104de3:	00 
+c0104de4:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104deb:	e8 d0 be ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p2) == 0);
+c0104df0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104df3:	89 04 24             	mov    %eax,(%esp)
+c0104df6:	e8 d2 ed ff ff       	call   c0103bcd <page_ref>
+c0104dfb:	85 c0                	test   %eax,%eax
+c0104dfd:	74 24                	je     c0104e23 <check_pgdir+0x5a8>
+c0104dff:	c7 44 24 0c 92 6e 10 	movl   $0xc0106e92,0xc(%esp)
+c0104e06:	c0 
+c0104e07:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104e0e:	c0 
+c0104e0f:	c7 44 24 04 0e 02 00 	movl   $0x20e,0x4(%esp)
+c0104e16:	00 
+c0104e17:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104e1e:	e8 9d be ff ff       	call   c0100cc0 <__panic>
+
+    page_remove(boot_pgdir, PGSIZE);
+c0104e23:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104e28:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c0104e2f:	00 
+c0104e30:	89 04 24             	mov    %eax,(%esp)
+c0104e33:	e8 cb f8 ff ff       	call   c0104703 <page_remove>
+    assert(page_ref(p1) == 0);
+c0104e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104e3b:	89 04 24             	mov    %eax,(%esp)
+c0104e3e:	e8 8a ed ff ff       	call   c0103bcd <page_ref>
+c0104e43:	85 c0                	test   %eax,%eax
+c0104e45:	74 24                	je     c0104e6b <check_pgdir+0x5f0>
+c0104e47:	c7 44 24 0c b9 6e 10 	movl   $0xc0106eb9,0xc(%esp)
+c0104e4e:	c0 
+c0104e4f:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104e56:	c0 
+c0104e57:	c7 44 24 04 11 02 00 	movl   $0x211,0x4(%esp)
+c0104e5e:	00 
+c0104e5f:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104e66:	e8 55 be ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p2) == 0);
+c0104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104e6e:	89 04 24             	mov    %eax,(%esp)
+c0104e71:	e8 57 ed ff ff       	call   c0103bcd <page_ref>
+c0104e76:	85 c0                	test   %eax,%eax
+c0104e78:	74 24                	je     c0104e9e <check_pgdir+0x623>
+c0104e7a:	c7 44 24 0c 92 6e 10 	movl   $0xc0106e92,0xc(%esp)
+c0104e81:	c0 
+c0104e82:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104e89:	c0 
+c0104e8a:	c7 44 24 04 12 02 00 	movl   $0x212,0x4(%esp)
+c0104e91:	00 
+c0104e92:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104e99:	e8 22 be ff ff       	call   c0100cc0 <__panic>
+
+    assert(page_ref(pa2page(boot_pgdir[0])) == 1);
+c0104e9e:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104ea3:	8b 00                	mov    (%eax),%eax
+c0104ea5:	89 04 24             	mov    %eax,(%esp)
+c0104ea8:	e8 3f ec ff ff       	call   c0103aec <pa2page>
+c0104ead:	89 04 24             	mov    %eax,(%esp)
+c0104eb0:	e8 18 ed ff ff       	call   c0103bcd <page_ref>
+c0104eb5:	83 f8 01             	cmp    $0x1,%eax
+c0104eb8:	74 24                	je     c0104ede <check_pgdir+0x663>
+c0104eba:	c7 44 24 0c cc 6e 10 	movl   $0xc0106ecc,0xc(%esp)
+c0104ec1:	c0 
+c0104ec2:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104ec9:	c0 
+c0104eca:	c7 44 24 04 14 02 00 	movl   $0x214,0x4(%esp)
+c0104ed1:	00 
+c0104ed2:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104ed9:	e8 e2 bd ff ff       	call   c0100cc0 <__panic>
+    free_page(pa2page(boot_pgdir[0]));
+c0104ede:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104ee3:	8b 00                	mov    (%eax),%eax
+c0104ee5:	89 04 24             	mov    %eax,(%esp)
+c0104ee8:	e8 ff eb ff ff       	call   c0103aec <pa2page>
+c0104eed:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0104ef4:	00 
+c0104ef5:	89 04 24             	mov    %eax,(%esp)
+c0104ef8:	e8 0d ef ff ff       	call   c0103e0a <free_pages>
+    boot_pgdir[0] = 0;
+c0104efd:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104f02:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    cprintf("check_pgdir() succeeded!\n");
+c0104f08:	c7 04 24 f2 6e 10 c0 	movl   $0xc0106ef2,(%esp)
+c0104f0f:	e8 28 b4 ff ff       	call   c010033c <cprintf>
+}
+c0104f14:	c9                   	leave  
+c0104f15:	c3                   	ret    
+
+c0104f16 <check_boot_pgdir>:
+
+static void
+check_boot_pgdir(void) {
+c0104f16:	55                   	push   %ebp
+c0104f17:	89 e5                	mov    %esp,%ebp
+c0104f19:	83 ec 38             	sub    $0x38,%esp
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+c0104f1c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0104f23:	e9 ca 00 00 00       	jmp    c0104ff2 <check_boot_pgdir+0xdc>
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+c0104f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104f2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104f2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104f31:	c1 e8 0c             	shr    $0xc,%eax
+c0104f34:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0104f37:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0104f3c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+c0104f3f:	72 23                	jb     c0104f64 <check_boot_pgdir+0x4e>
+c0104f41:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104f44:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104f48:	c7 44 24 08 3c 6b 10 	movl   $0xc0106b3c,0x8(%esp)
+c0104f4f:	c0 
+c0104f50:	c7 44 24 04 20 02 00 	movl   $0x220,0x4(%esp)
+c0104f57:	00 
+c0104f58:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104f5f:	e8 5c bd ff ff       	call   c0100cc0 <__panic>
+c0104f64:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104f67:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0104f6c:	89 c2                	mov    %eax,%edx
+c0104f6e:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0104f73:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104f7a:	00 
+c0104f7b:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0104f7f:	89 04 24             	mov    %eax,(%esp)
+c0104f82:	e8 8a f5 ff ff       	call   c0104511 <get_pte>
+c0104f87:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0104f8a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0104f8e:	75 24                	jne    c0104fb4 <check_boot_pgdir+0x9e>
+c0104f90:	c7 44 24 0c 0c 6f 10 	movl   $0xc0106f0c,0xc(%esp)
+c0104f97:	c0 
+c0104f98:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104f9f:	c0 
+c0104fa0:	c7 44 24 04 20 02 00 	movl   $0x220,0x4(%esp)
+c0104fa7:	00 
+c0104fa8:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104faf:	e8 0c bd ff ff       	call   c0100cc0 <__panic>
+        assert(PTE_ADDR(*ptep) == i);
+c0104fb4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0104fb7:	8b 00                	mov    (%eax),%eax
+c0104fb9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104fbe:	89 c2                	mov    %eax,%edx
+c0104fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104fc3:	39 c2                	cmp    %eax,%edx
+c0104fc5:	74 24                	je     c0104feb <check_boot_pgdir+0xd5>
+c0104fc7:	c7 44 24 0c 49 6f 10 	movl   $0xc0106f49,0xc(%esp)
+c0104fce:	c0 
+c0104fcf:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0104fd6:	c0 
+c0104fd7:	c7 44 24 04 21 02 00 	movl   $0x221,0x4(%esp)
+c0104fde:	00 
+c0104fdf:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0104fe6:	e8 d5 bc ff ff       	call   c0100cc0 <__panic>
+
+static void
+check_boot_pgdir(void) {
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+c0104feb:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+c0104ff2:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0104ff5:	a1 c0 88 11 c0       	mov    0xc01188c0,%eax
+c0104ffa:	39 c2                	cmp    %eax,%edx
+c0104ffc:	0f 82 26 ff ff ff    	jb     c0104f28 <check_boot_pgdir+0x12>
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+        assert(PTE_ADDR(*ptep) == i);
+    }
+
+    assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
+c0105002:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0105007:	05 ac 0f 00 00       	add    $0xfac,%eax
+c010500c:	8b 00                	mov    (%eax),%eax
+c010500e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0105013:	89 c2                	mov    %eax,%edx
+c0105015:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c010501a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010501d:	81 7d e4 ff ff ff bf 	cmpl   $0xbfffffff,-0x1c(%ebp)
+c0105024:	77 23                	ja     c0105049 <check_boot_pgdir+0x133>
+c0105026:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105029:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c010502d:	c7 44 24 08 e0 6b 10 	movl   $0xc0106be0,0x8(%esp)
+c0105034:	c0 
+c0105035:	c7 44 24 04 24 02 00 	movl   $0x224,0x4(%esp)
+c010503c:	00 
+c010503d:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0105044:	e8 77 bc ff ff       	call   c0100cc0 <__panic>
+c0105049:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010504c:	05 00 00 00 40       	add    $0x40000000,%eax
+c0105051:	39 c2                	cmp    %eax,%edx
+c0105053:	74 24                	je     c0105079 <check_boot_pgdir+0x163>
+c0105055:	c7 44 24 0c 60 6f 10 	movl   $0xc0106f60,0xc(%esp)
+c010505c:	c0 
+c010505d:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0105064:	c0 
+c0105065:	c7 44 24 04 24 02 00 	movl   $0x224,0x4(%esp)
+c010506c:	00 
+c010506d:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0105074:	e8 47 bc ff ff       	call   c0100cc0 <__panic>
+
+    assert(boot_pgdir[0] == 0);
+c0105079:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c010507e:	8b 00                	mov    (%eax),%eax
+c0105080:	85 c0                	test   %eax,%eax
+c0105082:	74 24                	je     c01050a8 <check_boot_pgdir+0x192>
+c0105084:	c7 44 24 0c 94 6f 10 	movl   $0xc0106f94,0xc(%esp)
+c010508b:	c0 
+c010508c:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0105093:	c0 
+c0105094:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
+c010509b:	00 
+c010509c:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01050a3:	e8 18 bc ff ff       	call   c0100cc0 <__panic>
+
+    struct Page *p;
+    p = alloc_page();
+c01050a8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01050af:	e8 1e ed ff ff       	call   c0103dd2 <alloc_pages>
+c01050b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
+c01050b7:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c01050bc:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+c01050c3:	00 
+c01050c4:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
+c01050cb:	00 
+c01050cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01050cf:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01050d3:	89 04 24             	mov    %eax,(%esp)
+c01050d6:	e8 6c f6 ff ff       	call   c0104747 <page_insert>
+c01050db:	85 c0                	test   %eax,%eax
+c01050dd:	74 24                	je     c0105103 <check_boot_pgdir+0x1ed>
+c01050df:	c7 44 24 0c a8 6f 10 	movl   $0xc0106fa8,0xc(%esp)
+c01050e6:	c0 
+c01050e7:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c01050ee:	c0 
+c01050ef:	c7 44 24 04 2a 02 00 	movl   $0x22a,0x4(%esp)
+c01050f6:	00 
+c01050f7:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01050fe:	e8 bd bb ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p) == 1);
+c0105103:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105106:	89 04 24             	mov    %eax,(%esp)
+c0105109:	e8 bf ea ff ff       	call   c0103bcd <page_ref>
+c010510e:	83 f8 01             	cmp    $0x1,%eax
+c0105111:	74 24                	je     c0105137 <check_boot_pgdir+0x221>
+c0105113:	c7 44 24 0c d6 6f 10 	movl   $0xc0106fd6,0xc(%esp)
+c010511a:	c0 
+c010511b:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c0105122:	c0 
+c0105123:	c7 44 24 04 2b 02 00 	movl   $0x22b,0x4(%esp)
+c010512a:	00 
+c010512b:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0105132:	e8 89 bb ff ff       	call   c0100cc0 <__panic>
+    assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
+c0105137:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c010513c:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+c0105143:	00 
+c0105144:	c7 44 24 08 00 11 00 	movl   $0x1100,0x8(%esp)
+c010514b:	00 
+c010514c:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c010514f:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105153:	89 04 24             	mov    %eax,(%esp)
+c0105156:	e8 ec f5 ff ff       	call   c0104747 <page_insert>
+c010515b:	85 c0                	test   %eax,%eax
+c010515d:	74 24                	je     c0105183 <check_boot_pgdir+0x26d>
+c010515f:	c7 44 24 0c e8 6f 10 	movl   $0xc0106fe8,0xc(%esp)
+c0105166:	c0 
+c0105167:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c010516e:	c0 
+c010516f:	c7 44 24 04 2c 02 00 	movl   $0x22c,0x4(%esp)
+c0105176:	00 
+c0105177:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c010517e:	e8 3d bb ff ff       	call   c0100cc0 <__panic>
+    assert(page_ref(p) == 2);
+c0105183:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105186:	89 04 24             	mov    %eax,(%esp)
+c0105189:	e8 3f ea ff ff       	call   c0103bcd <page_ref>
+c010518e:	83 f8 02             	cmp    $0x2,%eax
+c0105191:	74 24                	je     c01051b7 <check_boot_pgdir+0x2a1>
+c0105193:	c7 44 24 0c 1f 70 10 	movl   $0xc010701f,0xc(%esp)
+c010519a:	c0 
+c010519b:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c01051a2:	c0 
+c01051a3:	c7 44 24 04 2d 02 00 	movl   $0x22d,0x4(%esp)
+c01051aa:	00 
+c01051ab:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c01051b2:	e8 09 bb ff ff       	call   c0100cc0 <__panic>
+
+    const char *str = "ucore: Hello world!!";
+c01051b7:	c7 45 dc 30 70 10 c0 	movl   $0xc0107030,-0x24(%ebp)
+    strcpy((void *)0x100, str);
+c01051be:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01051c1:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01051c5:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+c01051cc:	e8 1e 0a 00 00       	call   c0105bef <strcpy>
+    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
+c01051d1:	c7 44 24 04 00 11 00 	movl   $0x1100,0x4(%esp)
+c01051d8:	00 
+c01051d9:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+c01051e0:	e8 83 0a 00 00       	call   c0105c68 <strcmp>
+c01051e5:	85 c0                	test   %eax,%eax
+c01051e7:	74 24                	je     c010520d <check_boot_pgdir+0x2f7>
+c01051e9:	c7 44 24 0c 48 70 10 	movl   $0xc0107048,0xc(%esp)
+c01051f0:	c0 
+c01051f1:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c01051f8:	c0 
+c01051f9:	c7 44 24 04 31 02 00 	movl   $0x231,0x4(%esp)
+c0105200:	00 
+c0105201:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c0105208:	e8 b3 ba ff ff       	call   c0100cc0 <__panic>
+
+    *(char *)(page2kva(p) + 0x100) = '\0';
+c010520d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105210:	89 04 24             	mov    %eax,(%esp)
+c0105213:	e8 23 e9 ff ff       	call   c0103b3b <page2kva>
+c0105218:	05 00 01 00 00       	add    $0x100,%eax
+c010521d:	c6 00 00             	movb   $0x0,(%eax)
+    assert(strlen((const char *)0x100) == 0);
+c0105220:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+c0105227:	e8 6b 09 00 00       	call   c0105b97 <strlen>
+c010522c:	85 c0                	test   %eax,%eax
+c010522e:	74 24                	je     c0105254 <check_boot_pgdir+0x33e>
+c0105230:	c7 44 24 0c 80 70 10 	movl   $0xc0107080,0xc(%esp)
+c0105237:	c0 
+c0105238:	c7 44 24 08 29 6c 10 	movl   $0xc0106c29,0x8(%esp)
+c010523f:	c0 
+c0105240:	c7 44 24 04 34 02 00 	movl   $0x234,0x4(%esp)
+c0105247:	00 
+c0105248:	c7 04 24 04 6c 10 c0 	movl   $0xc0106c04,(%esp)
+c010524f:	e8 6c ba ff ff       	call   c0100cc0 <__panic>
+
+    free_page(p);
+c0105254:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010525b:	00 
+c010525c:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010525f:	89 04 24             	mov    %eax,(%esp)
+c0105262:	e8 a3 eb ff ff       	call   c0103e0a <free_pages>
+    free_page(pa2page(PDE_ADDR(boot_pgdir[0])));
+c0105267:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c010526c:	8b 00                	mov    (%eax),%eax
+c010526e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0105273:	89 04 24             	mov    %eax,(%esp)
+c0105276:	e8 71 e8 ff ff       	call   c0103aec <pa2page>
+c010527b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0105282:	00 
+c0105283:	89 04 24             	mov    %eax,(%esp)
+c0105286:	e8 7f eb ff ff       	call   c0103e0a <free_pages>
+    boot_pgdir[0] = 0;
+c010528b:	a1 c4 88 11 c0       	mov    0xc01188c4,%eax
+c0105290:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    cprintf("check_boot_pgdir() succeeded!\n");
+c0105296:	c7 04 24 a4 70 10 c0 	movl   $0xc01070a4,(%esp)
+c010529d:	e8 9a b0 ff ff       	call   c010033c <cprintf>
+}
+c01052a2:	c9                   	leave  
+c01052a3:	c3                   	ret    
+
+c01052a4 <perm2str>:
+
+//perm2str - use string 'u,r,w,-' to present the permission
+static const char *
+perm2str(int perm) {
+c01052a4:	55                   	push   %ebp
+c01052a5:	89 e5                	mov    %esp,%ebp
+    static char str[4];
+    str[0] = (perm & PTE_U) ? 'u' : '-';
+c01052a7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01052aa:	83 e0 04             	and    $0x4,%eax
+c01052ad:	85 c0                	test   %eax,%eax
+c01052af:	74 07                	je     c01052b8 <perm2str+0x14>
+c01052b1:	b8 75 00 00 00       	mov    $0x75,%eax
+c01052b6:	eb 05                	jmp    c01052bd <perm2str+0x19>
+c01052b8:	b8 2d 00 00 00       	mov    $0x2d,%eax
+c01052bd:	a2 48 89 11 c0       	mov    %al,0xc0118948
+    str[1] = 'r';
+c01052c2:	c6 05 49 89 11 c0 72 	movb   $0x72,0xc0118949
+    str[2] = (perm & PTE_W) ? 'w' : '-';
+c01052c9:	8b 45 08             	mov    0x8(%ebp),%eax
+c01052cc:	83 e0 02             	and    $0x2,%eax
+c01052cf:	85 c0                	test   %eax,%eax
+c01052d1:	74 07                	je     c01052da <perm2str+0x36>
+c01052d3:	b8 77 00 00 00       	mov    $0x77,%eax
+c01052d8:	eb 05                	jmp    c01052df <perm2str+0x3b>
+c01052da:	b8 2d 00 00 00       	mov    $0x2d,%eax
+c01052df:	a2 4a 89 11 c0       	mov    %al,0xc011894a
+    str[3] = '\0';
+c01052e4:	c6 05 4b 89 11 c0 00 	movb   $0x0,0xc011894b
+    return str;
+c01052eb:	b8 48 89 11 c0       	mov    $0xc0118948,%eax
+}
+c01052f0:	5d                   	pop    %ebp
+c01052f1:	c3                   	ret    
+
+c01052f2 <get_pgtable_items>:
+//  table:       the beginning addr of table
+//  left_store:  the pointer of the high side of table's next range
+//  right_store: the pointer of the low side of table's next range
+// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+c01052f2:	55                   	push   %ebp
+c01052f3:	89 e5                	mov    %esp,%ebp
+c01052f5:	83 ec 10             	sub    $0x10,%esp
+    if (start >= right) {
+c01052f8:	8b 45 10             	mov    0x10(%ebp),%eax
+c01052fb:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c01052fe:	72 0a                	jb     c010530a <get_pgtable_items+0x18>
+        return 0;
+c0105300:	b8 00 00 00 00       	mov    $0x0,%eax
+c0105305:	e9 9c 00 00 00       	jmp    c01053a6 <get_pgtable_items+0xb4>
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+c010530a:	eb 04                	jmp    c0105310 <get_pgtable_items+0x1e>
+        start ++;
+c010530c:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+    if (start >= right) {
+        return 0;
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+c0105310:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105313:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0105316:	73 18                	jae    c0105330 <get_pgtable_items+0x3e>
+c0105318:	8b 45 10             	mov    0x10(%ebp),%eax
+c010531b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0105322:	8b 45 14             	mov    0x14(%ebp),%eax
+c0105325:	01 d0                	add    %edx,%eax
+c0105327:	8b 00                	mov    (%eax),%eax
+c0105329:	83 e0 01             	and    $0x1,%eax
+c010532c:	85 c0                	test   %eax,%eax
+c010532e:	74 dc                	je     c010530c <get_pgtable_items+0x1a>
+        start ++;
+    }
+    if (start < right) {
+c0105330:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105333:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0105336:	73 69                	jae    c01053a1 <get_pgtable_items+0xaf>
+        if (left_store != NULL) {
+c0105338:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
+c010533c:	74 08                	je     c0105346 <get_pgtable_items+0x54>
+            *left_store = start;
+c010533e:	8b 45 18             	mov    0x18(%ebp),%eax
+c0105341:	8b 55 10             	mov    0x10(%ebp),%edx
+c0105344:	89 10                	mov    %edx,(%eax)
+        }
+        int perm = (table[start ++] & PTE_USER);
+c0105346:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105349:	8d 50 01             	lea    0x1(%eax),%edx
+c010534c:	89 55 10             	mov    %edx,0x10(%ebp)
+c010534f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0105356:	8b 45 14             	mov    0x14(%ebp),%eax
+c0105359:	01 d0                	add    %edx,%eax
+c010535b:	8b 00                	mov    (%eax),%eax
+c010535d:	83 e0 07             	and    $0x7,%eax
+c0105360:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        while (start < right && (table[start] & PTE_USER) == perm) {
+c0105363:	eb 04                	jmp    c0105369 <get_pgtable_items+0x77>
+            start ++;
+c0105365:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+    if (start < right) {
+        if (left_store != NULL) {
+            *left_store = start;
+        }
+        int perm = (table[start ++] & PTE_USER);
+        while (start < right && (table[start] & PTE_USER) == perm) {
+c0105369:	8b 45 10             	mov    0x10(%ebp),%eax
+c010536c:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c010536f:	73 1d                	jae    c010538e <get_pgtable_items+0x9c>
+c0105371:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105374:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c010537b:	8b 45 14             	mov    0x14(%ebp),%eax
+c010537e:	01 d0                	add    %edx,%eax
+c0105380:	8b 00                	mov    (%eax),%eax
+c0105382:	83 e0 07             	and    $0x7,%eax
+c0105385:	89 c2                	mov    %eax,%edx
+c0105387:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010538a:	39 c2                	cmp    %eax,%edx
+c010538c:	74 d7                	je     c0105365 <get_pgtable_items+0x73>
+            start ++;
+        }
+        if (right_store != NULL) {
+c010538e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+c0105392:	74 08                	je     c010539c <get_pgtable_items+0xaa>
+            *right_store = start;
+c0105394:	8b 45 1c             	mov    0x1c(%ebp),%eax
+c0105397:	8b 55 10             	mov    0x10(%ebp),%edx
+c010539a:	89 10                	mov    %edx,(%eax)
+        }
+        return perm;
+c010539c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010539f:	eb 05                	jmp    c01053a6 <get_pgtable_items+0xb4>
+    }
+    return 0;
+c01053a1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c01053a6:	c9                   	leave  
+c01053a7:	c3                   	ret    
+
+c01053a8 <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+c01053a8:	55                   	push   %ebp
+c01053a9:	89 e5                	mov    %esp,%ebp
+c01053ab:	57                   	push   %edi
+c01053ac:	56                   	push   %esi
+c01053ad:	53                   	push   %ebx
+c01053ae:	83 ec 4c             	sub    $0x4c,%esp
+    cprintf("-------------------- BEGIN --------------------\n");
+c01053b1:	c7 04 24 c4 70 10 c0 	movl   $0xc01070c4,(%esp)
+c01053b8:	e8 7f af ff ff       	call   c010033c <cprintf>
+    size_t left, right = 0, perm;
+c01053bd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+c01053c4:	e9 fa 00 00 00       	jmp    c01054c3 <print_pgdir+0x11b>
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+c01053c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01053cc:	89 04 24             	mov    %eax,(%esp)
+c01053cf:	e8 d0 fe ff ff       	call   c01052a4 <perm2str>
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+c01053d4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+c01053d7:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01053da:	29 d1                	sub    %edx,%ecx
+c01053dc:	89 ca                	mov    %ecx,%edx
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+c01053de:	89 d6                	mov    %edx,%esi
+c01053e0:	c1 e6 16             	shl    $0x16,%esi
+c01053e3:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01053e6:	89 d3                	mov    %edx,%ebx
+c01053e8:	c1 e3 16             	shl    $0x16,%ebx
+c01053eb:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01053ee:	89 d1                	mov    %edx,%ecx
+c01053f0:	c1 e1 16             	shl    $0x16,%ecx
+c01053f3:	8b 7d dc             	mov    -0x24(%ebp),%edi
+c01053f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01053f9:	29 d7                	sub    %edx,%edi
+c01053fb:	89 fa                	mov    %edi,%edx
+c01053fd:	89 44 24 14          	mov    %eax,0x14(%esp)
+c0105401:	89 74 24 10          	mov    %esi,0x10(%esp)
+c0105405:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+c0105409:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c010540d:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105411:	c7 04 24 f5 70 10 c0 	movl   $0xc01070f5,(%esp)
+c0105418:	e8 1f af ff ff       	call   c010033c <cprintf>
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+c010541d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105420:	c1 e0 0a             	shl    $0xa,%eax
+c0105423:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+c0105426:	eb 54                	jmp    c010547c <print_pgdir+0xd4>
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+c0105428:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010542b:	89 04 24             	mov    %eax,(%esp)
+c010542e:	e8 71 fe ff ff       	call   c01052a4 <perm2str>
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+c0105433:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
+c0105436:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0105439:	29 d1                	sub    %edx,%ecx
+c010543b:	89 ca                	mov    %ecx,%edx
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+c010543d:	89 d6                	mov    %edx,%esi
+c010543f:	c1 e6 0c             	shl    $0xc,%esi
+c0105442:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0105445:	89 d3                	mov    %edx,%ebx
+c0105447:	c1 e3 0c             	shl    $0xc,%ebx
+c010544a:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c010544d:	c1 e2 0c             	shl    $0xc,%edx
+c0105450:	89 d1                	mov    %edx,%ecx
+c0105452:	8b 7d d4             	mov    -0x2c(%ebp),%edi
+c0105455:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0105458:	29 d7                	sub    %edx,%edi
+c010545a:	89 fa                	mov    %edi,%edx
+c010545c:	89 44 24 14          	mov    %eax,0x14(%esp)
+c0105460:	89 74 24 10          	mov    %esi,0x10(%esp)
+c0105464:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+c0105468:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c010546c:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105470:	c7 04 24 14 71 10 c0 	movl   $0xc0107114,(%esp)
+c0105477:	e8 c0 ae ff ff       	call   c010033c <cprintf>
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+c010547c:	ba 00 00 c0 fa       	mov    $0xfac00000,%edx
+c0105481:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0105484:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+c0105487:	89 ce                	mov    %ecx,%esi
+c0105489:	c1 e6 0a             	shl    $0xa,%esi
+c010548c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+c010548f:	89 cb                	mov    %ecx,%ebx
+c0105491:	c1 e3 0a             	shl    $0xa,%ebx
+c0105494:	8d 4d d4             	lea    -0x2c(%ebp),%ecx
+c0105497:	89 4c 24 14          	mov    %ecx,0x14(%esp)
+c010549b:	8d 4d d8             	lea    -0x28(%ebp),%ecx
+c010549e:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+c01054a2:	89 54 24 0c          	mov    %edx,0xc(%esp)
+c01054a6:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01054aa:	89 74 24 04          	mov    %esi,0x4(%esp)
+c01054ae:	89 1c 24             	mov    %ebx,(%esp)
+c01054b1:	e8 3c fe ff ff       	call   c01052f2 <get_pgtable_items>
+c01054b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01054b9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01054bd:	0f 85 65 ff ff ff    	jne    c0105428 <print_pgdir+0x80>
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+c01054c3:	ba 00 b0 fe fa       	mov    $0xfafeb000,%edx
+c01054c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01054cb:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+c01054ce:	89 4c 24 14          	mov    %ecx,0x14(%esp)
+c01054d2:	8d 4d e0             	lea    -0x20(%ebp),%ecx
+c01054d5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+c01054d9:	89 54 24 0c          	mov    %edx,0xc(%esp)
+c01054dd:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01054e1:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
+c01054e8:	00 
+c01054e9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c01054f0:	e8 fd fd ff ff       	call   c01052f2 <get_pgtable_items>
+c01054f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01054f8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01054fc:	0f 85 c7 fe ff ff    	jne    c01053c9 <print_pgdir+0x21>
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+        }
+    }
+    cprintf("--------------------- END ---------------------\n");
+c0105502:	c7 04 24 38 71 10 c0 	movl   $0xc0107138,(%esp)
+c0105509:	e8 2e ae ff ff       	call   c010033c <cprintf>
+}
+c010550e:	83 c4 4c             	add    $0x4c,%esp
+c0105511:	5b                   	pop    %ebx
+c0105512:	5e                   	pop    %esi
+c0105513:	5f                   	pop    %edi
+c0105514:	5d                   	pop    %ebp
+c0105515:	c3                   	ret    
+
+c0105516 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+c0105516:	55                   	push   %ebp
+c0105517:	89 e5                	mov    %esp,%ebp
+c0105519:	83 ec 58             	sub    $0x58,%esp
+c010551c:	8b 45 10             	mov    0x10(%ebp),%eax
+c010551f:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0105522:	8b 45 14             	mov    0x14(%ebp),%eax
+c0105525:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+c0105528:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010552b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c010552e:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0105531:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+c0105534:	8b 45 18             	mov    0x18(%ebp),%eax
+c0105537:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010553a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010553d:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0105540:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0105543:	89 55 f0             	mov    %edx,-0x10(%ebp)
+c0105546:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105549:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010554c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0105550:	74 1c                	je     c010556e <printnum+0x58>
+c0105552:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105555:	ba 00 00 00 00       	mov    $0x0,%edx
+c010555a:	f7 75 e4             	divl   -0x1c(%ebp)
+c010555d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0105560:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105563:	ba 00 00 00 00       	mov    $0x0,%edx
+c0105568:	f7 75 e4             	divl   -0x1c(%ebp)
+c010556b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010556e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105571:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105574:	f7 75 e4             	divl   -0x1c(%ebp)
+c0105577:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010557a:	89 55 dc             	mov    %edx,-0x24(%ebp)
+c010557d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105580:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0105583:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0105586:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c0105589:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010558c:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+c010558f:	8b 45 18             	mov    0x18(%ebp),%eax
+c0105592:	ba 00 00 00 00       	mov    $0x0,%edx
+c0105597:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c010559a:	77 56                	ja     c01055f2 <printnum+0xdc>
+c010559c:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c010559f:	72 05                	jb     c01055a6 <printnum+0x90>
+c01055a1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+c01055a4:	77 4c                	ja     c01055f2 <printnum+0xdc>
+        printnum(putch, putdat, result, base, width - 1, padc);
+c01055a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
+c01055a9:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01055ac:	8b 45 20             	mov    0x20(%ebp),%eax
+c01055af:	89 44 24 18          	mov    %eax,0x18(%esp)
+c01055b3:	89 54 24 14          	mov    %edx,0x14(%esp)
+c01055b7:	8b 45 18             	mov    0x18(%ebp),%eax
+c01055ba:	89 44 24 10          	mov    %eax,0x10(%esp)
+c01055be:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01055c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c01055c4:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01055c8:	89 54 24 0c          	mov    %edx,0xc(%esp)
+c01055cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01055cf:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01055d3:	8b 45 08             	mov    0x8(%ebp),%eax
+c01055d6:	89 04 24             	mov    %eax,(%esp)
+c01055d9:	e8 38 ff ff ff       	call   c0105516 <printnum>
+c01055de:	eb 1c                	jmp    c01055fc <printnum+0xe6>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+c01055e0:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01055e3:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01055e7:	8b 45 20             	mov    0x20(%ebp),%eax
+c01055ea:	89 04 24             	mov    %eax,(%esp)
+c01055ed:	8b 45 08             	mov    0x8(%ebp),%eax
+c01055f0:	ff d0                	call   *%eax
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+c01055f2:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+c01055f6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+c01055fa:	7f e4                	jg     c01055e0 <printnum+0xca>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+c01055fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01055ff:	05 ec 71 10 c0       	add    $0xc01071ec,%eax
+c0105604:	0f b6 00             	movzbl (%eax),%eax
+c0105607:	0f be c0             	movsbl %al,%eax
+c010560a:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010560d:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105611:	89 04 24             	mov    %eax,(%esp)
+c0105614:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105617:	ff d0                	call   *%eax
+}
+c0105619:	c9                   	leave  
+c010561a:	c3                   	ret    
+
+c010561b <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+c010561b:	55                   	push   %ebp
+c010561c:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+c010561e:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+c0105622:	7e 14                	jle    c0105638 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+c0105624:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105627:	8b 00                	mov    (%eax),%eax
+c0105629:	8d 48 08             	lea    0x8(%eax),%ecx
+c010562c:	8b 55 08             	mov    0x8(%ebp),%edx
+c010562f:	89 0a                	mov    %ecx,(%edx)
+c0105631:	8b 50 04             	mov    0x4(%eax),%edx
+c0105634:	8b 00                	mov    (%eax),%eax
+c0105636:	eb 30                	jmp    c0105668 <getuint+0x4d>
+    }
+    else if (lflag) {
+c0105638:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c010563c:	74 16                	je     c0105654 <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+c010563e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105641:	8b 00                	mov    (%eax),%eax
+c0105643:	8d 48 04             	lea    0x4(%eax),%ecx
+c0105646:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105649:	89 0a                	mov    %ecx,(%edx)
+c010564b:	8b 00                	mov    (%eax),%eax
+c010564d:	ba 00 00 00 00       	mov    $0x0,%edx
+c0105652:	eb 14                	jmp    c0105668 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+c0105654:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105657:	8b 00                	mov    (%eax),%eax
+c0105659:	8d 48 04             	lea    0x4(%eax),%ecx
+c010565c:	8b 55 08             	mov    0x8(%ebp),%edx
+c010565f:	89 0a                	mov    %ecx,(%edx)
+c0105661:	8b 00                	mov    (%eax),%eax
+c0105663:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+c0105668:	5d                   	pop    %ebp
+c0105669:	c3                   	ret    
+
+c010566a <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+c010566a:	55                   	push   %ebp
+c010566b:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+c010566d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+c0105671:	7e 14                	jle    c0105687 <getint+0x1d>
+        return va_arg(*ap, long long);
+c0105673:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105676:	8b 00                	mov    (%eax),%eax
+c0105678:	8d 48 08             	lea    0x8(%eax),%ecx
+c010567b:	8b 55 08             	mov    0x8(%ebp),%edx
+c010567e:	89 0a                	mov    %ecx,(%edx)
+c0105680:	8b 50 04             	mov    0x4(%eax),%edx
+c0105683:	8b 00                	mov    (%eax),%eax
+c0105685:	eb 28                	jmp    c01056af <getint+0x45>
+    }
+    else if (lflag) {
+c0105687:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c010568b:	74 12                	je     c010569f <getint+0x35>
+        return va_arg(*ap, long);
+c010568d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105690:	8b 00                	mov    (%eax),%eax
+c0105692:	8d 48 04             	lea    0x4(%eax),%ecx
+c0105695:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105698:	89 0a                	mov    %ecx,(%edx)
+c010569a:	8b 00                	mov    (%eax),%eax
+c010569c:	99                   	cltd   
+c010569d:	eb 10                	jmp    c01056af <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+c010569f:	8b 45 08             	mov    0x8(%ebp),%eax
+c01056a2:	8b 00                	mov    (%eax),%eax
+c01056a4:	8d 48 04             	lea    0x4(%eax),%ecx
+c01056a7:	8b 55 08             	mov    0x8(%ebp),%edx
+c01056aa:	89 0a                	mov    %ecx,(%edx)
+c01056ac:	8b 00                	mov    (%eax),%eax
+c01056ae:	99                   	cltd   
+    }
+}
+c01056af:	5d                   	pop    %ebp
+c01056b0:	c3                   	ret    
+
+c01056b1 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+c01056b1:	55                   	push   %ebp
+c01056b2:	89 e5                	mov    %esp,%ebp
+c01056b4:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+c01056b7:	8d 45 14             	lea    0x14(%ebp),%eax
+c01056ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+c01056bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01056c0:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c01056c4:	8b 45 10             	mov    0x10(%ebp),%eax
+c01056c7:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01056cb:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01056ce:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01056d2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01056d5:	89 04 24             	mov    %eax,(%esp)
+c01056d8:	e8 02 00 00 00       	call   c01056df <vprintfmt>
+    va_end(ap);
+}
+c01056dd:	c9                   	leave  
+c01056de:	c3                   	ret    
+
+c01056df <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+c01056df:	55                   	push   %ebp
+c01056e0:	89 e5                	mov    %esp,%ebp
+c01056e2:	56                   	push   %esi
+c01056e3:	53                   	push   %ebx
+c01056e4:	83 ec 40             	sub    $0x40,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+c01056e7:	eb 18                	jmp    c0105701 <vprintfmt+0x22>
+            if (ch == '\0') {
+c01056e9:	85 db                	test   %ebx,%ebx
+c01056eb:	75 05                	jne    c01056f2 <vprintfmt+0x13>
+                return;
+c01056ed:	e9 d1 03 00 00       	jmp    c0105ac3 <vprintfmt+0x3e4>
+            }
+            putch(ch, putdat);
+c01056f2:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01056f5:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01056f9:	89 1c 24             	mov    %ebx,(%esp)
+c01056fc:	8b 45 08             	mov    0x8(%ebp),%eax
+c01056ff:	ff d0                	call   *%eax
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+c0105701:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105704:	8d 50 01             	lea    0x1(%eax),%edx
+c0105707:	89 55 10             	mov    %edx,0x10(%ebp)
+c010570a:	0f b6 00             	movzbl (%eax),%eax
+c010570d:	0f b6 d8             	movzbl %al,%ebx
+c0105710:	83 fb 25             	cmp    $0x25,%ebx
+c0105713:	75 d4                	jne    c01056e9 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+c0105715:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+c0105719:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+c0105720:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105723:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+c0105726:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c010572d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0105730:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+c0105733:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105736:	8d 50 01             	lea    0x1(%eax),%edx
+c0105739:	89 55 10             	mov    %edx,0x10(%ebp)
+c010573c:	0f b6 00             	movzbl (%eax),%eax
+c010573f:	0f b6 d8             	movzbl %al,%ebx
+c0105742:	8d 43 dd             	lea    -0x23(%ebx),%eax
+c0105745:	83 f8 55             	cmp    $0x55,%eax
+c0105748:	0f 87 44 03 00 00    	ja     c0105a92 <vprintfmt+0x3b3>
+c010574e:	8b 04 85 10 72 10 c0 	mov    -0x3fef8df0(,%eax,4),%eax
+c0105755:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+c0105757:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+c010575b:	eb d6                	jmp    c0105733 <vprintfmt+0x54>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+c010575d:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+c0105761:	eb d0                	jmp    c0105733 <vprintfmt+0x54>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+c0105763:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+c010576a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010576d:	89 d0                	mov    %edx,%eax
+c010576f:	c1 e0 02             	shl    $0x2,%eax
+c0105772:	01 d0                	add    %edx,%eax
+c0105774:	01 c0                	add    %eax,%eax
+c0105776:	01 d8                	add    %ebx,%eax
+c0105778:	83 e8 30             	sub    $0x30,%eax
+c010577b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+c010577e:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105781:	0f b6 00             	movzbl (%eax),%eax
+c0105784:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+c0105787:	83 fb 2f             	cmp    $0x2f,%ebx
+c010578a:	7e 0b                	jle    c0105797 <vprintfmt+0xb8>
+c010578c:	83 fb 39             	cmp    $0x39,%ebx
+c010578f:	7f 06                	jg     c0105797 <vprintfmt+0xb8>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+c0105791:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+c0105795:	eb d3                	jmp    c010576a <vprintfmt+0x8b>
+            goto process_precision;
+c0105797:	eb 33                	jmp    c01057cc <vprintfmt+0xed>
+
+        case '*':
+            precision = va_arg(ap, int);
+c0105799:	8b 45 14             	mov    0x14(%ebp),%eax
+c010579c:	8d 50 04             	lea    0x4(%eax),%edx
+c010579f:	89 55 14             	mov    %edx,0x14(%ebp)
+c01057a2:	8b 00                	mov    (%eax),%eax
+c01057a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+c01057a7:	eb 23                	jmp    c01057cc <vprintfmt+0xed>
+
+        case '.':
+            if (width < 0)
+c01057a9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c01057ad:	79 0c                	jns    c01057bb <vprintfmt+0xdc>
+                width = 0;
+c01057af:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+c01057b6:	e9 78 ff ff ff       	jmp    c0105733 <vprintfmt+0x54>
+c01057bb:	e9 73 ff ff ff       	jmp    c0105733 <vprintfmt+0x54>
+
+        case '#':
+            altflag = 1;
+c01057c0:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+c01057c7:	e9 67 ff ff ff       	jmp    c0105733 <vprintfmt+0x54>
+
+        process_precision:
+            if (width < 0)
+c01057cc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c01057d0:	79 12                	jns    c01057e4 <vprintfmt+0x105>
+                width = precision, precision = -1;
+c01057d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01057d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01057d8:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+c01057df:	e9 4f ff ff ff       	jmp    c0105733 <vprintfmt+0x54>
+c01057e4:	e9 4a ff ff ff       	jmp    c0105733 <vprintfmt+0x54>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+c01057e9:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+c01057ed:	e9 41 ff ff ff       	jmp    c0105733 <vprintfmt+0x54>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+c01057f2:	8b 45 14             	mov    0x14(%ebp),%eax
+c01057f5:	8d 50 04             	lea    0x4(%eax),%edx
+c01057f8:	89 55 14             	mov    %edx,0x14(%ebp)
+c01057fb:	8b 00                	mov    (%eax),%eax
+c01057fd:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0105800:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105804:	89 04 24             	mov    %eax,(%esp)
+c0105807:	8b 45 08             	mov    0x8(%ebp),%eax
+c010580a:	ff d0                	call   *%eax
+            break;
+c010580c:	e9 ac 02 00 00       	jmp    c0105abd <vprintfmt+0x3de>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+c0105811:	8b 45 14             	mov    0x14(%ebp),%eax
+c0105814:	8d 50 04             	lea    0x4(%eax),%edx
+c0105817:	89 55 14             	mov    %edx,0x14(%ebp)
+c010581a:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+c010581c:	85 db                	test   %ebx,%ebx
+c010581e:	79 02                	jns    c0105822 <vprintfmt+0x143>
+                err = -err;
+c0105820:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+c0105822:	83 fb 06             	cmp    $0x6,%ebx
+c0105825:	7f 0b                	jg     c0105832 <vprintfmt+0x153>
+c0105827:	8b 34 9d d0 71 10 c0 	mov    -0x3fef8e30(,%ebx,4),%esi
+c010582e:	85 f6                	test   %esi,%esi
+c0105830:	75 23                	jne    c0105855 <vprintfmt+0x176>
+                printfmt(putch, putdat, "error %d", err);
+c0105832:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+c0105836:	c7 44 24 08 fd 71 10 	movl   $0xc01071fd,0x8(%esp)
+c010583d:	c0 
+c010583e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105841:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105845:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105848:	89 04 24             	mov    %eax,(%esp)
+c010584b:	e8 61 fe ff ff       	call   c01056b1 <printfmt>
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+c0105850:	e9 68 02 00 00       	jmp    c0105abd <vprintfmt+0x3de>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+c0105855:	89 74 24 0c          	mov    %esi,0xc(%esp)
+c0105859:	c7 44 24 08 06 72 10 	movl   $0xc0107206,0x8(%esp)
+c0105860:	c0 
+c0105861:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105864:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105868:	8b 45 08             	mov    0x8(%ebp),%eax
+c010586b:	89 04 24             	mov    %eax,(%esp)
+c010586e:	e8 3e fe ff ff       	call   c01056b1 <printfmt>
+            }
+            break;
+c0105873:	e9 45 02 00 00       	jmp    c0105abd <vprintfmt+0x3de>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+c0105878:	8b 45 14             	mov    0x14(%ebp),%eax
+c010587b:	8d 50 04             	lea    0x4(%eax),%edx
+c010587e:	89 55 14             	mov    %edx,0x14(%ebp)
+c0105881:	8b 30                	mov    (%eax),%esi
+c0105883:	85 f6                	test   %esi,%esi
+c0105885:	75 05                	jne    c010588c <vprintfmt+0x1ad>
+                p = "(null)";
+c0105887:	be 09 72 10 c0       	mov    $0xc0107209,%esi
+            }
+            if (width > 0 && padc != '-') {
+c010588c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0105890:	7e 3e                	jle    c01058d0 <vprintfmt+0x1f1>
+c0105892:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+c0105896:	74 38                	je     c01058d0 <vprintfmt+0x1f1>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+c0105898:	8b 5d e8             	mov    -0x18(%ebp),%ebx
+c010589b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010589e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01058a2:	89 34 24             	mov    %esi,(%esp)
+c01058a5:	e8 15 03 00 00       	call   c0105bbf <strnlen>
+c01058aa:	29 c3                	sub    %eax,%ebx
+c01058ac:	89 d8                	mov    %ebx,%eax
+c01058ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01058b1:	eb 17                	jmp    c01058ca <vprintfmt+0x1eb>
+                    putch(padc, putdat);
+c01058b3:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+c01058b7:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01058ba:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01058be:	89 04 24             	mov    %eax,(%esp)
+c01058c1:	8b 45 08             	mov    0x8(%ebp),%eax
+c01058c4:	ff d0                	call   *%eax
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+c01058c6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+c01058ca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c01058ce:	7f e3                	jg     c01058b3 <vprintfmt+0x1d4>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+c01058d0:	eb 38                	jmp    c010590a <vprintfmt+0x22b>
+                if (altflag && (ch < ' ' || ch > '~')) {
+c01058d2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c01058d6:	74 1f                	je     c01058f7 <vprintfmt+0x218>
+c01058d8:	83 fb 1f             	cmp    $0x1f,%ebx
+c01058db:	7e 05                	jle    c01058e2 <vprintfmt+0x203>
+c01058dd:	83 fb 7e             	cmp    $0x7e,%ebx
+c01058e0:	7e 15                	jle    c01058f7 <vprintfmt+0x218>
+                    putch('?', putdat);
+c01058e2:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01058e5:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01058e9:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+c01058f0:	8b 45 08             	mov    0x8(%ebp),%eax
+c01058f3:	ff d0                	call   *%eax
+c01058f5:	eb 0f                	jmp    c0105906 <vprintfmt+0x227>
+                }
+                else {
+                    putch(ch, putdat);
+c01058f7:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01058fa:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01058fe:	89 1c 24             	mov    %ebx,(%esp)
+c0105901:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105904:	ff d0                	call   *%eax
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+c0105906:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+c010590a:	89 f0                	mov    %esi,%eax
+c010590c:	8d 70 01             	lea    0x1(%eax),%esi
+c010590f:	0f b6 00             	movzbl (%eax),%eax
+c0105912:	0f be d8             	movsbl %al,%ebx
+c0105915:	85 db                	test   %ebx,%ebx
+c0105917:	74 10                	je     c0105929 <vprintfmt+0x24a>
+c0105919:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c010591d:	78 b3                	js     c01058d2 <vprintfmt+0x1f3>
+c010591f:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+c0105923:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0105927:	79 a9                	jns    c01058d2 <vprintfmt+0x1f3>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+c0105929:	eb 17                	jmp    c0105942 <vprintfmt+0x263>
+                putch(' ', putdat);
+c010592b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010592e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105932:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+c0105939:	8b 45 08             	mov    0x8(%ebp),%eax
+c010593c:	ff d0                	call   *%eax
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+c010593e:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+c0105942:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0105946:	7f e3                	jg     c010592b <vprintfmt+0x24c>
+                putch(' ', putdat);
+            }
+            break;
+c0105948:	e9 70 01 00 00       	jmp    c0105abd <vprintfmt+0x3de>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+c010594d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105950:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105954:	8d 45 14             	lea    0x14(%ebp),%eax
+c0105957:	89 04 24             	mov    %eax,(%esp)
+c010595a:	e8 0b fd ff ff       	call   c010566a <getint>
+c010595f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105962:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+c0105965:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105968:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010596b:	85 d2                	test   %edx,%edx
+c010596d:	79 26                	jns    c0105995 <vprintfmt+0x2b6>
+                putch('-', putdat);
+c010596f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105972:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105976:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+c010597d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105980:	ff d0                	call   *%eax
+                num = -(long long)num;
+c0105982:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105985:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105988:	f7 d8                	neg    %eax
+c010598a:	83 d2 00             	adc    $0x0,%edx
+c010598d:	f7 da                	neg    %edx
+c010598f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105992:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+c0105995:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+c010599c:	e9 a8 00 00 00       	jmp    c0105a49 <vprintfmt+0x36a>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+c01059a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01059a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01059a8:	8d 45 14             	lea    0x14(%ebp),%eax
+c01059ab:	89 04 24             	mov    %eax,(%esp)
+c01059ae:	e8 68 fc ff ff       	call   c010561b <getuint>
+c01059b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01059b6:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+c01059b9:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+c01059c0:	e9 84 00 00 00       	jmp    c0105a49 <vprintfmt+0x36a>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+c01059c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01059c8:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01059cc:	8d 45 14             	lea    0x14(%ebp),%eax
+c01059cf:	89 04 24             	mov    %eax,(%esp)
+c01059d2:	e8 44 fc ff ff       	call   c010561b <getuint>
+c01059d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01059da:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+c01059dd:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+c01059e4:	eb 63                	jmp    c0105a49 <vprintfmt+0x36a>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+c01059e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01059e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01059ed:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+c01059f4:	8b 45 08             	mov    0x8(%ebp),%eax
+c01059f7:	ff d0                	call   *%eax
+            putch('x', putdat);
+c01059f9:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01059fc:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105a00:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+c0105a07:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105a0a:	ff d0                	call   *%eax
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+c0105a0c:	8b 45 14             	mov    0x14(%ebp),%eax
+c0105a0f:	8d 50 04             	lea    0x4(%eax),%edx
+c0105a12:	89 55 14             	mov    %edx,0x14(%ebp)
+c0105a15:	8b 00                	mov    (%eax),%eax
+c0105a17:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105a1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+c0105a21:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+c0105a28:	eb 1f                	jmp    c0105a49 <vprintfmt+0x36a>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+c0105a2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105a2d:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105a31:	8d 45 14             	lea    0x14(%ebp),%eax
+c0105a34:	89 04 24             	mov    %eax,(%esp)
+c0105a37:	e8 df fb ff ff       	call   c010561b <getuint>
+c0105a3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105a3f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+c0105a42:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+c0105a49:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+c0105a4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105a50:	89 54 24 18          	mov    %edx,0x18(%esp)
+c0105a54:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0105a57:	89 54 24 14          	mov    %edx,0x14(%esp)
+c0105a5b:	89 44 24 10          	mov    %eax,0x10(%esp)
+c0105a5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105a62:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105a65:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0105a69:	89 54 24 0c          	mov    %edx,0xc(%esp)
+c0105a6d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105a70:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105a74:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105a77:	89 04 24             	mov    %eax,(%esp)
+c0105a7a:	e8 97 fa ff ff       	call   c0105516 <printnum>
+            break;
+c0105a7f:	eb 3c                	jmp    c0105abd <vprintfmt+0x3de>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+c0105a81:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105a84:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105a88:	89 1c 24             	mov    %ebx,(%esp)
+c0105a8b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105a8e:	ff d0                	call   *%eax
+            break;
+c0105a90:	eb 2b                	jmp    c0105abd <vprintfmt+0x3de>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+c0105a92:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105a95:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105a99:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+c0105aa0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105aa3:	ff d0                	call   *%eax
+            for (fmt --; fmt[-1] != '%'; fmt --)
+c0105aa5:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+c0105aa9:	eb 04                	jmp    c0105aaf <vprintfmt+0x3d0>
+c0105aab:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+c0105aaf:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105ab2:	83 e8 01             	sub    $0x1,%eax
+c0105ab5:	0f b6 00             	movzbl (%eax),%eax
+c0105ab8:	3c 25                	cmp    $0x25,%al
+c0105aba:	75 ef                	jne    c0105aab <vprintfmt+0x3cc>
+                /* do nothing */;
+            break;
+c0105abc:	90                   	nop
+        }
+    }
+c0105abd:	90                   	nop
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+c0105abe:	e9 3e fc ff ff       	jmp    c0105701 <vprintfmt+0x22>
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+c0105ac3:	83 c4 40             	add    $0x40,%esp
+c0105ac6:	5b                   	pop    %ebx
+c0105ac7:	5e                   	pop    %esi
+c0105ac8:	5d                   	pop    %ebp
+c0105ac9:	c3                   	ret    
+
+c0105aca <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+c0105aca:	55                   	push   %ebp
+c0105acb:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+c0105acd:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105ad0:	8b 40 08             	mov    0x8(%eax),%eax
+c0105ad3:	8d 50 01             	lea    0x1(%eax),%edx
+c0105ad6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105ad9:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+c0105adc:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105adf:	8b 10                	mov    (%eax),%edx
+c0105ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105ae4:	8b 40 04             	mov    0x4(%eax),%eax
+c0105ae7:	39 c2                	cmp    %eax,%edx
+c0105ae9:	73 12                	jae    c0105afd <sprintputch+0x33>
+        *b->buf ++ = ch;
+c0105aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105aee:	8b 00                	mov    (%eax),%eax
+c0105af0:	8d 48 01             	lea    0x1(%eax),%ecx
+c0105af3:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0105af6:	89 0a                	mov    %ecx,(%edx)
+c0105af8:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105afb:	88 10                	mov    %dl,(%eax)
+    }
+}
+c0105afd:	5d                   	pop    %ebp
+c0105afe:	c3                   	ret    
+
+c0105aff <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+c0105aff:	55                   	push   %ebp
+c0105b00:	89 e5                	mov    %esp,%ebp
+c0105b02:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+c0105b05:	8d 45 14             	lea    0x14(%ebp),%eax
+c0105b08:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+c0105b0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105b0e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0105b12:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105b15:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0105b19:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105b1c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105b20:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105b23:	89 04 24             	mov    %eax,(%esp)
+c0105b26:	e8 08 00 00 00       	call   c0105b33 <vsnprintf>
+c0105b2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+c0105b2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0105b31:	c9                   	leave  
+c0105b32:	c3                   	ret    
+
+c0105b33 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+c0105b33:	55                   	push   %ebp
+c0105b34:	89 e5                	mov    %esp,%ebp
+c0105b36:	83 ec 28             	sub    $0x28,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+c0105b39:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105b3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0105b3f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105b42:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0105b45:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105b48:	01 d0                	add    %edx,%eax
+c0105b4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105b4d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+c0105b54:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0105b58:	74 0a                	je     c0105b64 <vsnprintf+0x31>
+c0105b5a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0105b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105b60:	39 c2                	cmp    %eax,%edx
+c0105b62:	76 07                	jbe    c0105b6b <vsnprintf+0x38>
+        return -E_INVAL;
+c0105b64:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+c0105b69:	eb 2a                	jmp    c0105b95 <vsnprintf+0x62>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+c0105b6b:	8b 45 14             	mov    0x14(%ebp),%eax
+c0105b6e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0105b72:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105b75:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0105b79:	8d 45 ec             	lea    -0x14(%ebp),%eax
+c0105b7c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105b80:	c7 04 24 ca 5a 10 c0 	movl   $0xc0105aca,(%esp)
+c0105b87:	e8 53 fb ff ff       	call   c01056df <vprintfmt>
+    // null terminate the buffer
+    *b.buf = '\0';
+c0105b8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105b8f:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+c0105b92:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+c0105b95:	c9                   	leave  
+c0105b96:	c3                   	ret    
+
+c0105b97 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+c0105b97:	55                   	push   %ebp
+c0105b98:	89 e5                	mov    %esp,%ebp
+c0105b9a:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+c0105b9d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+c0105ba4:	eb 04                	jmp    c0105baa <strlen+0x13>
+        cnt ++;
+c0105ba6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+c0105baa:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105bad:	8d 50 01             	lea    0x1(%eax),%edx
+c0105bb0:	89 55 08             	mov    %edx,0x8(%ebp)
+c0105bb3:	0f b6 00             	movzbl (%eax),%eax
+c0105bb6:	84 c0                	test   %al,%al
+c0105bb8:	75 ec                	jne    c0105ba6 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+c0105bba:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c0105bbd:	c9                   	leave  
+c0105bbe:	c3                   	ret    
+
+c0105bbf <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+c0105bbf:	55                   	push   %ebp
+c0105bc0:	89 e5                	mov    %esp,%ebp
+c0105bc2:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+c0105bc5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+c0105bcc:	eb 04                	jmp    c0105bd2 <strnlen+0x13>
+        cnt ++;
+c0105bce:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+c0105bd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0105bd5:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0105bd8:	73 10                	jae    c0105bea <strnlen+0x2b>
+c0105bda:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105bdd:	8d 50 01             	lea    0x1(%eax),%edx
+c0105be0:	89 55 08             	mov    %edx,0x8(%ebp)
+c0105be3:	0f b6 00             	movzbl (%eax),%eax
+c0105be6:	84 c0                	test   %al,%al
+c0105be8:	75 e4                	jne    c0105bce <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+c0105bea:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+c0105bed:	c9                   	leave  
+c0105bee:	c3                   	ret    
+
+c0105bef <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+c0105bef:	55                   	push   %ebp
+c0105bf0:	89 e5                	mov    %esp,%ebp
+c0105bf2:	57                   	push   %edi
+c0105bf3:	56                   	push   %esi
+c0105bf4:	83 ec 20             	sub    $0x20,%esp
+c0105bf7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105bfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105bfd:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105c00:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+c0105c03:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0105c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105c09:	89 d1                	mov    %edx,%ecx
+c0105c0b:	89 c2                	mov    %eax,%edx
+c0105c0d:	89 ce                	mov    %ecx,%esi
+c0105c0f:	89 d7                	mov    %edx,%edi
+c0105c11:	ac                   	lods   %ds:(%esi),%al
+c0105c12:	aa                   	stos   %al,%es:(%edi)
+c0105c13:	84 c0                	test   %al,%al
+c0105c15:	75 fa                	jne    c0105c11 <strcpy+0x22>
+c0105c17:	89 fa                	mov    %edi,%edx
+c0105c19:	89 f1                	mov    %esi,%ecx
+c0105c1b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+c0105c1e:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c0105c21:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+c0105c24:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+c0105c27:	83 c4 20             	add    $0x20,%esp
+c0105c2a:	5e                   	pop    %esi
+c0105c2b:	5f                   	pop    %edi
+c0105c2c:	5d                   	pop    %ebp
+c0105c2d:	c3                   	ret    
+
+c0105c2e <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+c0105c2e:	55                   	push   %ebp
+c0105c2f:	89 e5                	mov    %esp,%ebp
+c0105c31:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+c0105c34:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105c37:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+c0105c3a:	eb 21                	jmp    c0105c5d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+c0105c3c:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105c3f:	0f b6 10             	movzbl (%eax),%edx
+c0105c42:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0105c45:	88 10                	mov    %dl,(%eax)
+c0105c47:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0105c4a:	0f b6 00             	movzbl (%eax),%eax
+c0105c4d:	84 c0                	test   %al,%al
+c0105c4f:	74 04                	je     c0105c55 <strncpy+0x27>
+            src ++;
+c0105c51:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+c0105c55:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c0105c59:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+c0105c5d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0105c61:	75 d9                	jne    c0105c3c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+c0105c63:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+c0105c66:	c9                   	leave  
+c0105c67:	c3                   	ret    
+
+c0105c68 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+c0105c68:	55                   	push   %ebp
+c0105c69:	89 e5                	mov    %esp,%ebp
+c0105c6b:	57                   	push   %edi
+c0105c6c:	56                   	push   %esi
+c0105c6d:	83 ec 20             	sub    $0x20,%esp
+c0105c70:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105c73:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105c76:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105c79:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+c0105c7c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105c7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105c82:	89 d1                	mov    %edx,%ecx
+c0105c84:	89 c2                	mov    %eax,%edx
+c0105c86:	89 ce                	mov    %ecx,%esi
+c0105c88:	89 d7                	mov    %edx,%edi
+c0105c8a:	ac                   	lods   %ds:(%esi),%al
+c0105c8b:	ae                   	scas   %es:(%edi),%al
+c0105c8c:	75 08                	jne    c0105c96 <strcmp+0x2e>
+c0105c8e:	84 c0                	test   %al,%al
+c0105c90:	75 f8                	jne    c0105c8a <strcmp+0x22>
+c0105c92:	31 c0                	xor    %eax,%eax
+c0105c94:	eb 04                	jmp    c0105c9a <strcmp+0x32>
+c0105c96:	19 c0                	sbb    %eax,%eax
+c0105c98:	0c 01                	or     $0x1,%al
+c0105c9a:	89 fa                	mov    %edi,%edx
+c0105c9c:	89 f1                	mov    %esi,%ecx
+c0105c9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0105ca1:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+c0105ca4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+c0105ca7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+c0105caa:	83 c4 20             	add    $0x20,%esp
+c0105cad:	5e                   	pop    %esi
+c0105cae:	5f                   	pop    %edi
+c0105caf:	5d                   	pop    %ebp
+c0105cb0:	c3                   	ret    
+
+c0105cb1 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+c0105cb1:	55                   	push   %ebp
+c0105cb2:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+c0105cb4:	eb 0c                	jmp    c0105cc2 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+c0105cb6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+c0105cba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c0105cbe:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+c0105cc2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0105cc6:	74 1a                	je     c0105ce2 <strncmp+0x31>
+c0105cc8:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105ccb:	0f b6 00             	movzbl (%eax),%eax
+c0105cce:	84 c0                	test   %al,%al
+c0105cd0:	74 10                	je     c0105ce2 <strncmp+0x31>
+c0105cd2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105cd5:	0f b6 10             	movzbl (%eax),%edx
+c0105cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105cdb:	0f b6 00             	movzbl (%eax),%eax
+c0105cde:	38 c2                	cmp    %al,%dl
+c0105ce0:	74 d4                	je     c0105cb6 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+c0105ce2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0105ce6:	74 18                	je     c0105d00 <strncmp+0x4f>
+c0105ce8:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105ceb:	0f b6 00             	movzbl (%eax),%eax
+c0105cee:	0f b6 d0             	movzbl %al,%edx
+c0105cf1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105cf4:	0f b6 00             	movzbl (%eax),%eax
+c0105cf7:	0f b6 c0             	movzbl %al,%eax
+c0105cfa:	29 c2                	sub    %eax,%edx
+c0105cfc:	89 d0                	mov    %edx,%eax
+c0105cfe:	eb 05                	jmp    c0105d05 <strncmp+0x54>
+c0105d00:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0105d05:	5d                   	pop    %ebp
+c0105d06:	c3                   	ret    
+
+c0105d07 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+c0105d07:	55                   	push   %ebp
+c0105d08:	89 e5                	mov    %esp,%ebp
+c0105d0a:	83 ec 04             	sub    $0x4,%esp
+c0105d0d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105d10:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+c0105d13:	eb 14                	jmp    c0105d29 <strchr+0x22>
+        if (*s == c) {
+c0105d15:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d18:	0f b6 00             	movzbl (%eax),%eax
+c0105d1b:	3a 45 fc             	cmp    -0x4(%ebp),%al
+c0105d1e:	75 05                	jne    c0105d25 <strchr+0x1e>
+            return (char *)s;
+c0105d20:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d23:	eb 13                	jmp    c0105d38 <strchr+0x31>
+        }
+        s ++;
+c0105d25:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+c0105d29:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d2c:	0f b6 00             	movzbl (%eax),%eax
+c0105d2f:	84 c0                	test   %al,%al
+c0105d31:	75 e2                	jne    c0105d15 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+c0105d33:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c0105d38:	c9                   	leave  
+c0105d39:	c3                   	ret    
+
+c0105d3a <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+c0105d3a:	55                   	push   %ebp
+c0105d3b:	89 e5                	mov    %esp,%ebp
+c0105d3d:	83 ec 04             	sub    $0x4,%esp
+c0105d40:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105d43:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+c0105d46:	eb 11                	jmp    c0105d59 <strfind+0x1f>
+        if (*s == c) {
+c0105d48:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d4b:	0f b6 00             	movzbl (%eax),%eax
+c0105d4e:	3a 45 fc             	cmp    -0x4(%ebp),%al
+c0105d51:	75 02                	jne    c0105d55 <strfind+0x1b>
+            break;
+c0105d53:	eb 0e                	jmp    c0105d63 <strfind+0x29>
+        }
+        s ++;
+c0105d55:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+c0105d59:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d5c:	0f b6 00             	movzbl (%eax),%eax
+c0105d5f:	84 c0                	test   %al,%al
+c0105d61:	75 e5                	jne    c0105d48 <strfind+0xe>
+        if (*s == c) {
+            break;
+        }
+        s ++;
+    }
+    return (char *)s;
+c0105d63:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+c0105d66:	c9                   	leave  
+c0105d67:	c3                   	ret    
+
+c0105d68 <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+c0105d68:	55                   	push   %ebp
+c0105d69:	89 e5                	mov    %esp,%ebp
+c0105d6b:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+c0105d6e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+c0105d75:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+c0105d7c:	eb 04                	jmp    c0105d82 <strtol+0x1a>
+        s ++;
+c0105d7e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+c0105d82:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d85:	0f b6 00             	movzbl (%eax),%eax
+c0105d88:	3c 20                	cmp    $0x20,%al
+c0105d8a:	74 f2                	je     c0105d7e <strtol+0x16>
+c0105d8c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d8f:	0f b6 00             	movzbl (%eax),%eax
+c0105d92:	3c 09                	cmp    $0x9,%al
+c0105d94:	74 e8                	je     c0105d7e <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+c0105d96:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d99:	0f b6 00             	movzbl (%eax),%eax
+c0105d9c:	3c 2b                	cmp    $0x2b,%al
+c0105d9e:	75 06                	jne    c0105da6 <strtol+0x3e>
+        s ++;
+c0105da0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c0105da4:	eb 15                	jmp    c0105dbb <strtol+0x53>
+    }
+    else if (*s == '-') {
+c0105da6:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105da9:	0f b6 00             	movzbl (%eax),%eax
+c0105dac:	3c 2d                	cmp    $0x2d,%al
+c0105dae:	75 0b                	jne    c0105dbb <strtol+0x53>
+        s ++, neg = 1;
+c0105db0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c0105db4:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+c0105dbb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0105dbf:	74 06                	je     c0105dc7 <strtol+0x5f>
+c0105dc1:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+c0105dc5:	75 24                	jne    c0105deb <strtol+0x83>
+c0105dc7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105dca:	0f b6 00             	movzbl (%eax),%eax
+c0105dcd:	3c 30                	cmp    $0x30,%al
+c0105dcf:	75 1a                	jne    c0105deb <strtol+0x83>
+c0105dd1:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105dd4:	83 c0 01             	add    $0x1,%eax
+c0105dd7:	0f b6 00             	movzbl (%eax),%eax
+c0105dda:	3c 78                	cmp    $0x78,%al
+c0105ddc:	75 0d                	jne    c0105deb <strtol+0x83>
+        s += 2, base = 16;
+c0105dde:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+c0105de2:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+c0105de9:	eb 2a                	jmp    c0105e15 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+c0105deb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0105def:	75 17                	jne    c0105e08 <strtol+0xa0>
+c0105df1:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105df4:	0f b6 00             	movzbl (%eax),%eax
+c0105df7:	3c 30                	cmp    $0x30,%al
+c0105df9:	75 0d                	jne    c0105e08 <strtol+0xa0>
+        s ++, base = 8;
+c0105dfb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c0105dff:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+c0105e06:	eb 0d                	jmp    c0105e15 <strtol+0xad>
+    }
+    else if (base == 0) {
+c0105e08:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0105e0c:	75 07                	jne    c0105e15 <strtol+0xad>
+        base = 10;
+c0105e0e:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+c0105e15:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e18:	0f b6 00             	movzbl (%eax),%eax
+c0105e1b:	3c 2f                	cmp    $0x2f,%al
+c0105e1d:	7e 1b                	jle    c0105e3a <strtol+0xd2>
+c0105e1f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e22:	0f b6 00             	movzbl (%eax),%eax
+c0105e25:	3c 39                	cmp    $0x39,%al
+c0105e27:	7f 11                	jg     c0105e3a <strtol+0xd2>
+            dig = *s - '0';
+c0105e29:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e2c:	0f b6 00             	movzbl (%eax),%eax
+c0105e2f:	0f be c0             	movsbl %al,%eax
+c0105e32:	83 e8 30             	sub    $0x30,%eax
+c0105e35:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105e38:	eb 48                	jmp    c0105e82 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+c0105e3a:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e3d:	0f b6 00             	movzbl (%eax),%eax
+c0105e40:	3c 60                	cmp    $0x60,%al
+c0105e42:	7e 1b                	jle    c0105e5f <strtol+0xf7>
+c0105e44:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e47:	0f b6 00             	movzbl (%eax),%eax
+c0105e4a:	3c 7a                	cmp    $0x7a,%al
+c0105e4c:	7f 11                	jg     c0105e5f <strtol+0xf7>
+            dig = *s - 'a' + 10;
+c0105e4e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e51:	0f b6 00             	movzbl (%eax),%eax
+c0105e54:	0f be c0             	movsbl %al,%eax
+c0105e57:	83 e8 57             	sub    $0x57,%eax
+c0105e5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105e5d:	eb 23                	jmp    c0105e82 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+c0105e5f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e62:	0f b6 00             	movzbl (%eax),%eax
+c0105e65:	3c 40                	cmp    $0x40,%al
+c0105e67:	7e 3d                	jle    c0105ea6 <strtol+0x13e>
+c0105e69:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e6c:	0f b6 00             	movzbl (%eax),%eax
+c0105e6f:	3c 5a                	cmp    $0x5a,%al
+c0105e71:	7f 33                	jg     c0105ea6 <strtol+0x13e>
+            dig = *s - 'A' + 10;
+c0105e73:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105e76:	0f b6 00             	movzbl (%eax),%eax
+c0105e79:	0f be c0             	movsbl %al,%eax
+c0105e7c:	83 e8 37             	sub    $0x37,%eax
+c0105e7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+c0105e82:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105e85:	3b 45 10             	cmp    0x10(%ebp),%eax
+c0105e88:	7c 02                	jl     c0105e8c <strtol+0x124>
+            break;
+c0105e8a:	eb 1a                	jmp    c0105ea6 <strtol+0x13e>
+        }
+        s ++, val = (val * base) + dig;
+c0105e8c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c0105e90:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0105e93:	0f af 45 10          	imul   0x10(%ebp),%eax
+c0105e97:	89 c2                	mov    %eax,%edx
+c0105e99:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105e9c:	01 d0                	add    %edx,%eax
+c0105e9e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+c0105ea1:	e9 6f ff ff ff       	jmp    c0105e15 <strtol+0xad>
+
+    if (endptr) {
+c0105ea6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0105eaa:	74 08                	je     c0105eb4 <strtol+0x14c>
+        *endptr = (char *) s;
+c0105eac:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105eaf:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105eb2:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+c0105eb4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c0105eb8:	74 07                	je     c0105ec1 <strtol+0x159>
+c0105eba:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0105ebd:	f7 d8                	neg    %eax
+c0105ebf:	eb 03                	jmp    c0105ec4 <strtol+0x15c>
+c0105ec1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+c0105ec4:	c9                   	leave  
+c0105ec5:	c3                   	ret    
+
+c0105ec6 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+c0105ec6:	55                   	push   %ebp
+c0105ec7:	89 e5                	mov    %esp,%ebp
+c0105ec9:	57                   	push   %edi
+c0105eca:	83 ec 24             	sub    $0x24,%esp
+c0105ecd:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105ed0:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+c0105ed3:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+c0105ed7:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105eda:	89 55 f8             	mov    %edx,-0x8(%ebp)
+c0105edd:	88 45 f7             	mov    %al,-0x9(%ebp)
+c0105ee0:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105ee3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+c0105ee6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+c0105ee9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+c0105eed:	8b 55 f8             	mov    -0x8(%ebp),%edx
+c0105ef0:	89 d7                	mov    %edx,%edi
+c0105ef2:	f3 aa                	rep stos %al,%es:(%edi)
+c0105ef4:	89 fa                	mov    %edi,%edx
+c0105ef6:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+c0105ef9:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+c0105efc:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+c0105eff:	83 c4 24             	add    $0x24,%esp
+c0105f02:	5f                   	pop    %edi
+c0105f03:	5d                   	pop    %ebp
+c0105f04:	c3                   	ret    
+
+c0105f05 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+c0105f05:	55                   	push   %ebp
+c0105f06:	89 e5                	mov    %esp,%ebp
+c0105f08:	57                   	push   %edi
+c0105f09:	56                   	push   %esi
+c0105f0a:	53                   	push   %ebx
+c0105f0b:	83 ec 30             	sub    $0x30,%esp
+c0105f0e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105f11:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105f14:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105f17:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0105f1a:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105f1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+c0105f20:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105f23:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0105f26:	73 42                	jae    c0105f6a <memmove+0x65>
+c0105f28:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105f2b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0105f2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105f31:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0105f34:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105f37:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+c0105f3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0105f3d:	c1 e8 02             	shr    $0x2,%eax
+c0105f40:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+c0105f42:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0105f45:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105f48:	89 d7                	mov    %edx,%edi
+c0105f4a:	89 c6                	mov    %eax,%esi
+c0105f4c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+c0105f4e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+c0105f51:	83 e1 03             	and    $0x3,%ecx
+c0105f54:	74 02                	je     c0105f58 <memmove+0x53>
+c0105f56:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c0105f58:	89 f0                	mov    %esi,%eax
+c0105f5a:	89 fa                	mov    %edi,%edx
+c0105f5c:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+c0105f5f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c0105f62:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+c0105f65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105f68:	eb 36                	jmp    c0105fa0 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+c0105f6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105f6d:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0105f70:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105f73:	01 c2                	add    %eax,%edx
+c0105f75:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105f78:	8d 48 ff             	lea    -0x1(%eax),%ecx
+c0105f7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105f7e:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+c0105f81:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105f84:	89 c1                	mov    %eax,%ecx
+c0105f86:	89 d8                	mov    %ebx,%eax
+c0105f88:	89 d6                	mov    %edx,%esi
+c0105f8a:	89 c7                	mov    %eax,%edi
+c0105f8c:	fd                   	std    
+c0105f8d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c0105f8f:	fc                   	cld    
+c0105f90:	89 f8                	mov    %edi,%eax
+c0105f92:	89 f2                	mov    %esi,%edx
+c0105f94:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+c0105f97:	89 55 c8             	mov    %edx,-0x38(%ebp)
+c0105f9a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+c0105f9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+c0105fa0:	83 c4 30             	add    $0x30,%esp
+c0105fa3:	5b                   	pop    %ebx
+c0105fa4:	5e                   	pop    %esi
+c0105fa5:	5f                   	pop    %edi
+c0105fa6:	5d                   	pop    %ebp
+c0105fa7:	c3                   	ret    
+
+c0105fa8 <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+c0105fa8:	55                   	push   %ebp
+c0105fa9:	89 e5                	mov    %esp,%ebp
+c0105fab:	57                   	push   %edi
+c0105fac:	56                   	push   %esi
+c0105fad:	83 ec 20             	sub    $0x20,%esp
+c0105fb0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105fb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105fb6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105fb9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105fbc:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+c0105fc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105fc5:	c1 e8 02             	shr    $0x2,%eax
+c0105fc8:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+c0105fca:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105fcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105fd0:	89 d7                	mov    %edx,%edi
+c0105fd2:	89 c6                	mov    %eax,%esi
+c0105fd4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+c0105fd6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+c0105fd9:	83 e1 03             	and    $0x3,%ecx
+c0105fdc:	74 02                	je     c0105fe0 <memcpy+0x38>
+c0105fde:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c0105fe0:	89 f0                	mov    %esi,%eax
+c0105fe2:	89 fa                	mov    %edi,%edx
+c0105fe4:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+c0105fe7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c0105fea:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+c0105fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+c0105ff0:	83 c4 20             	add    $0x20,%esp
+c0105ff3:	5e                   	pop    %esi
+c0105ff4:	5f                   	pop    %edi
+c0105ff5:	5d                   	pop    %ebp
+c0105ff6:	c3                   	ret    
+
+c0105ff7 <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+c0105ff7:	55                   	push   %ebp
+c0105ff8:	89 e5                	mov    %esp,%ebp
+c0105ffa:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+c0105ffd:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106000:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+c0106003:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0106006:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+c0106009:	eb 30                	jmp    c010603b <memcmp+0x44>
+        if (*s1 != *s2) {
+c010600b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010600e:	0f b6 10             	movzbl (%eax),%edx
+c0106011:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0106014:	0f b6 00             	movzbl (%eax),%eax
+c0106017:	38 c2                	cmp    %al,%dl
+c0106019:	74 18                	je     c0106033 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+c010601b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010601e:	0f b6 00             	movzbl (%eax),%eax
+c0106021:	0f b6 d0             	movzbl %al,%edx
+c0106024:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0106027:	0f b6 00             	movzbl (%eax),%eax
+c010602a:	0f b6 c0             	movzbl %al,%eax
+c010602d:	29 c2                	sub    %eax,%edx
+c010602f:	89 d0                	mov    %edx,%eax
+c0106031:	eb 1a                	jmp    c010604d <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+c0106033:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c0106037:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+c010603b:	8b 45 10             	mov    0x10(%ebp),%eax
+c010603e:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0106041:	89 55 10             	mov    %edx,0x10(%ebp)
+c0106044:	85 c0                	test   %eax,%eax
+c0106046:	75 c3                	jne    c010600b <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+c0106048:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+c010604d:	c9                   	leave  
+c010604e:	c3                   	ret    
diff -r -u -P lab2_origin/obj/kernel_nopage.asm lab2/obj/kernel_nopage.asm
--- lab2_origin/obj/kernel_nopage.asm	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kernel_nopage.asm	2021-08-29 21:35:38.862604847 +0800
@@ -0,0 +1,12692 @@
+
+bin/kernel_nopage:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00100000 <kern_entry>:
+.text
+.globl kern_entry
+kern_entry:
+    # reload temperate gdt (second time) to remap all physical memory
+    # virtual_addr 0~4G=linear_addr&physical_addr -KERNBASE~4G-KERNBASE 
+    lgdt REALLOC(__gdtdesc)
+  100000:	0f 01 15 18 70 11 40 	lgdtl  0x40117018
+    movl $KERNEL_DS, %eax
+  100007:	b8 10 00 00 00       	mov    $0x10,%eax
+    movw %ax, %ds
+  10000c:	8e d8                	mov    %eax,%ds
+    movw %ax, %es
+  10000e:	8e c0                	mov    %eax,%es
+    movw %ax, %ss
+  100010:	8e d0                	mov    %eax,%ss
+
+    ljmp $KERNEL_CS, $relocated
+  100012:	ea 19 00 10 00 08 00 	ljmp   $0x8,$0x100019
+
+00100019 <relocated>:
+
+relocated:
+
+    # set ebp, esp
+    movl $0x0, %ebp
+  100019:	bd 00 00 00 00       	mov    $0x0,%ebp
+    # the kernel stack region is from bootstack -- bootstacktop,
+    # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h
+    movl $bootstacktop, %esp
+  10001e:	bc 00 70 11 00       	mov    $0x117000,%esp
+    # now kernel stack is ready , call the first C function
+    call kern_init
+  100023:	e8 02 00 00 00       	call   10002a <kern_init>
+
+00100028 <spin>:
+
+# should never get here
+spin:
+    jmp spin
+  100028:	eb fe                	jmp    100028 <spin>
+
+0010002a <kern_init>:
+int kern_init(void) __attribute__((noreturn));
+void grade_backtrace(void);
+static void lab1_switch_test(void);
+
+int
+kern_init(void) {
+  10002a:	55                   	push   %ebp
+  10002b:	89 e5                	mov    %esp,%ebp
+  10002d:	83 ec 28             	sub    $0x28,%esp
+    extern char edata[], end[];
+    memset(edata, 0, end - edata);
+  100030:	ba c8 89 11 00       	mov    $0x1189c8,%edx
+  100035:	b8 36 7a 11 00       	mov    $0x117a36,%eax
+  10003a:	29 c2                	sub    %eax,%edx
+  10003c:	89 d0                	mov    %edx,%eax
+  10003e:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100042:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  100049:	00 
+  10004a:	c7 04 24 36 7a 11 00 	movl   $0x117a36,(%esp)
+  100051:	e8 70 5e 00 00       	call   105ec6 <memset>
+
+    cons_init();                // init the console
+  100056:	e8 6b 15 00 00       	call   1015c6 <cons_init>
+
+    const char *message = "(THU.CST) os is loading ...";
+  10005b:	c7 45 f4 60 60 10 00 	movl   $0x106060,-0xc(%ebp)
+    cprintf("%s\n\n", message);
+  100062:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100065:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100069:	c7 04 24 7c 60 10 00 	movl   $0x10607c,(%esp)
+  100070:	e8 c7 02 00 00       	call   10033c <cprintf>
+
+    print_kerninfo();
+  100075:	e8 f6 07 00 00       	call   100870 <print_kerninfo>
+
+    grade_backtrace();
+  10007a:	e8 86 00 00 00       	call   100105 <grade_backtrace>
+
+    pmm_init();                 // init physical memory management
+  10007f:	e8 5e 43 00 00       	call   1043e2 <pmm_init>
+
+    pic_init();                 // init interrupt controller
+  100084:	e8 a6 16 00 00       	call   10172f <pic_init>
+    idt_init();                 // init interrupt descriptor table
+  100089:	e8 1e 18 00 00       	call   1018ac <idt_init>
+
+    clock_init();               // init clock interrupt
+  10008e:	e8 e9 0c 00 00       	call   100d7c <clock_init>
+    intr_enable();              // enable irq interrupt
+  100093:	e8 05 16 00 00       	call   10169d <intr_enable>
+    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
+    // user/kernel mode switch test
+    //lab1_switch_test();
+
+    /* do nothing */
+    while (1);
+  100098:	eb fe                	jmp    100098 <kern_init+0x6e>
+
+0010009a <grade_backtrace2>:
+}
+
+void __attribute__((noinline))
+grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
+  10009a:	55                   	push   %ebp
+  10009b:	89 e5                	mov    %esp,%ebp
+  10009d:	83 ec 18             	sub    $0x18,%esp
+    mon_backtrace(0, NULL, NULL);
+  1000a0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  1000a7:	00 
+  1000a8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  1000af:	00 
+  1000b0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  1000b7:	e8 f2 0b 00 00       	call   100cae <mon_backtrace>
+}
+  1000bc:	c9                   	leave  
+  1000bd:	c3                   	ret    
+
+001000be <grade_backtrace1>:
+
+void __attribute__((noinline))
+grade_backtrace1(int arg0, int arg1) {
+  1000be:	55                   	push   %ebp
+  1000bf:	89 e5                	mov    %esp,%ebp
+  1000c1:	53                   	push   %ebx
+  1000c2:	83 ec 14             	sub    $0x14,%esp
+    grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
+  1000c5:	8d 5d 0c             	lea    0xc(%ebp),%ebx
+  1000c8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  1000cb:	8d 55 08             	lea    0x8(%ebp),%edx
+  1000ce:	8b 45 08             	mov    0x8(%ebp),%eax
+  1000d1:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  1000d5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  1000d9:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1000dd:	89 04 24             	mov    %eax,(%esp)
+  1000e0:	e8 b5 ff ff ff       	call   10009a <grade_backtrace2>
+}
+  1000e5:	83 c4 14             	add    $0x14,%esp
+  1000e8:	5b                   	pop    %ebx
+  1000e9:	5d                   	pop    %ebp
+  1000ea:	c3                   	ret    
+
+001000eb <grade_backtrace0>:
+
+void __attribute__((noinline))
+grade_backtrace0(int arg0, int arg1, int arg2) {
+  1000eb:	55                   	push   %ebp
+  1000ec:	89 e5                	mov    %esp,%ebp
+  1000ee:	83 ec 18             	sub    $0x18,%esp
+    grade_backtrace1(arg0, arg2);
+  1000f1:	8b 45 10             	mov    0x10(%ebp),%eax
+  1000f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1000f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  1000fb:	89 04 24             	mov    %eax,(%esp)
+  1000fe:	e8 bb ff ff ff       	call   1000be <grade_backtrace1>
+}
+  100103:	c9                   	leave  
+  100104:	c3                   	ret    
+
+00100105 <grade_backtrace>:
+
+void
+grade_backtrace(void) {
+  100105:	55                   	push   %ebp
+  100106:	89 e5                	mov    %esp,%ebp
+  100108:	83 ec 18             	sub    $0x18,%esp
+    grade_backtrace0(0, (int)kern_init, 0xffff0000);
+  10010b:	b8 2a 00 10 00       	mov    $0x10002a,%eax
+  100110:	c7 44 24 08 00 00 ff 	movl   $0xffff0000,0x8(%esp)
+  100117:	ff 
+  100118:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10011c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  100123:	e8 c3 ff ff ff       	call   1000eb <grade_backtrace0>
+}
+  100128:	c9                   	leave  
+  100129:	c3                   	ret    
+
+0010012a <lab1_print_cur_status>:
+
+static void
+lab1_print_cur_status(void) {
+  10012a:	55                   	push   %ebp
+  10012b:	89 e5                	mov    %esp,%ebp
+  10012d:	83 ec 28             	sub    $0x28,%esp
+    static int round = 0;
+    uint16_t reg1, reg2, reg3, reg4;
+    asm volatile (
+  100130:	8c 4d f6             	mov    %cs,-0xa(%ebp)
+  100133:	8c 5d f4             	mov    %ds,-0xc(%ebp)
+  100136:	8c 45 f2             	mov    %es,-0xe(%ebp)
+  100139:	8c 55 f0             	mov    %ss,-0x10(%ebp)
+            "mov %%cs, %0;"
+            "mov %%ds, %1;"
+            "mov %%es, %2;"
+            "mov %%ss, %3;"
+            : "=m"(reg1), "=m"(reg2), "=m"(reg3), "=m"(reg4));
+    cprintf("%d: @ring %d\n", round, reg1 & 3);
+  10013c:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  100140:	0f b7 c0             	movzwl %ax,%eax
+  100143:	83 e0 03             	and    $0x3,%eax
+  100146:	89 c2                	mov    %eax,%edx
+  100148:	a1 40 7a 11 00       	mov    0x117a40,%eax
+  10014d:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100151:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100155:	c7 04 24 81 60 10 00 	movl   $0x106081,(%esp)
+  10015c:	e8 db 01 00 00       	call   10033c <cprintf>
+    cprintf("%d:  cs = %x\n", round, reg1);
+  100161:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  100165:	0f b7 d0             	movzwl %ax,%edx
+  100168:	a1 40 7a 11 00       	mov    0x117a40,%eax
+  10016d:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100171:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100175:	c7 04 24 8f 60 10 00 	movl   $0x10608f,(%esp)
+  10017c:	e8 bb 01 00 00       	call   10033c <cprintf>
+    cprintf("%d:  ds = %x\n", round, reg2);
+  100181:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
+  100185:	0f b7 d0             	movzwl %ax,%edx
+  100188:	a1 40 7a 11 00       	mov    0x117a40,%eax
+  10018d:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100191:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100195:	c7 04 24 9d 60 10 00 	movl   $0x10609d,(%esp)
+  10019c:	e8 9b 01 00 00       	call   10033c <cprintf>
+    cprintf("%d:  es = %x\n", round, reg3);
+  1001a1:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+  1001a5:	0f b7 d0             	movzwl %ax,%edx
+  1001a8:	a1 40 7a 11 00       	mov    0x117a40,%eax
+  1001ad:	89 54 24 08          	mov    %edx,0x8(%esp)
+  1001b1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1001b5:	c7 04 24 ab 60 10 00 	movl   $0x1060ab,(%esp)
+  1001bc:	e8 7b 01 00 00       	call   10033c <cprintf>
+    cprintf("%d:  ss = %x\n", round, reg4);
+  1001c1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+  1001c5:	0f b7 d0             	movzwl %ax,%edx
+  1001c8:	a1 40 7a 11 00       	mov    0x117a40,%eax
+  1001cd:	89 54 24 08          	mov    %edx,0x8(%esp)
+  1001d1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1001d5:	c7 04 24 b9 60 10 00 	movl   $0x1060b9,(%esp)
+  1001dc:	e8 5b 01 00 00       	call   10033c <cprintf>
+    round ++;
+  1001e1:	a1 40 7a 11 00       	mov    0x117a40,%eax
+  1001e6:	83 c0 01             	add    $0x1,%eax
+  1001e9:	a3 40 7a 11 00       	mov    %eax,0x117a40
+}
+  1001ee:	c9                   	leave  
+  1001ef:	c3                   	ret    
+
+001001f0 <lab1_switch_to_user>:
+
+static void
+lab1_switch_to_user(void) {
+  1001f0:	55                   	push   %ebp
+  1001f1:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 : TODO
+}
+  1001f3:	5d                   	pop    %ebp
+  1001f4:	c3                   	ret    
+
+001001f5 <lab1_switch_to_kernel>:
+
+static void
+lab1_switch_to_kernel(void) {
+  1001f5:	55                   	push   %ebp
+  1001f6:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 :  TODO
+}
+  1001f8:	5d                   	pop    %ebp
+  1001f9:	c3                   	ret    
+
+001001fa <lab1_switch_test>:
+
+static void
+lab1_switch_test(void) {
+  1001fa:	55                   	push   %ebp
+  1001fb:	89 e5                	mov    %esp,%ebp
+  1001fd:	83 ec 18             	sub    $0x18,%esp
+    lab1_print_cur_status();
+  100200:	e8 25 ff ff ff       	call   10012a <lab1_print_cur_status>
+    cprintf("+++ switch to  user  mode +++\n");
+  100205:	c7 04 24 c8 60 10 00 	movl   $0x1060c8,(%esp)
+  10020c:	e8 2b 01 00 00       	call   10033c <cprintf>
+    lab1_switch_to_user();
+  100211:	e8 da ff ff ff       	call   1001f0 <lab1_switch_to_user>
+    lab1_print_cur_status();
+  100216:	e8 0f ff ff ff       	call   10012a <lab1_print_cur_status>
+    cprintf("+++ switch to kernel mode +++\n");
+  10021b:	c7 04 24 e8 60 10 00 	movl   $0x1060e8,(%esp)
+  100222:	e8 15 01 00 00       	call   10033c <cprintf>
+    lab1_switch_to_kernel();
+  100227:	e8 c9 ff ff ff       	call   1001f5 <lab1_switch_to_kernel>
+    lab1_print_cur_status();
+  10022c:	e8 f9 fe ff ff       	call   10012a <lab1_print_cur_status>
+}
+  100231:	c9                   	leave  
+  100232:	c3                   	ret    
+
+00100233 <readline>:
+ * The readline() function returns the text of the line read. If some errors
+ * are happened, NULL is returned. The return value is a global variable,
+ * thus it should be copied before it is used.
+ * */
+char *
+readline(const char *prompt) {
+  100233:	55                   	push   %ebp
+  100234:	89 e5                	mov    %esp,%ebp
+  100236:	83 ec 28             	sub    $0x28,%esp
+    if (prompt != NULL) {
+  100239:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  10023d:	74 13                	je     100252 <readline+0x1f>
+        cprintf("%s", prompt);
+  10023f:	8b 45 08             	mov    0x8(%ebp),%eax
+  100242:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100246:	c7 04 24 07 61 10 00 	movl   $0x106107,(%esp)
+  10024d:	e8 ea 00 00 00       	call   10033c <cprintf>
+    }
+    int i = 0, c;
+  100252:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        c = getchar();
+  100259:	e8 66 01 00 00       	call   1003c4 <getchar>
+  10025e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (c < 0) {
+  100261:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  100265:	79 07                	jns    10026e <readline+0x3b>
+            return NULL;
+  100267:	b8 00 00 00 00       	mov    $0x0,%eax
+  10026c:	eb 79                	jmp    1002e7 <readline+0xb4>
+        }
+        else if (c >= ' ' && i < BUFSIZE - 1) {
+  10026e:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
+  100272:	7e 28                	jle    10029c <readline+0x69>
+  100274:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
+  10027b:	7f 1f                	jg     10029c <readline+0x69>
+            cputchar(c);
+  10027d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100280:	89 04 24             	mov    %eax,(%esp)
+  100283:	e8 da 00 00 00       	call   100362 <cputchar>
+            buf[i ++] = c;
+  100288:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10028b:	8d 50 01             	lea    0x1(%eax),%edx
+  10028e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  100291:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100294:	88 90 60 7a 11 00    	mov    %dl,0x117a60(%eax)
+  10029a:	eb 46                	jmp    1002e2 <readline+0xaf>
+        }
+        else if (c == '\b' && i > 0) {
+  10029c:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
+  1002a0:	75 17                	jne    1002b9 <readline+0x86>
+  1002a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  1002a6:	7e 11                	jle    1002b9 <readline+0x86>
+            cputchar(c);
+  1002a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1002ab:	89 04 24             	mov    %eax,(%esp)
+  1002ae:	e8 af 00 00 00       	call   100362 <cputchar>
+            i --;
+  1002b3:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  1002b7:	eb 29                	jmp    1002e2 <readline+0xaf>
+        }
+        else if (c == '\n' || c == '\r') {
+  1002b9:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+  1002bd:	74 06                	je     1002c5 <readline+0x92>
+  1002bf:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+  1002c3:	75 1d                	jne    1002e2 <readline+0xaf>
+            cputchar(c);
+  1002c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1002c8:	89 04 24             	mov    %eax,(%esp)
+  1002cb:	e8 92 00 00 00       	call   100362 <cputchar>
+            buf[i] = '\0';
+  1002d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1002d3:	05 60 7a 11 00       	add    $0x117a60,%eax
+  1002d8:	c6 00 00             	movb   $0x0,(%eax)
+            return buf;
+  1002db:	b8 60 7a 11 00       	mov    $0x117a60,%eax
+  1002e0:	eb 05                	jmp    1002e7 <readline+0xb4>
+        }
+    }
+  1002e2:	e9 72 ff ff ff       	jmp    100259 <readline+0x26>
+}
+  1002e7:	c9                   	leave  
+  1002e8:	c3                   	ret    
+
+001002e9 <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  1002e9:	55                   	push   %ebp
+  1002ea:	89 e5                	mov    %esp,%ebp
+  1002ec:	83 ec 18             	sub    $0x18,%esp
+    cons_putc(c);
+  1002ef:	8b 45 08             	mov    0x8(%ebp),%eax
+  1002f2:	89 04 24             	mov    %eax,(%esp)
+  1002f5:	e8 f8 12 00 00       	call   1015f2 <cons_putc>
+    (*cnt) ++;
+  1002fa:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1002fd:	8b 00                	mov    (%eax),%eax
+  1002ff:	8d 50 01             	lea    0x1(%eax),%edx
+  100302:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100305:	89 10                	mov    %edx,(%eax)
+}
+  100307:	c9                   	leave  
+  100308:	c3                   	ret    
+
+00100309 <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  100309:	55                   	push   %ebp
+  10030a:	89 e5                	mov    %esp,%ebp
+  10030c:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+  10030f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  100316:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100319:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  10031d:	8b 45 08             	mov    0x8(%ebp),%eax
+  100320:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100324:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  100327:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10032b:	c7 04 24 e9 02 10 00 	movl   $0x1002e9,(%esp)
+  100332:	e8 a8 53 00 00       	call   1056df <vprintfmt>
+    return cnt;
+  100337:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  10033a:	c9                   	leave  
+  10033b:	c3                   	ret    
+
+0010033c <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  10033c:	55                   	push   %ebp
+  10033d:	89 e5                	mov    %esp,%ebp
+  10033f:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  100342:	8d 45 0c             	lea    0xc(%ebp),%eax
+  100345:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vcprintf(fmt, ap);
+  100348:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10034b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10034f:	8b 45 08             	mov    0x8(%ebp),%eax
+  100352:	89 04 24             	mov    %eax,(%esp)
+  100355:	e8 af ff ff ff       	call   100309 <vcprintf>
+  10035a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  10035d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  100360:	c9                   	leave  
+  100361:	c3                   	ret    
+
+00100362 <cputchar>:
+
+/* cputchar - writes a single character to stdout */
+void
+cputchar(int c) {
+  100362:	55                   	push   %ebp
+  100363:	89 e5                	mov    %esp,%ebp
+  100365:	83 ec 18             	sub    $0x18,%esp
+    cons_putc(c);
+  100368:	8b 45 08             	mov    0x8(%ebp),%eax
+  10036b:	89 04 24             	mov    %eax,(%esp)
+  10036e:	e8 7f 12 00 00       	call   1015f2 <cons_putc>
+}
+  100373:	c9                   	leave  
+  100374:	c3                   	ret    
+
+00100375 <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  100375:	55                   	push   %ebp
+  100376:	89 e5                	mov    %esp,%ebp
+  100378:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+  10037b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  100382:	eb 13                	jmp    100397 <cputs+0x22>
+        cputch(c, &cnt);
+  100384:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  100388:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  10038b:	89 54 24 04          	mov    %edx,0x4(%esp)
+  10038f:	89 04 24             	mov    %eax,(%esp)
+  100392:	e8 52 ff ff ff       	call   1002e9 <cputch>
+ * */
+int
+cputs(const char *str) {
+    int cnt = 0;
+    char c;
+    while ((c = *str ++) != '\0') {
+  100397:	8b 45 08             	mov    0x8(%ebp),%eax
+  10039a:	8d 50 01             	lea    0x1(%eax),%edx
+  10039d:	89 55 08             	mov    %edx,0x8(%ebp)
+  1003a0:	0f b6 00             	movzbl (%eax),%eax
+  1003a3:	88 45 f7             	mov    %al,-0x9(%ebp)
+  1003a6:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  1003aa:	75 d8                	jne    100384 <cputs+0xf>
+        cputch(c, &cnt);
+    }
+    cputch('\n', &cnt);
+  1003ac:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  1003af:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1003b3:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+  1003ba:	e8 2a ff ff ff       	call   1002e9 <cputch>
+    return cnt;
+  1003bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  1003c2:	c9                   	leave  
+  1003c3:	c3                   	ret    
+
+001003c4 <getchar>:
+
+/* getchar - reads a single non-zero character from stdin */
+int
+getchar(void) {
+  1003c4:	55                   	push   %ebp
+  1003c5:	89 e5                	mov    %esp,%ebp
+  1003c7:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = cons_getc()) == 0)
+  1003ca:	e8 5f 12 00 00       	call   10162e <cons_getc>
+  1003cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  1003d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  1003d6:	74 f2                	je     1003ca <getchar+0x6>
+        /* do nothing */;
+    return c;
+  1003d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  1003db:	c9                   	leave  
+  1003dc:	c3                   	ret    
+
+001003dd <stab_binsearch>:
+ *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+ * will exit setting left = 118, right = 554.
+ * */
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+  1003dd:	55                   	push   %ebp
+  1003de:	89 e5                	mov    %esp,%ebp
+  1003e0:	83 ec 20             	sub    $0x20,%esp
+    int l = *region_left, r = *region_right, any_matches = 0;
+  1003e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1003e6:	8b 00                	mov    (%eax),%eax
+  1003e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  1003eb:	8b 45 10             	mov    0x10(%ebp),%eax
+  1003ee:	8b 00                	mov    (%eax),%eax
+  1003f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  1003f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+    while (l <= r) {
+  1003fa:	e9 d2 00 00 00       	jmp    1004d1 <stab_binsearch+0xf4>
+        int true_m = (l + r) / 2, m = true_m;
+  1003ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  100402:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  100405:	01 d0                	add    %edx,%eax
+  100407:	89 c2                	mov    %eax,%edx
+  100409:	c1 ea 1f             	shr    $0x1f,%edx
+  10040c:	01 d0                	add    %edx,%eax
+  10040e:	d1 f8                	sar    %eax
+  100410:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  100413:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100416:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+  100419:	eb 04                	jmp    10041f <stab_binsearch+0x42>
+            m --;
+  10041b:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
+
+    while (l <= r) {
+        int true_m = (l + r) / 2, m = true_m;
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+  10041f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100422:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  100425:	7c 1f                	jl     100446 <stab_binsearch+0x69>
+  100427:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  10042a:	89 d0                	mov    %edx,%eax
+  10042c:	01 c0                	add    %eax,%eax
+  10042e:	01 d0                	add    %edx,%eax
+  100430:	c1 e0 02             	shl    $0x2,%eax
+  100433:	89 c2                	mov    %eax,%edx
+  100435:	8b 45 08             	mov    0x8(%ebp),%eax
+  100438:	01 d0                	add    %edx,%eax
+  10043a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  10043e:	0f b6 c0             	movzbl %al,%eax
+  100441:	3b 45 14             	cmp    0x14(%ebp),%eax
+  100444:	75 d5                	jne    10041b <stab_binsearch+0x3e>
+            m --;
+        }
+        if (m < l) {    // no match in [l, m]
+  100446:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100449:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  10044c:	7d 0b                	jge    100459 <stab_binsearch+0x7c>
+            l = true_m + 1;
+  10044e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100451:	83 c0 01             	add    $0x1,%eax
+  100454:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            continue;
+  100457:	eb 78                	jmp    1004d1 <stab_binsearch+0xf4>
+        }
+
+        // actual binary search
+        any_matches = 1;
+  100459:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+        if (stabs[m].n_value < addr) {
+  100460:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100463:	89 d0                	mov    %edx,%eax
+  100465:	01 c0                	add    %eax,%eax
+  100467:	01 d0                	add    %edx,%eax
+  100469:	c1 e0 02             	shl    $0x2,%eax
+  10046c:	89 c2                	mov    %eax,%edx
+  10046e:	8b 45 08             	mov    0x8(%ebp),%eax
+  100471:	01 d0                	add    %edx,%eax
+  100473:	8b 40 08             	mov    0x8(%eax),%eax
+  100476:	3b 45 18             	cmp    0x18(%ebp),%eax
+  100479:	73 13                	jae    10048e <stab_binsearch+0xb1>
+            *region_left = m;
+  10047b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10047e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100481:	89 10                	mov    %edx,(%eax)
+            l = true_m + 1;
+  100483:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100486:	83 c0 01             	add    $0x1,%eax
+  100489:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  10048c:	eb 43                	jmp    1004d1 <stab_binsearch+0xf4>
+        } else if (stabs[m].n_value > addr) {
+  10048e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100491:	89 d0                	mov    %edx,%eax
+  100493:	01 c0                	add    %eax,%eax
+  100495:	01 d0                	add    %edx,%eax
+  100497:	c1 e0 02             	shl    $0x2,%eax
+  10049a:	89 c2                	mov    %eax,%edx
+  10049c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10049f:	01 d0                	add    %edx,%eax
+  1004a1:	8b 40 08             	mov    0x8(%eax),%eax
+  1004a4:	3b 45 18             	cmp    0x18(%ebp),%eax
+  1004a7:	76 16                	jbe    1004bf <stab_binsearch+0xe2>
+            *region_right = m - 1;
+  1004a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1004ac:	8d 50 ff             	lea    -0x1(%eax),%edx
+  1004af:	8b 45 10             	mov    0x10(%ebp),%eax
+  1004b2:	89 10                	mov    %edx,(%eax)
+            r = m - 1;
+  1004b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1004b7:	83 e8 01             	sub    $0x1,%eax
+  1004ba:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  1004bd:	eb 12                	jmp    1004d1 <stab_binsearch+0xf4>
+        } else {
+            // exact match for 'addr', but continue loop to find
+            // *region_right
+            *region_left = m;
+  1004bf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1004c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  1004c5:	89 10                	mov    %edx,(%eax)
+            l = m;
+  1004c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1004ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            addr ++;
+  1004cd:	83 45 18 01          	addl   $0x1,0x18(%ebp)
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+    int l = *region_left, r = *region_right, any_matches = 0;
+
+    while (l <= r) {
+  1004d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1004d4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+  1004d7:	0f 8e 22 ff ff ff    	jle    1003ff <stab_binsearch+0x22>
+            l = m;
+            addr ++;
+        }
+    }
+
+    if (!any_matches) {
+  1004dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  1004e1:	75 0f                	jne    1004f2 <stab_binsearch+0x115>
+        *region_right = *region_left - 1;
+  1004e3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1004e6:	8b 00                	mov    (%eax),%eax
+  1004e8:	8d 50 ff             	lea    -0x1(%eax),%edx
+  1004eb:	8b 45 10             	mov    0x10(%ebp),%eax
+  1004ee:	89 10                	mov    %edx,(%eax)
+  1004f0:	eb 3f                	jmp    100531 <stab_binsearch+0x154>
+    }
+    else {
+        // find rightmost region containing 'addr'
+        l = *region_right;
+  1004f2:	8b 45 10             	mov    0x10(%ebp),%eax
+  1004f5:	8b 00                	mov    (%eax),%eax
+  1004f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+  1004fa:	eb 04                	jmp    100500 <stab_binsearch+0x123>
+  1004fc:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
+  100500:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100503:	8b 00                	mov    (%eax),%eax
+  100505:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  100508:	7d 1f                	jge    100529 <stab_binsearch+0x14c>
+  10050a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  10050d:	89 d0                	mov    %edx,%eax
+  10050f:	01 c0                	add    %eax,%eax
+  100511:	01 d0                	add    %edx,%eax
+  100513:	c1 e0 02             	shl    $0x2,%eax
+  100516:	89 c2                	mov    %eax,%edx
+  100518:	8b 45 08             	mov    0x8(%ebp),%eax
+  10051b:	01 d0                	add    %edx,%eax
+  10051d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  100521:	0f b6 c0             	movzbl %al,%eax
+  100524:	3b 45 14             	cmp    0x14(%ebp),%eax
+  100527:	75 d3                	jne    1004fc <stab_binsearch+0x11f>
+            /* do nothing */;
+        *region_left = l;
+  100529:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10052c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  10052f:	89 10                	mov    %edx,(%eax)
+    }
+}
+  100531:	c9                   	leave  
+  100532:	c3                   	ret    
+
+00100533 <debuginfo_eip>:
+ * the specified instruction address, @addr.  Returns 0 if information
+ * was found, and negative if not.  But even if it returns negative it
+ * has stored some information into '*info'.
+ * */
+int
+debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
+  100533:	55                   	push   %ebp
+  100534:	89 e5                	mov    %esp,%ebp
+  100536:	83 ec 58             	sub    $0x58,%esp
+    const struct stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+
+    info->eip_file = "<unknown>";
+  100539:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10053c:	c7 00 0c 61 10 00    	movl   $0x10610c,(%eax)
+    info->eip_line = 0;
+  100542:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100545:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    info->eip_fn_name = "<unknown>";
+  10054c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10054f:	c7 40 08 0c 61 10 00 	movl   $0x10610c,0x8(%eax)
+    info->eip_fn_namelen = 9;
+  100556:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100559:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
+    info->eip_fn_addr = addr;
+  100560:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100563:	8b 55 08             	mov    0x8(%ebp),%edx
+  100566:	89 50 10             	mov    %edx,0x10(%eax)
+    info->eip_fn_narg = 0;
+  100569:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10056c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+
+    stabs = __STAB_BEGIN__;
+  100573:	c7 45 f4 68 73 10 00 	movl   $0x107368,-0xc(%ebp)
+    stab_end = __STAB_END__;
+  10057a:	c7 45 f0 00 20 11 00 	movl   $0x112000,-0x10(%ebp)
+    stabstr = __STABSTR_BEGIN__;
+  100581:	c7 45 ec 01 20 11 00 	movl   $0x112001,-0x14(%ebp)
+    stabstr_end = __STABSTR_END__;
+  100588:	c7 45 e8 5a 4a 11 00 	movl   $0x114a5a,-0x18(%ebp)
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
+  10058f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100592:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  100595:	76 0d                	jbe    1005a4 <debuginfo_eip+0x71>
+  100597:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  10059a:	83 e8 01             	sub    $0x1,%eax
+  10059d:	0f b6 00             	movzbl (%eax),%eax
+  1005a0:	84 c0                	test   %al,%al
+  1005a2:	74 0a                	je     1005ae <debuginfo_eip+0x7b>
+        return -1;
+  1005a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  1005a9:	e9 c0 02 00 00       	jmp    10086e <debuginfo_eip+0x33b>
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    int lfile = 0, rfile = (stab_end - stabs) - 1;
+  1005ae:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  1005b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  1005b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1005bb:	29 c2                	sub    %eax,%edx
+  1005bd:	89 d0                	mov    %edx,%eax
+  1005bf:	c1 f8 02             	sar    $0x2,%eax
+  1005c2:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
+  1005c8:	83 e8 01             	sub    $0x1,%eax
+  1005cb:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+  1005ce:	8b 45 08             	mov    0x8(%ebp),%eax
+  1005d1:	89 44 24 10          	mov    %eax,0x10(%esp)
+  1005d5:	c7 44 24 0c 64 00 00 	movl   $0x64,0xc(%esp)
+  1005dc:	00 
+  1005dd:	8d 45 e0             	lea    -0x20(%ebp),%eax
+  1005e0:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1005e4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+  1005e7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1005eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1005ee:	89 04 24             	mov    %eax,(%esp)
+  1005f1:	e8 e7 fd ff ff       	call   1003dd <stab_binsearch>
+    if (lfile == 0)
+  1005f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1005f9:	85 c0                	test   %eax,%eax
+  1005fb:	75 0a                	jne    100607 <debuginfo_eip+0xd4>
+        return -1;
+  1005fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  100602:	e9 67 02 00 00       	jmp    10086e <debuginfo_eip+0x33b>
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    int lfun = lfile, rfun = rfile;
+  100607:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10060a:	89 45 dc             	mov    %eax,-0x24(%ebp)
+  10060d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  100610:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    int lline, rline;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+  100613:	8b 45 08             	mov    0x8(%ebp),%eax
+  100616:	89 44 24 10          	mov    %eax,0x10(%esp)
+  10061a:	c7 44 24 0c 24 00 00 	movl   $0x24,0xc(%esp)
+  100621:	00 
+  100622:	8d 45 d8             	lea    -0x28(%ebp),%eax
+  100625:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100629:	8d 45 dc             	lea    -0x24(%ebp),%eax
+  10062c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100630:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100633:	89 04 24             	mov    %eax,(%esp)
+  100636:	e8 a2 fd ff ff       	call   1003dd <stab_binsearch>
+
+    if (lfun <= rfun) {
+  10063b:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  10063e:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  100641:	39 c2                	cmp    %eax,%edx
+  100643:	7f 7c                	jg     1006c1 <debuginfo_eip+0x18e>
+        // stabs[lfun] points to the function name
+        // in the string table, but check bounds just in case.
+        if (stabs[lfun].n_strx < stabstr_end - stabstr) {
+  100645:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100648:	89 c2                	mov    %eax,%edx
+  10064a:	89 d0                	mov    %edx,%eax
+  10064c:	01 c0                	add    %eax,%eax
+  10064e:	01 d0                	add    %edx,%eax
+  100650:	c1 e0 02             	shl    $0x2,%eax
+  100653:	89 c2                	mov    %eax,%edx
+  100655:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100658:	01 d0                	add    %edx,%eax
+  10065a:	8b 10                	mov    (%eax),%edx
+  10065c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+  10065f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100662:	29 c1                	sub    %eax,%ecx
+  100664:	89 c8                	mov    %ecx,%eax
+  100666:	39 c2                	cmp    %eax,%edx
+  100668:	73 22                	jae    10068c <debuginfo_eip+0x159>
+            info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+  10066a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  10066d:	89 c2                	mov    %eax,%edx
+  10066f:	89 d0                	mov    %edx,%eax
+  100671:	01 c0                	add    %eax,%eax
+  100673:	01 d0                	add    %edx,%eax
+  100675:	c1 e0 02             	shl    $0x2,%eax
+  100678:	89 c2                	mov    %eax,%edx
+  10067a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10067d:	01 d0                	add    %edx,%eax
+  10067f:	8b 10                	mov    (%eax),%edx
+  100681:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100684:	01 c2                	add    %eax,%edx
+  100686:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100689:	89 50 08             	mov    %edx,0x8(%eax)
+        }
+        info->eip_fn_addr = stabs[lfun].n_value;
+  10068c:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  10068f:	89 c2                	mov    %eax,%edx
+  100691:	89 d0                	mov    %edx,%eax
+  100693:	01 c0                	add    %eax,%eax
+  100695:	01 d0                	add    %edx,%eax
+  100697:	c1 e0 02             	shl    $0x2,%eax
+  10069a:	89 c2                	mov    %eax,%edx
+  10069c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10069f:	01 d0                	add    %edx,%eax
+  1006a1:	8b 50 08             	mov    0x8(%eax),%edx
+  1006a4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1006a7:	89 50 10             	mov    %edx,0x10(%eax)
+        addr -= info->eip_fn_addr;
+  1006aa:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1006ad:	8b 40 10             	mov    0x10(%eax),%eax
+  1006b0:	29 45 08             	sub    %eax,0x8(%ebp)
+        // Search within the function definition for the line number.
+        lline = lfun;
+  1006b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  1006b6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        rline = rfun;
+  1006b9:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  1006bc:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  1006bf:	eb 15                	jmp    1006d6 <debuginfo_eip+0x1a3>
+    } else {
+        // Couldn't find function stab!  Maybe we're in an assembly
+        // file.  Search the whole file for the line number.
+        info->eip_fn_addr = addr;
+  1006c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1006c4:	8b 55 08             	mov    0x8(%ebp),%edx
+  1006c7:	89 50 10             	mov    %edx,0x10(%eax)
+        lline = lfile;
+  1006ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1006cd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        rline = rfile;
+  1006d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1006d3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    }
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+  1006d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1006d9:	8b 40 08             	mov    0x8(%eax),%eax
+  1006dc:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
+  1006e3:	00 
+  1006e4:	89 04 24             	mov    %eax,(%esp)
+  1006e7:	e8 4e 56 00 00       	call   105d3a <strfind>
+  1006ec:	89 c2                	mov    %eax,%edx
+  1006ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1006f1:	8b 40 08             	mov    0x8(%eax),%eax
+  1006f4:	29 c2                	sub    %eax,%edx
+  1006f6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1006f9:	89 50 0c             	mov    %edx,0xc(%eax)
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+  1006fc:	8b 45 08             	mov    0x8(%ebp),%eax
+  1006ff:	89 44 24 10          	mov    %eax,0x10(%esp)
+  100703:	c7 44 24 0c 44 00 00 	movl   $0x44,0xc(%esp)
+  10070a:	00 
+  10070b:	8d 45 d0             	lea    -0x30(%ebp),%eax
+  10070e:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100712:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+  100715:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100719:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10071c:	89 04 24             	mov    %eax,(%esp)
+  10071f:	e8 b9 fc ff ff       	call   1003dd <stab_binsearch>
+    if (lline <= rline) {
+  100724:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  100727:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  10072a:	39 c2                	cmp    %eax,%edx
+  10072c:	7f 24                	jg     100752 <debuginfo_eip+0x21f>
+        info->eip_line = stabs[rline].n_desc;
+  10072e:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  100731:	89 c2                	mov    %eax,%edx
+  100733:	89 d0                	mov    %edx,%eax
+  100735:	01 c0                	add    %eax,%eax
+  100737:	01 d0                	add    %edx,%eax
+  100739:	c1 e0 02             	shl    $0x2,%eax
+  10073c:	89 c2                	mov    %eax,%edx
+  10073e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100741:	01 d0                	add    %edx,%eax
+  100743:	0f b7 40 06          	movzwl 0x6(%eax),%eax
+  100747:	0f b7 d0             	movzwl %ax,%edx
+  10074a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10074d:	89 50 04             	mov    %edx,0x4(%eax)
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+  100750:	eb 13                	jmp    100765 <debuginfo_eip+0x232>
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+    if (lline <= rline) {
+        info->eip_line = stabs[rline].n_desc;
+    } else {
+        return -1;
+  100752:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  100757:	e9 12 01 00 00       	jmp    10086e <debuginfo_eip+0x33b>
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+           && stabs[lline].n_type != N_SOL
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+        lline --;
+  10075c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  10075f:	83 e8 01             	sub    $0x1,%eax
+  100762:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+  100765:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  100768:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10076b:	39 c2                	cmp    %eax,%edx
+  10076d:	7c 56                	jl     1007c5 <debuginfo_eip+0x292>
+           && stabs[lline].n_type != N_SOL
+  10076f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100772:	89 c2                	mov    %eax,%edx
+  100774:	89 d0                	mov    %edx,%eax
+  100776:	01 c0                	add    %eax,%eax
+  100778:	01 d0                	add    %edx,%eax
+  10077a:	c1 e0 02             	shl    $0x2,%eax
+  10077d:	89 c2                	mov    %eax,%edx
+  10077f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100782:	01 d0                	add    %edx,%eax
+  100784:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  100788:	3c 84                	cmp    $0x84,%al
+  10078a:	74 39                	je     1007c5 <debuginfo_eip+0x292>
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+  10078c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  10078f:	89 c2                	mov    %eax,%edx
+  100791:	89 d0                	mov    %edx,%eax
+  100793:	01 c0                	add    %eax,%eax
+  100795:	01 d0                	add    %edx,%eax
+  100797:	c1 e0 02             	shl    $0x2,%eax
+  10079a:	89 c2                	mov    %eax,%edx
+  10079c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10079f:	01 d0                	add    %edx,%eax
+  1007a1:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  1007a5:	3c 64                	cmp    $0x64,%al
+  1007a7:	75 b3                	jne    10075c <debuginfo_eip+0x229>
+  1007a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  1007ac:	89 c2                	mov    %eax,%edx
+  1007ae:	89 d0                	mov    %edx,%eax
+  1007b0:	01 c0                	add    %eax,%eax
+  1007b2:	01 d0                	add    %edx,%eax
+  1007b4:	c1 e0 02             	shl    $0x2,%eax
+  1007b7:	89 c2                	mov    %eax,%edx
+  1007b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1007bc:	01 d0                	add    %edx,%eax
+  1007be:	8b 40 08             	mov    0x8(%eax),%eax
+  1007c1:	85 c0                	test   %eax,%eax
+  1007c3:	74 97                	je     10075c <debuginfo_eip+0x229>
+        lline --;
+    }
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
+  1007c5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  1007c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1007cb:	39 c2                	cmp    %eax,%edx
+  1007cd:	7c 46                	jl     100815 <debuginfo_eip+0x2e2>
+  1007cf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  1007d2:	89 c2                	mov    %eax,%edx
+  1007d4:	89 d0                	mov    %edx,%eax
+  1007d6:	01 c0                	add    %eax,%eax
+  1007d8:	01 d0                	add    %edx,%eax
+  1007da:	c1 e0 02             	shl    $0x2,%eax
+  1007dd:	89 c2                	mov    %eax,%edx
+  1007df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1007e2:	01 d0                	add    %edx,%eax
+  1007e4:	8b 10                	mov    (%eax),%edx
+  1007e6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+  1007e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1007ec:	29 c1                	sub    %eax,%ecx
+  1007ee:	89 c8                	mov    %ecx,%eax
+  1007f0:	39 c2                	cmp    %eax,%edx
+  1007f2:	73 21                	jae    100815 <debuginfo_eip+0x2e2>
+        info->eip_file = stabstr + stabs[lline].n_strx;
+  1007f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  1007f7:	89 c2                	mov    %eax,%edx
+  1007f9:	89 d0                	mov    %edx,%eax
+  1007fb:	01 c0                	add    %eax,%eax
+  1007fd:	01 d0                	add    %edx,%eax
+  1007ff:	c1 e0 02             	shl    $0x2,%eax
+  100802:	89 c2                	mov    %eax,%edx
+  100804:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100807:	01 d0                	add    %edx,%eax
+  100809:	8b 10                	mov    (%eax),%edx
+  10080b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  10080e:	01 c2                	add    %eax,%edx
+  100810:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100813:	89 10                	mov    %edx,(%eax)
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+  100815:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  100818:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  10081b:	39 c2                	cmp    %eax,%edx
+  10081d:	7d 4a                	jge    100869 <debuginfo_eip+0x336>
+        for (lline = lfun + 1;
+  10081f:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100822:	83 c0 01             	add    $0x1,%eax
+  100825:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  100828:	eb 18                	jmp    100842 <debuginfo_eip+0x30f>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+            info->eip_fn_narg ++;
+  10082a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10082d:	8b 40 14             	mov    0x14(%eax),%eax
+  100830:	8d 50 01             	lea    0x1(%eax),%edx
+  100833:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100836:	89 50 14             	mov    %edx,0x14(%eax)
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+  100839:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  10083c:	83 c0 01             	add    $0x1,%eax
+  10083f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+  100842:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  100845:	8b 45 d8             	mov    -0x28(%ebp),%eax
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+        for (lline = lfun + 1;
+  100848:	39 c2                	cmp    %eax,%edx
+  10084a:	7d 1d                	jge    100869 <debuginfo_eip+0x336>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+  10084c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  10084f:	89 c2                	mov    %eax,%edx
+  100851:	89 d0                	mov    %edx,%eax
+  100853:	01 c0                	add    %eax,%eax
+  100855:	01 d0                	add    %edx,%eax
+  100857:	c1 e0 02             	shl    $0x2,%eax
+  10085a:	89 c2                	mov    %eax,%edx
+  10085c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10085f:	01 d0                	add    %edx,%eax
+  100861:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  100865:	3c a0                	cmp    $0xa0,%al
+  100867:	74 c1                	je     10082a <debuginfo_eip+0x2f7>
+             lline ++) {
+            info->eip_fn_narg ++;
+        }
+    }
+    return 0;
+  100869:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  10086e:	c9                   	leave  
+  10086f:	c3                   	ret    
+
+00100870 <print_kerninfo>:
+ * print_kerninfo - print the information about kernel, including the location
+ * of kernel entry, the start addresses of data and text segements, the start
+ * address of free memory and how many memory that kernel has used.
+ * */
+void
+print_kerninfo(void) {
+  100870:	55                   	push   %ebp
+  100871:	89 e5                	mov    %esp,%ebp
+  100873:	83 ec 18             	sub    $0x18,%esp
+    extern char etext[], edata[], end[], kern_init[];
+    cprintf("Special kernel symbols:\n");
+  100876:	c7 04 24 16 61 10 00 	movl   $0x106116,(%esp)
+  10087d:	e8 ba fa ff ff       	call   10033c <cprintf>
+    cprintf("  entry  0x%08x (phys)\n", kern_init);
+  100882:	c7 44 24 04 2a 00 10 	movl   $0x10002a,0x4(%esp)
+  100889:	00 
+  10088a:	c7 04 24 2f 61 10 00 	movl   $0x10612f,(%esp)
+  100891:	e8 a6 fa ff ff       	call   10033c <cprintf>
+    cprintf("  etext  0x%08x (phys)\n", etext);
+  100896:	c7 44 24 04 4f 60 10 	movl   $0x10604f,0x4(%esp)
+  10089d:	00 
+  10089e:	c7 04 24 47 61 10 00 	movl   $0x106147,(%esp)
+  1008a5:	e8 92 fa ff ff       	call   10033c <cprintf>
+    cprintf("  edata  0x%08x (phys)\n", edata);
+  1008aa:	c7 44 24 04 36 7a 11 	movl   $0x117a36,0x4(%esp)
+  1008b1:	00 
+  1008b2:	c7 04 24 5f 61 10 00 	movl   $0x10615f,(%esp)
+  1008b9:	e8 7e fa ff ff       	call   10033c <cprintf>
+    cprintf("  end    0x%08x (phys)\n", end);
+  1008be:	c7 44 24 04 c8 89 11 	movl   $0x1189c8,0x4(%esp)
+  1008c5:	00 
+  1008c6:	c7 04 24 77 61 10 00 	movl   $0x106177,(%esp)
+  1008cd:	e8 6a fa ff ff       	call   10033c <cprintf>
+    cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
+  1008d2:	b8 c8 89 11 00       	mov    $0x1189c8,%eax
+  1008d7:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+  1008dd:	b8 2a 00 10 00       	mov    $0x10002a,%eax
+  1008e2:	29 c2                	sub    %eax,%edx
+  1008e4:	89 d0                	mov    %edx,%eax
+  1008e6:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+  1008ec:	85 c0                	test   %eax,%eax
+  1008ee:	0f 48 c2             	cmovs  %edx,%eax
+  1008f1:	c1 f8 0a             	sar    $0xa,%eax
+  1008f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1008f8:	c7 04 24 90 61 10 00 	movl   $0x106190,(%esp)
+  1008ff:	e8 38 fa ff ff       	call   10033c <cprintf>
+}
+  100904:	c9                   	leave  
+  100905:	c3                   	ret    
+
+00100906 <print_debuginfo>:
+/* *
+ * print_debuginfo - read and print the stat information for the address @eip,
+ * and info.eip_fn_addr should be the first address of the related function.
+ * */
+void
+print_debuginfo(uintptr_t eip) {
+  100906:	55                   	push   %ebp
+  100907:	89 e5                	mov    %esp,%ebp
+  100909:	81 ec 48 01 00 00    	sub    $0x148,%esp
+    struct eipdebuginfo info;
+    if (debuginfo_eip(eip, &info) != 0) {
+  10090f:	8d 45 dc             	lea    -0x24(%ebp),%eax
+  100912:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100916:	8b 45 08             	mov    0x8(%ebp),%eax
+  100919:	89 04 24             	mov    %eax,(%esp)
+  10091c:	e8 12 fc ff ff       	call   100533 <debuginfo_eip>
+  100921:	85 c0                	test   %eax,%eax
+  100923:	74 15                	je     10093a <print_debuginfo+0x34>
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+  100925:	8b 45 08             	mov    0x8(%ebp),%eax
+  100928:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10092c:	c7 04 24 ba 61 10 00 	movl   $0x1061ba,(%esp)
+  100933:	e8 04 fa ff ff       	call   10033c <cprintf>
+  100938:	eb 6d                	jmp    1009a7 <print_debuginfo+0xa1>
+    }
+    else{ 
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+  10093a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  100941:	eb 1c                	jmp    10095f <print_debuginfo+0x59>
+            fnname[j] = info.eip_fn_name[j];
+  100943:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  100946:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100949:	01 d0                	add    %edx,%eax
+  10094b:	0f b6 00             	movzbl (%eax),%eax
+  10094e:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+  100954:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100957:	01 ca                	add    %ecx,%edx
+  100959:	88 02                	mov    %al,(%edx)
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+    }
+    else{ 
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+  10095b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  10095f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100962:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  100965:	7f dc                	jg     100943 <print_debuginfo+0x3d>
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+  100967:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
+  10096d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100970:	01 d0                	add    %edx,%eax
+  100972:	c6 00 00             	movb   $0x0,(%eax)
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+  100975:	8b 45 ec             	mov    -0x14(%ebp),%eax
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+            fnname[j] = info.eip_fn_name[j];
+        }
+        fnname[j] = '\0';
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+  100978:	8b 55 08             	mov    0x8(%ebp),%edx
+  10097b:	89 d1                	mov    %edx,%ecx
+  10097d:	29 c1                	sub    %eax,%ecx
+  10097f:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  100982:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100985:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  100989:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+  10098f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+  100993:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100997:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10099b:	c7 04 24 d6 61 10 00 	movl   $0x1061d6,(%esp)
+  1009a2:	e8 95 f9 ff ff       	call   10033c <cprintf>
+                fnname, eip - info.eip_fn_addr);
+    }
+}
+  1009a7:	c9                   	leave  
+  1009a8:	c3                   	ret    
+
+001009a9 <read_eip>:
+
+static __noinline uint32_t
+read_eip(void) {
+  1009a9:	55                   	push   %ebp
+  1009aa:	89 e5                	mov    %esp,%ebp
+  1009ac:	83 ec 10             	sub    $0x10,%esp
+    uint32_t eip;
+    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
+  1009af:	8b 45 04             	mov    0x4(%ebp),%eax
+  1009b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    return eip;
+  1009b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  1009b8:	c9                   	leave  
+  1009b9:	c3                   	ret    
+
+001009ba <print_stackframe>:
+ *
+ * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
+ * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
+ * */
+void
+print_stackframe(void) {
+  1009ba:	55                   	push   %ebp
+  1009bb:	89 e5                	mov    %esp,%ebp
+  1009bd:	83 ec 38             	sub    $0x38,%esp
+}
+
+static inline uint32_t
+read_ebp(void) {
+    uint32_t ebp;
+    asm volatile ("movl %%ebp, %0" : "=r" (ebp));
+  1009c0:	89 e8                	mov    %ebp,%eax
+  1009c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    return ebp;
+  1009c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
+      *    (3.5) popup a calling stackframe
+      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+	uint32_t ebp = read_ebp();
+  1009c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	uint32_t eip = read_eip();
+  1009cb:	e8 d9 ff ff ff       	call   1009a9 <read_eip>
+  1009d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+	int i,j;
+	for(i=0;i<STACKFRAME_DEPTH;i++){
+  1009d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  1009da:	e9 88 00 00 00       	jmp    100a67 <print_stackframe+0xad>
+		cprintf("ebp:0x%08x eip:0x%08x args:",ebp,eip);
+  1009df:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1009e2:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1009e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1009e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1009ed:	c7 04 24 e8 61 10 00 	movl   $0x1061e8,(%esp)
+  1009f4:	e8 43 f9 ff ff       	call   10033c <cprintf>
+		uint32_t *args = (uint32_t *)ebp +2;
+  1009f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1009fc:	83 c0 08             	add    $0x8,%eax
+  1009ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		for(j=0;j<4;j++){
+  100a02:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+  100a09:	eb 25                	jmp    100a30 <print_stackframe+0x76>
+			cprintf("0x%08x ",args[j]);
+  100a0b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100a0e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  100a15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  100a18:	01 d0                	add    %edx,%eax
+  100a1a:	8b 00                	mov    (%eax),%eax
+  100a1c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100a20:	c7 04 24 04 62 10 00 	movl   $0x106204,(%esp)
+  100a27:	e8 10 f9 ff ff       	call   10033c <cprintf>
+	uint32_t eip = read_eip();
+	int i,j;
+	for(i=0;i<STACKFRAME_DEPTH;i++){
+		cprintf("ebp:0x%08x eip:0x%08x args:",ebp,eip);
+		uint32_t *args = (uint32_t *)ebp +2;
+		for(j=0;j<4;j++){
+  100a2c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+  100a30:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
+  100a34:	7e d5                	jle    100a0b <print_stackframe+0x51>
+			cprintf("0x%08x ",args[j]);
+		}
+		cprintf("\n");
+  100a36:	c7 04 24 0c 62 10 00 	movl   $0x10620c,(%esp)
+  100a3d:	e8 fa f8 ff ff       	call   10033c <cprintf>
+		print_debuginfo(eip-1);
+  100a42:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100a45:	83 e8 01             	sub    $0x1,%eax
+  100a48:	89 04 24             	mov    %eax,(%esp)
+  100a4b:	e8 b6 fe ff ff       	call   100906 <print_debuginfo>
+		eip = ((uint32_t *)ebp)[1];
+  100a50:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100a53:	83 c0 04             	add    $0x4,%eax
+  100a56:	8b 00                	mov    (%eax),%eax
+  100a58:	89 45 f0             	mov    %eax,-0x10(%ebp)
+		ebp = ((uint32_t *)ebp)[0];
+  100a5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100a5e:	8b 00                	mov    (%eax),%eax
+  100a60:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+	uint32_t ebp = read_ebp();
+	uint32_t eip = read_eip();
+	int i,j;
+	for(i=0;i<STACKFRAME_DEPTH;i++){
+  100a63:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+  100a67:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
+  100a6b:	0f 8e 6e ff ff ff    	jle    1009df <print_stackframe+0x25>
+		cprintf("\n");
+		print_debuginfo(eip-1);
+		eip = ((uint32_t *)ebp)[1];
+		ebp = ((uint32_t *)ebp)[0];
+	}
+}
+  100a71:	c9                   	leave  
+  100a72:	c3                   	ret    
+
+00100a73 <parse>:
+#define MAXARGS         16
+#define WHITESPACE      " \t\n\r"
+
+/* parse - parse the command buffer into whitespace-separated arguments */
+static int
+parse(char *buf, char **argv) {
+  100a73:	55                   	push   %ebp
+  100a74:	89 e5                	mov    %esp,%ebp
+  100a76:	83 ec 28             	sub    $0x28,%esp
+    int argc = 0;
+  100a79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100a80:	eb 0c                	jmp    100a8e <parse+0x1b>
+            *buf ++ = '\0';
+  100a82:	8b 45 08             	mov    0x8(%ebp),%eax
+  100a85:	8d 50 01             	lea    0x1(%eax),%edx
+  100a88:	89 55 08             	mov    %edx,0x8(%ebp)
+  100a8b:	c6 00 00             	movb   $0x0,(%eax)
+static int
+parse(char *buf, char **argv) {
+    int argc = 0;
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100a8e:	8b 45 08             	mov    0x8(%ebp),%eax
+  100a91:	0f b6 00             	movzbl (%eax),%eax
+  100a94:	84 c0                	test   %al,%al
+  100a96:	74 1d                	je     100ab5 <parse+0x42>
+  100a98:	8b 45 08             	mov    0x8(%ebp),%eax
+  100a9b:	0f b6 00             	movzbl (%eax),%eax
+  100a9e:	0f be c0             	movsbl %al,%eax
+  100aa1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100aa5:	c7 04 24 90 62 10 00 	movl   $0x106290,(%esp)
+  100aac:	e8 56 52 00 00       	call   105d07 <strchr>
+  100ab1:	85 c0                	test   %eax,%eax
+  100ab3:	75 cd                	jne    100a82 <parse+0xf>
+            *buf ++ = '\0';
+        }
+        if (*buf == '\0') {
+  100ab5:	8b 45 08             	mov    0x8(%ebp),%eax
+  100ab8:	0f b6 00             	movzbl (%eax),%eax
+  100abb:	84 c0                	test   %al,%al
+  100abd:	75 02                	jne    100ac1 <parse+0x4e>
+            break;
+  100abf:	eb 67                	jmp    100b28 <parse+0xb5>
+        }
+
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+  100ac1:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+  100ac5:	75 14                	jne    100adb <parse+0x68>
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+  100ac7:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
+  100ace:	00 
+  100acf:	c7 04 24 95 62 10 00 	movl   $0x106295,(%esp)
+  100ad6:	e8 61 f8 ff ff       	call   10033c <cprintf>
+        }
+        argv[argc ++] = buf;
+  100adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100ade:	8d 50 01             	lea    0x1(%eax),%edx
+  100ae1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  100ae4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  100aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100aee:	01 c2                	add    %eax,%edx
+  100af0:	8b 45 08             	mov    0x8(%ebp),%eax
+  100af3:	89 02                	mov    %eax,(%edx)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+  100af5:	eb 04                	jmp    100afb <parse+0x88>
+            buf ++;
+  100af7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+        // save and scan past next arg
+        if (argc == MAXARGS - 1) {
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+        }
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+  100afb:	8b 45 08             	mov    0x8(%ebp),%eax
+  100afe:	0f b6 00             	movzbl (%eax),%eax
+  100b01:	84 c0                	test   %al,%al
+  100b03:	74 1d                	je     100b22 <parse+0xaf>
+  100b05:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b08:	0f b6 00             	movzbl (%eax),%eax
+  100b0b:	0f be c0             	movsbl %al,%eax
+  100b0e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100b12:	c7 04 24 90 62 10 00 	movl   $0x106290,(%esp)
+  100b19:	e8 e9 51 00 00       	call   105d07 <strchr>
+  100b1e:	85 c0                	test   %eax,%eax
+  100b20:	74 d5                	je     100af7 <parse+0x84>
+            buf ++;
+        }
+    }
+  100b22:	90                   	nop
+static int
+parse(char *buf, char **argv) {
+    int argc = 0;
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100b23:	e9 66 ff ff ff       	jmp    100a8e <parse+0x1b>
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+            buf ++;
+        }
+    }
+    return argc;
+  100b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  100b2b:	c9                   	leave  
+  100b2c:	c3                   	ret    
+
+00100b2d <runcmd>:
+/* *
+ * runcmd - parse the input string, split it into separated arguments
+ * and then lookup and invoke some related commands/
+ * */
+static int
+runcmd(char *buf, struct trapframe *tf) {
+  100b2d:	55                   	push   %ebp
+  100b2e:	89 e5                	mov    %esp,%ebp
+  100b30:	83 ec 68             	sub    $0x68,%esp
+    char *argv[MAXARGS];
+    int argc = parse(buf, argv);
+  100b33:	8d 45 b0             	lea    -0x50(%ebp),%eax
+  100b36:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100b3a:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b3d:	89 04 24             	mov    %eax,(%esp)
+  100b40:	e8 2e ff ff ff       	call   100a73 <parse>
+  100b45:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if (argc == 0) {
+  100b48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  100b4c:	75 0a                	jne    100b58 <runcmd+0x2b>
+        return 0;
+  100b4e:	b8 00 00 00 00       	mov    $0x0,%eax
+  100b53:	e9 85 00 00 00       	jmp    100bdd <runcmd+0xb0>
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100b58:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  100b5f:	eb 5c                	jmp    100bbd <runcmd+0x90>
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+  100b61:	8b 4d b0             	mov    -0x50(%ebp),%ecx
+  100b64:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100b67:	89 d0                	mov    %edx,%eax
+  100b69:	01 c0                	add    %eax,%eax
+  100b6b:	01 d0                	add    %edx,%eax
+  100b6d:	c1 e0 02             	shl    $0x2,%eax
+  100b70:	05 20 70 11 00       	add    $0x117020,%eax
+  100b75:	8b 00                	mov    (%eax),%eax
+  100b77:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+  100b7b:	89 04 24             	mov    %eax,(%esp)
+  100b7e:	e8 e5 50 00 00       	call   105c68 <strcmp>
+  100b83:	85 c0                	test   %eax,%eax
+  100b85:	75 32                	jne    100bb9 <runcmd+0x8c>
+            return commands[i].func(argc - 1, argv + 1, tf);
+  100b87:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100b8a:	89 d0                	mov    %edx,%eax
+  100b8c:	01 c0                	add    %eax,%eax
+  100b8e:	01 d0                	add    %edx,%eax
+  100b90:	c1 e0 02             	shl    $0x2,%eax
+  100b93:	05 20 70 11 00       	add    $0x117020,%eax
+  100b98:	8b 40 08             	mov    0x8(%eax),%eax
+  100b9b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100b9e:	8d 4a ff             	lea    -0x1(%edx),%ecx
+  100ba1:	8b 55 0c             	mov    0xc(%ebp),%edx
+  100ba4:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100ba8:	8d 55 b0             	lea    -0x50(%ebp),%edx
+  100bab:	83 c2 04             	add    $0x4,%edx
+  100bae:	89 54 24 04          	mov    %edx,0x4(%esp)
+  100bb2:	89 0c 24             	mov    %ecx,(%esp)
+  100bb5:	ff d0                	call   *%eax
+  100bb7:	eb 24                	jmp    100bdd <runcmd+0xb0>
+    int argc = parse(buf, argv);
+    if (argc == 0) {
+        return 0;
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100bb9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  100bbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100bc0:	83 f8 02             	cmp    $0x2,%eax
+  100bc3:	76 9c                	jbe    100b61 <runcmd+0x34>
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+            return commands[i].func(argc - 1, argv + 1, tf);
+        }
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+  100bc5:	8b 45 b0             	mov    -0x50(%ebp),%eax
+  100bc8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100bcc:	c7 04 24 b3 62 10 00 	movl   $0x1062b3,(%esp)
+  100bd3:	e8 64 f7 ff ff       	call   10033c <cprintf>
+    return 0;
+  100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100bdd:	c9                   	leave  
+  100bde:	c3                   	ret    
+
+00100bdf <kmonitor>:
+
+/***** Implementations of basic kernel monitor commands *****/
+
+void
+kmonitor(struct trapframe *tf) {
+  100bdf:	55                   	push   %ebp
+  100be0:	89 e5                	mov    %esp,%ebp
+  100be2:	83 ec 28             	sub    $0x28,%esp
+    cprintf("Welcome to the kernel debug monitor!!\n");
+  100be5:	c7 04 24 cc 62 10 00 	movl   $0x1062cc,(%esp)
+  100bec:	e8 4b f7 ff ff       	call   10033c <cprintf>
+    cprintf("Type 'help' for a list of commands.\n");
+  100bf1:	c7 04 24 f4 62 10 00 	movl   $0x1062f4,(%esp)
+  100bf8:	e8 3f f7 ff ff       	call   10033c <cprintf>
+
+    if (tf != NULL) {
+  100bfd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  100c01:	74 0b                	je     100c0e <kmonitor+0x2f>
+        print_trapframe(tf);
+  100c03:	8b 45 08             	mov    0x8(%ebp),%eax
+  100c06:	89 04 24             	mov    %eax,(%esp)
+  100c09:	e8 56 0e 00 00       	call   101a64 <print_trapframe>
+    }
+
+    char *buf;
+    while (1) {
+        if ((buf = readline("K> ")) != NULL) {
+  100c0e:	c7 04 24 19 63 10 00 	movl   $0x106319,(%esp)
+  100c15:	e8 19 f6 ff ff       	call   100233 <readline>
+  100c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  100c1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  100c21:	74 18                	je     100c3b <kmonitor+0x5c>
+            if (runcmd(buf, tf) < 0) {
+  100c23:	8b 45 08             	mov    0x8(%ebp),%eax
+  100c26:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100c2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100c2d:	89 04 24             	mov    %eax,(%esp)
+  100c30:	e8 f8 fe ff ff       	call   100b2d <runcmd>
+  100c35:	85 c0                	test   %eax,%eax
+  100c37:	79 02                	jns    100c3b <kmonitor+0x5c>
+                break;
+  100c39:	eb 02                	jmp    100c3d <kmonitor+0x5e>
+            }
+        }
+    }
+  100c3b:	eb d1                	jmp    100c0e <kmonitor+0x2f>
+}
+  100c3d:	c9                   	leave  
+  100c3e:	c3                   	ret    
+
+00100c3f <mon_help>:
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+  100c3f:	55                   	push   %ebp
+  100c40:	89 e5                	mov    %esp,%ebp
+  100c42:	83 ec 28             	sub    $0x28,%esp
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100c45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  100c4c:	eb 3f                	jmp    100c8d <mon_help+0x4e>
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+  100c4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100c51:	89 d0                	mov    %edx,%eax
+  100c53:	01 c0                	add    %eax,%eax
+  100c55:	01 d0                	add    %edx,%eax
+  100c57:	c1 e0 02             	shl    $0x2,%eax
+  100c5a:	05 20 70 11 00       	add    $0x117020,%eax
+  100c5f:	8b 48 04             	mov    0x4(%eax),%ecx
+  100c62:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100c65:	89 d0                	mov    %edx,%eax
+  100c67:	01 c0                	add    %eax,%eax
+  100c69:	01 d0                	add    %edx,%eax
+  100c6b:	c1 e0 02             	shl    $0x2,%eax
+  100c6e:	05 20 70 11 00       	add    $0x117020,%eax
+  100c73:	8b 00                	mov    (%eax),%eax
+  100c75:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  100c79:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100c7d:	c7 04 24 1d 63 10 00 	movl   $0x10631d,(%esp)
+  100c84:	e8 b3 f6 ff ff       	call   10033c <cprintf>
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100c89:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  100c8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100c90:	83 f8 02             	cmp    $0x2,%eax
+  100c93:	76 b9                	jbe    100c4e <mon_help+0xf>
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+    }
+    return 0;
+  100c95:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100c9a:	c9                   	leave  
+  100c9b:	c3                   	ret    
+
+00100c9c <mon_kerninfo>:
+/* *
+ * mon_kerninfo - call print_kerninfo in kern/debug/kdebug.c to
+ * print the memory occupancy in kernel.
+ * */
+int
+mon_kerninfo(int argc, char **argv, struct trapframe *tf) {
+  100c9c:	55                   	push   %ebp
+  100c9d:	89 e5                	mov    %esp,%ebp
+  100c9f:	83 ec 08             	sub    $0x8,%esp
+    print_kerninfo();
+  100ca2:	e8 c9 fb ff ff       	call   100870 <print_kerninfo>
+    return 0;
+  100ca7:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100cac:	c9                   	leave  
+  100cad:	c3                   	ret    
+
+00100cae <mon_backtrace>:
+/* *
+ * mon_backtrace - call print_stackframe in kern/debug/kdebug.c to
+ * print a backtrace of the stack.
+ * */
+int
+mon_backtrace(int argc, char **argv, struct trapframe *tf) {
+  100cae:	55                   	push   %ebp
+  100caf:	89 e5                	mov    %esp,%ebp
+  100cb1:	83 ec 08             	sub    $0x8,%esp
+    print_stackframe();
+  100cb4:	e8 01 fd ff ff       	call   1009ba <print_stackframe>
+    return 0;
+  100cb9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100cbe:	c9                   	leave  
+  100cbf:	c3                   	ret    
+
+00100cc0 <__panic>:
+/* *
+ * __panic - __panic is called on unresolvable fatal errors. it prints
+ * "panic: 'message'", and then enters the kernel monitor.
+ * */
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  100cc0:	55                   	push   %ebp
+  100cc1:	89 e5                	mov    %esp,%ebp
+  100cc3:	83 ec 28             	sub    $0x28,%esp
+    if (is_panic) {
+  100cc6:	a1 60 7e 11 00       	mov    0x117e60,%eax
+  100ccb:	85 c0                	test   %eax,%eax
+  100ccd:	74 02                	je     100cd1 <__panic+0x11>
+        goto panic_dead;
+  100ccf:	eb 48                	jmp    100d19 <__panic+0x59>
+    }
+    is_panic = 1;
+  100cd1:	c7 05 60 7e 11 00 01 	movl   $0x1,0x117e60
+  100cd8:	00 00 00 
+
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  100cdb:	8d 45 14             	lea    0x14(%ebp),%eax
+  100cde:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel panic at %s:%d:\n    ", file, line);
+  100ce1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100ce4:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100ce8:	8b 45 08             	mov    0x8(%ebp),%eax
+  100ceb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100cef:	c7 04 24 26 63 10 00 	movl   $0x106326,(%esp)
+  100cf6:	e8 41 f6 ff ff       	call   10033c <cprintf>
+    vcprintf(fmt, ap);
+  100cfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100cfe:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100d02:	8b 45 10             	mov    0x10(%ebp),%eax
+  100d05:	89 04 24             	mov    %eax,(%esp)
+  100d08:	e8 fc f5 ff ff       	call   100309 <vcprintf>
+    cprintf("\n");
+  100d0d:	c7 04 24 42 63 10 00 	movl   $0x106342,(%esp)
+  100d14:	e8 23 f6 ff ff       	call   10033c <cprintf>
+    va_end(ap);
+
+panic_dead:
+    intr_disable();
+  100d19:	e8 85 09 00 00       	call   1016a3 <intr_disable>
+    while (1) {
+        kmonitor(NULL);
+  100d1e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  100d25:	e8 b5 fe ff ff       	call   100bdf <kmonitor>
+    }
+  100d2a:	eb f2                	jmp    100d1e <__panic+0x5e>
+
+00100d2c <__warn>:
+}
+
+/* __warn - like panic, but don't */
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  100d2c:	55                   	push   %ebp
+  100d2d:	89 e5                	mov    %esp,%ebp
+  100d2f:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  100d32:	8d 45 14             	lea    0x14(%ebp),%eax
+  100d35:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel warning at %s:%d:\n    ", file, line);
+  100d38:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100d3b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100d3f:	8b 45 08             	mov    0x8(%ebp),%eax
+  100d42:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100d46:	c7 04 24 44 63 10 00 	movl   $0x106344,(%esp)
+  100d4d:	e8 ea f5 ff ff       	call   10033c <cprintf>
+    vcprintf(fmt, ap);
+  100d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100d55:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100d59:	8b 45 10             	mov    0x10(%ebp),%eax
+  100d5c:	89 04 24             	mov    %eax,(%esp)
+  100d5f:	e8 a5 f5 ff ff       	call   100309 <vcprintf>
+    cprintf("\n");
+  100d64:	c7 04 24 42 63 10 00 	movl   $0x106342,(%esp)
+  100d6b:	e8 cc f5 ff ff       	call   10033c <cprintf>
+    va_end(ap);
+}
+  100d70:	c9                   	leave  
+  100d71:	c3                   	ret    
+
+00100d72 <is_kernel_panic>:
+
+bool
+is_kernel_panic(void) {
+  100d72:	55                   	push   %ebp
+  100d73:	89 e5                	mov    %esp,%ebp
+    return is_panic;
+  100d75:	a1 60 7e 11 00       	mov    0x117e60,%eax
+}
+  100d7a:	5d                   	pop    %ebp
+  100d7b:	c3                   	ret    
+
+00100d7c <clock_init>:
+/* *
+ * clock_init - initialize 8253 clock to interrupt 100 times per second,
+ * and then enable IRQ_TIMER.
+ * */
+void
+clock_init(void) {
+  100d7c:	55                   	push   %ebp
+  100d7d:	89 e5                	mov    %esp,%ebp
+  100d7f:	83 ec 28             	sub    $0x28,%esp
+  100d82:	66 c7 45 f6 43 00    	movw   $0x43,-0xa(%ebp)
+  100d88:	c6 45 f5 34          	movb   $0x34,-0xb(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+  100d8c:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  100d90:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  100d94:	ee                   	out    %al,(%dx)
+  100d95:	66 c7 45 f2 40 00    	movw   $0x40,-0xe(%ebp)
+  100d9b:	c6 45 f1 9c          	movb   $0x9c,-0xf(%ebp)
+  100d9f:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  100da3:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100da7:	ee                   	out    %al,(%dx)
+  100da8:	66 c7 45 ee 40 00    	movw   $0x40,-0x12(%ebp)
+  100dae:	c6 45 ed 2e          	movb   $0x2e,-0x13(%ebp)
+  100db2:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100db6:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  100dba:	ee                   	out    %al,(%dx)
+    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+    outb(IO_TIMER1, TIMER_DIV(100) % 256);
+    outb(IO_TIMER1, TIMER_DIV(100) / 256);
+
+    // initialize time counter 'ticks' to zero
+    ticks = 0;
+  100dbb:	c7 05 4c 89 11 00 00 	movl   $0x0,0x11894c
+  100dc2:	00 00 00 
+
+    cprintf("++ setup timer interrupts\n");
+  100dc5:	c7 04 24 62 63 10 00 	movl   $0x106362,(%esp)
+  100dcc:	e8 6b f5 ff ff       	call   10033c <cprintf>
+    pic_enable(IRQ_TIMER);
+  100dd1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  100dd8:	e8 24 09 00 00       	call   101701 <pic_enable>
+}
+  100ddd:	c9                   	leave  
+  100dde:	c3                   	ret    
+
+00100ddf <__intr_save>:
+#include <x86.h>
+#include <intr.h>
+#include <mmu.h>
+
+static inline bool
+__intr_save(void) {
+  100ddf:	55                   	push   %ebp
+  100de0:	89 e5                	mov    %esp,%ebp
+  100de2:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+  100de5:	9c                   	pushf  
+  100de6:	58                   	pop    %eax
+  100de7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+  100dea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+  100ded:	25 00 02 00 00       	and    $0x200,%eax
+  100df2:	85 c0                	test   %eax,%eax
+  100df4:	74 0c                	je     100e02 <__intr_save+0x23>
+        intr_disable();
+  100df6:	e8 a8 08 00 00       	call   1016a3 <intr_disable>
+        return 1;
+  100dfb:	b8 01 00 00 00       	mov    $0x1,%eax
+  100e00:	eb 05                	jmp    100e07 <__intr_save+0x28>
+    }
+    return 0;
+  100e02:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100e07:	c9                   	leave  
+  100e08:	c3                   	ret    
+
+00100e09 <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+  100e09:	55                   	push   %ebp
+  100e0a:	89 e5                	mov    %esp,%ebp
+  100e0c:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+  100e0f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  100e13:	74 05                	je     100e1a <__intr_restore+0x11>
+        intr_enable();
+  100e15:	e8 83 08 00 00       	call   10169d <intr_enable>
+    }
+}
+  100e1a:	c9                   	leave  
+  100e1b:	c3                   	ret    
+
+00100e1c <delay>:
+#include <memlayout.h>
+#include <sync.h>
+
+/* stupid I/O delay routine necessitated by historical PC design flaws */
+static void
+delay(void) {
+  100e1c:	55                   	push   %ebp
+  100e1d:	89 e5                	mov    %esp,%ebp
+  100e1f:	83 ec 10             	sub    $0x10,%esp
+  100e22:	66 c7 45 fe 84 00    	movw   $0x84,-0x2(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  100e28:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+  100e2c:	89 c2                	mov    %eax,%edx
+  100e2e:	ec                   	in     (%dx),%al
+  100e2f:	88 45 fd             	mov    %al,-0x3(%ebp)
+  100e32:	66 c7 45 fa 84 00    	movw   $0x84,-0x6(%ebp)
+  100e38:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+  100e3c:	89 c2                	mov    %eax,%edx
+  100e3e:	ec                   	in     (%dx),%al
+  100e3f:	88 45 f9             	mov    %al,-0x7(%ebp)
+  100e42:	66 c7 45 f6 84 00    	movw   $0x84,-0xa(%ebp)
+  100e48:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  100e4c:	89 c2                	mov    %eax,%edx
+  100e4e:	ec                   	in     (%dx),%al
+  100e4f:	88 45 f5             	mov    %al,-0xb(%ebp)
+  100e52:	66 c7 45 f2 84 00    	movw   $0x84,-0xe(%ebp)
+  100e58:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+  100e5c:	89 c2                	mov    %eax,%edx
+  100e5e:	ec                   	in     (%dx),%al
+  100e5f:	88 45 f1             	mov    %al,-0xf(%ebp)
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+}
+  100e62:	c9                   	leave  
+  100e63:	c3                   	ret    
+
+00100e64 <cga_init>:
+static uint16_t addr_6845;
+
+/* TEXT-mode CGA/VGA display output */
+
+static void
+cga_init(void) {
+  100e64:	55                   	push   %ebp
+  100e65:	89 e5                	mov    %esp,%ebp
+  100e67:	83 ec 20             	sub    $0x20,%esp
+    volatile uint16_t *cp = (uint16_t *)(CGA_BUF + KERNBASE);
+  100e6a:	c7 45 fc 00 80 0b c0 	movl   $0xc00b8000,-0x4(%ebp)
+    uint16_t was = *cp;
+  100e71:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100e74:	0f b7 00             	movzwl (%eax),%eax
+  100e77:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+    *cp = (uint16_t) 0xA55A;
+  100e7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100e7e:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
+    if (*cp != 0xA55A) {
+  100e83:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100e86:	0f b7 00             	movzwl (%eax),%eax
+  100e89:	66 3d 5a a5          	cmp    $0xa55a,%ax
+  100e8d:	74 12                	je     100ea1 <cga_init+0x3d>
+        cp = (uint16_t*)(MONO_BUF + KERNBASE);
+  100e8f:	c7 45 fc 00 00 0b c0 	movl   $0xc00b0000,-0x4(%ebp)
+        addr_6845 = MONO_BASE;
+  100e96:	66 c7 05 86 7e 11 00 	movw   $0x3b4,0x117e86
+  100e9d:	b4 03 
+  100e9f:	eb 13                	jmp    100eb4 <cga_init+0x50>
+    } else {
+        *cp = was;
+  100ea1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100ea4:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  100ea8:	66 89 10             	mov    %dx,(%eax)
+        addr_6845 = CGA_BASE;
+  100eab:	66 c7 05 86 7e 11 00 	movw   $0x3d4,0x117e86
+  100eb2:	d4 03 
+    }
+
+    // Extract cursor location
+    uint32_t pos;
+    outb(addr_6845, 14);
+  100eb4:	0f b7 05 86 7e 11 00 	movzwl 0x117e86,%eax
+  100ebb:	0f b7 c0             	movzwl %ax,%eax
+  100ebe:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+  100ec2:	c6 45 f1 0e          	movb   $0xe,-0xf(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+  100ec6:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  100eca:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100ece:	ee                   	out    %al,(%dx)
+    pos = inb(addr_6845 + 1) << 8;
+  100ecf:	0f b7 05 86 7e 11 00 	movzwl 0x117e86,%eax
+  100ed6:	83 c0 01             	add    $0x1,%eax
+  100ed9:	0f b7 c0             	movzwl %ax,%eax
+  100edc:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  100ee0:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
+  100ee4:	89 c2                	mov    %eax,%edx
+  100ee6:	ec                   	in     (%dx),%al
+  100ee7:	88 45 ed             	mov    %al,-0x13(%ebp)
+    return data;
+  100eea:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100eee:	0f b6 c0             	movzbl %al,%eax
+  100ef1:	c1 e0 08             	shl    $0x8,%eax
+  100ef4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    outb(addr_6845, 15);
+  100ef7:	0f b7 05 86 7e 11 00 	movzwl 0x117e86,%eax
+  100efe:	0f b7 c0             	movzwl %ax,%eax
+  100f01:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+  100f05:	c6 45 e9 0f          	movb   $0xf,-0x17(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+  100f09:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  100f0d:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100f11:	ee                   	out    %al,(%dx)
+    pos |= inb(addr_6845 + 1);
+  100f12:	0f b7 05 86 7e 11 00 	movzwl 0x117e86,%eax
+  100f19:	83 c0 01             	add    $0x1,%eax
+  100f1c:	0f b7 c0             	movzwl %ax,%eax
+  100f1f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  100f23:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
+  100f27:	89 c2                	mov    %eax,%edx
+  100f29:	ec                   	in     (%dx),%al
+  100f2a:	88 45 e5             	mov    %al,-0x1b(%ebp)
+    return data;
+  100f2d:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  100f31:	0f b6 c0             	movzbl %al,%eax
+  100f34:	09 45 f4             	or     %eax,-0xc(%ebp)
+
+    crt_buf = (uint16_t*) cp;
+  100f37:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100f3a:	a3 80 7e 11 00       	mov    %eax,0x117e80
+    crt_pos = pos;
+  100f3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100f42:	66 a3 84 7e 11 00    	mov    %ax,0x117e84
+}
+  100f48:	c9                   	leave  
+  100f49:	c3                   	ret    
+
+00100f4a <serial_init>:
+
+static bool serial_exists = 0;
+
+static void
+serial_init(void) {
+  100f4a:	55                   	push   %ebp
+  100f4b:	89 e5                	mov    %esp,%ebp
+  100f4d:	83 ec 48             	sub    $0x48,%esp
+  100f50:	66 c7 45 f6 fa 03    	movw   $0x3fa,-0xa(%ebp)
+  100f56:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+  100f5a:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  100f5e:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  100f62:	ee                   	out    %al,(%dx)
+  100f63:	66 c7 45 f2 fb 03    	movw   $0x3fb,-0xe(%ebp)
+  100f69:	c6 45 f1 80          	movb   $0x80,-0xf(%ebp)
+  100f6d:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  100f71:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100f75:	ee                   	out    %al,(%dx)
+  100f76:	66 c7 45 ee f8 03    	movw   $0x3f8,-0x12(%ebp)
+  100f7c:	c6 45 ed 0c          	movb   $0xc,-0x13(%ebp)
+  100f80:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100f84:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  100f88:	ee                   	out    %al,(%dx)
+  100f89:	66 c7 45 ea f9 03    	movw   $0x3f9,-0x16(%ebp)
+  100f8f:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
+  100f93:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  100f97:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100f9b:	ee                   	out    %al,(%dx)
+  100f9c:	66 c7 45 e6 fb 03    	movw   $0x3fb,-0x1a(%ebp)
+  100fa2:	c6 45 e5 03          	movb   $0x3,-0x1b(%ebp)
+  100fa6:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  100faa:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  100fae:	ee                   	out    %al,(%dx)
+  100faf:	66 c7 45 e2 fc 03    	movw   $0x3fc,-0x1e(%ebp)
+  100fb5:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
+  100fb9:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+  100fbd:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+  100fc1:	ee                   	out    %al,(%dx)
+  100fc2:	66 c7 45 de f9 03    	movw   $0x3f9,-0x22(%ebp)
+  100fc8:	c6 45 dd 01          	movb   $0x1,-0x23(%ebp)
+  100fcc:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+  100fd0:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+  100fd4:	ee                   	out    %al,(%dx)
+  100fd5:	66 c7 45 da fd 03    	movw   $0x3fd,-0x26(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  100fdb:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
+  100fdf:	89 c2                	mov    %eax,%edx
+  100fe1:	ec                   	in     (%dx),%al
+  100fe2:	88 45 d9             	mov    %al,-0x27(%ebp)
+    return data;
+  100fe5:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+    // Enable rcv interrupts
+    outb(COM1 + COM_IER, COM_IER_RDI);
+
+    // Clear any preexisting overrun indications and interrupts
+    // Serial port doesn't exist if COM_LSR returns 0xFF
+    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
+  100fe9:	3c ff                	cmp    $0xff,%al
+  100feb:	0f 95 c0             	setne  %al
+  100fee:	0f b6 c0             	movzbl %al,%eax
+  100ff1:	a3 88 7e 11 00       	mov    %eax,0x117e88
+  100ff6:	66 c7 45 d6 fa 03    	movw   $0x3fa,-0x2a(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  100ffc:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
+  101000:	89 c2                	mov    %eax,%edx
+  101002:	ec                   	in     (%dx),%al
+  101003:	88 45 d5             	mov    %al,-0x2b(%ebp)
+  101006:	66 c7 45 d2 f8 03    	movw   $0x3f8,-0x2e(%ebp)
+  10100c:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
+  101010:	89 c2                	mov    %eax,%edx
+  101012:	ec                   	in     (%dx),%al
+  101013:	88 45 d1             	mov    %al,-0x2f(%ebp)
+    (void) inb(COM1+COM_IIR);
+    (void) inb(COM1+COM_RX);
+
+    if (serial_exists) {
+  101016:	a1 88 7e 11 00       	mov    0x117e88,%eax
+  10101b:	85 c0                	test   %eax,%eax
+  10101d:	74 0c                	je     10102b <serial_init+0xe1>
+        pic_enable(IRQ_COM1);
+  10101f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+  101026:	e8 d6 06 00 00       	call   101701 <pic_enable>
+    }
+}
+  10102b:	c9                   	leave  
+  10102c:	c3                   	ret    
+
+0010102d <lpt_putc_sub>:
+
+static void
+lpt_putc_sub(int c) {
+  10102d:	55                   	push   %ebp
+  10102e:	89 e5                	mov    %esp,%ebp
+  101030:	83 ec 20             	sub    $0x20,%esp
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+  101033:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  10103a:	eb 09                	jmp    101045 <lpt_putc_sub+0x18>
+        delay();
+  10103c:	e8 db fd ff ff       	call   100e1c <delay>
+}
+
+static void
+lpt_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+  101041:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  101045:	66 c7 45 fa 79 03    	movw   $0x379,-0x6(%ebp)
+  10104b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+  10104f:	89 c2                	mov    %eax,%edx
+  101051:	ec                   	in     (%dx),%al
+  101052:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+  101055:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  101059:	84 c0                	test   %al,%al
+  10105b:	78 09                	js     101066 <lpt_putc_sub+0x39>
+  10105d:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+  101064:	7e d6                	jle    10103c <lpt_putc_sub+0xf>
+        delay();
+    }
+    outb(LPTPORT + 0, c);
+  101066:	8b 45 08             	mov    0x8(%ebp),%eax
+  101069:	0f b6 c0             	movzbl %al,%eax
+  10106c:	66 c7 45 f6 78 03    	movw   $0x378,-0xa(%ebp)
+  101072:	88 45 f5             	mov    %al,-0xb(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+  101075:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  101079:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  10107d:	ee                   	out    %al,(%dx)
+  10107e:	66 c7 45 f2 7a 03    	movw   $0x37a,-0xe(%ebp)
+  101084:	c6 45 f1 0d          	movb   $0xd,-0xf(%ebp)
+  101088:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  10108c:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  101090:	ee                   	out    %al,(%dx)
+  101091:	66 c7 45 ee 7a 03    	movw   $0x37a,-0x12(%ebp)
+  101097:	c6 45 ed 08          	movb   $0x8,-0x13(%ebp)
+  10109b:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  10109f:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  1010a3:	ee                   	out    %al,(%dx)
+    outb(LPTPORT + 2, 0x08 | 0x04 | 0x01);
+    outb(LPTPORT + 2, 0x08);
+}
+  1010a4:	c9                   	leave  
+  1010a5:	c3                   	ret    
+
+001010a6 <lpt_putc>:
+
+/* lpt_putc - copy console output to parallel port */
+static void
+lpt_putc(int c) {
+  1010a6:	55                   	push   %ebp
+  1010a7:	89 e5                	mov    %esp,%ebp
+  1010a9:	83 ec 04             	sub    $0x4,%esp
+    if (c != '\b') {
+  1010ac:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+  1010b0:	74 0d                	je     1010bf <lpt_putc+0x19>
+        lpt_putc_sub(c);
+  1010b2:	8b 45 08             	mov    0x8(%ebp),%eax
+  1010b5:	89 04 24             	mov    %eax,(%esp)
+  1010b8:	e8 70 ff ff ff       	call   10102d <lpt_putc_sub>
+  1010bd:	eb 24                	jmp    1010e3 <lpt_putc+0x3d>
+    }
+    else {
+        lpt_putc_sub('\b');
+  1010bf:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  1010c6:	e8 62 ff ff ff       	call   10102d <lpt_putc_sub>
+        lpt_putc_sub(' ');
+  1010cb:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  1010d2:	e8 56 ff ff ff       	call   10102d <lpt_putc_sub>
+        lpt_putc_sub('\b');
+  1010d7:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  1010de:	e8 4a ff ff ff       	call   10102d <lpt_putc_sub>
+    }
+}
+  1010e3:	c9                   	leave  
+  1010e4:	c3                   	ret    
+
+001010e5 <cga_putc>:
+
+/* cga_putc - print character to console */
+static void
+cga_putc(int c) {
+  1010e5:	55                   	push   %ebp
+  1010e6:	89 e5                	mov    %esp,%ebp
+  1010e8:	53                   	push   %ebx
+  1010e9:	83 ec 34             	sub    $0x34,%esp
+    // set black on white
+    if (!(c & ~0xFF)) {
+  1010ec:	8b 45 08             	mov    0x8(%ebp),%eax
+  1010ef:	b0 00                	mov    $0x0,%al
+  1010f1:	85 c0                	test   %eax,%eax
+  1010f3:	75 07                	jne    1010fc <cga_putc+0x17>
+        c |= 0x0700;
+  1010f5:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)
+    }
+
+    switch (c & 0xff) {
+  1010fc:	8b 45 08             	mov    0x8(%ebp),%eax
+  1010ff:	0f b6 c0             	movzbl %al,%eax
+  101102:	83 f8 0a             	cmp    $0xa,%eax
+  101105:	74 4c                	je     101153 <cga_putc+0x6e>
+  101107:	83 f8 0d             	cmp    $0xd,%eax
+  10110a:	74 57                	je     101163 <cga_putc+0x7e>
+  10110c:	83 f8 08             	cmp    $0x8,%eax
+  10110f:	0f 85 88 00 00 00    	jne    10119d <cga_putc+0xb8>
+    case '\b':
+        if (crt_pos > 0) {
+  101115:	0f b7 05 84 7e 11 00 	movzwl 0x117e84,%eax
+  10111c:	66 85 c0             	test   %ax,%ax
+  10111f:	74 30                	je     101151 <cga_putc+0x6c>
+            crt_pos --;
+  101121:	0f b7 05 84 7e 11 00 	movzwl 0x117e84,%eax
+  101128:	83 e8 01             	sub    $0x1,%eax
+  10112b:	66 a3 84 7e 11 00    	mov    %ax,0x117e84
+            crt_buf[crt_pos] = (c & ~0xff) | ' ';
+  101131:	a1 80 7e 11 00       	mov    0x117e80,%eax
+  101136:	0f b7 15 84 7e 11 00 	movzwl 0x117e84,%edx
+  10113d:	0f b7 d2             	movzwl %dx,%edx
+  101140:	01 d2                	add    %edx,%edx
+  101142:	01 c2                	add    %eax,%edx
+  101144:	8b 45 08             	mov    0x8(%ebp),%eax
+  101147:	b0 00                	mov    $0x0,%al
+  101149:	83 c8 20             	or     $0x20,%eax
+  10114c:	66 89 02             	mov    %ax,(%edx)
+        }
+        break;
+  10114f:	eb 72                	jmp    1011c3 <cga_putc+0xde>
+  101151:	eb 70                	jmp    1011c3 <cga_putc+0xde>
+    case '\n':
+        crt_pos += CRT_COLS;
+  101153:	0f b7 05 84 7e 11 00 	movzwl 0x117e84,%eax
+  10115a:	83 c0 50             	add    $0x50,%eax
+  10115d:	66 a3 84 7e 11 00    	mov    %ax,0x117e84
+    case '\r':
+        crt_pos -= (crt_pos % CRT_COLS);
+  101163:	0f b7 1d 84 7e 11 00 	movzwl 0x117e84,%ebx
+  10116a:	0f b7 0d 84 7e 11 00 	movzwl 0x117e84,%ecx
+  101171:	0f b7 c1             	movzwl %cx,%eax
+  101174:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
+  10117a:	c1 e8 10             	shr    $0x10,%eax
+  10117d:	89 c2                	mov    %eax,%edx
+  10117f:	66 c1 ea 06          	shr    $0x6,%dx
+  101183:	89 d0                	mov    %edx,%eax
+  101185:	c1 e0 02             	shl    $0x2,%eax
+  101188:	01 d0                	add    %edx,%eax
+  10118a:	c1 e0 04             	shl    $0x4,%eax
+  10118d:	29 c1                	sub    %eax,%ecx
+  10118f:	89 ca                	mov    %ecx,%edx
+  101191:	89 d8                	mov    %ebx,%eax
+  101193:	29 d0                	sub    %edx,%eax
+  101195:	66 a3 84 7e 11 00    	mov    %ax,0x117e84
+        break;
+  10119b:	eb 26                	jmp    1011c3 <cga_putc+0xde>
+    default:
+        crt_buf[crt_pos ++] = c;     // write the character
+  10119d:	8b 0d 80 7e 11 00    	mov    0x117e80,%ecx
+  1011a3:	0f b7 05 84 7e 11 00 	movzwl 0x117e84,%eax
+  1011aa:	8d 50 01             	lea    0x1(%eax),%edx
+  1011ad:	66 89 15 84 7e 11 00 	mov    %dx,0x117e84
+  1011b4:	0f b7 c0             	movzwl %ax,%eax
+  1011b7:	01 c0                	add    %eax,%eax
+  1011b9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
+  1011bc:	8b 45 08             	mov    0x8(%ebp),%eax
+  1011bf:	66 89 02             	mov    %ax,(%edx)
+        break;
+  1011c2:	90                   	nop
+    }
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+  1011c3:	0f b7 05 84 7e 11 00 	movzwl 0x117e84,%eax
+  1011ca:	66 3d cf 07          	cmp    $0x7cf,%ax
+  1011ce:	76 5b                	jbe    10122b <cga_putc+0x146>
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+  1011d0:	a1 80 7e 11 00       	mov    0x117e80,%eax
+  1011d5:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+  1011db:	a1 80 7e 11 00       	mov    0x117e80,%eax
+  1011e0:	c7 44 24 08 00 0f 00 	movl   $0xf00,0x8(%esp)
+  1011e7:	00 
+  1011e8:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1011ec:	89 04 24             	mov    %eax,(%esp)
+  1011ef:	e8 11 4d 00 00       	call   105f05 <memmove>
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+  1011f4:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
+  1011fb:	eb 15                	jmp    101212 <cga_putc+0x12d>
+            crt_buf[i] = 0x0700 | ' ';
+  1011fd:	a1 80 7e 11 00       	mov    0x117e80,%eax
+  101202:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  101205:	01 d2                	add    %edx,%edx
+  101207:	01 d0                	add    %edx,%eax
+  101209:	66 c7 00 20 07       	movw   $0x720,(%eax)
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+  10120e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  101212:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
+  101219:	7e e2                	jle    1011fd <cga_putc+0x118>
+            crt_buf[i] = 0x0700 | ' ';
+        }
+        crt_pos -= CRT_COLS;
+  10121b:	0f b7 05 84 7e 11 00 	movzwl 0x117e84,%eax
+  101222:	83 e8 50             	sub    $0x50,%eax
+  101225:	66 a3 84 7e 11 00    	mov    %ax,0x117e84
+    }
+
+    // move that little blinky thing
+    outb(addr_6845, 14);
+  10122b:	0f b7 05 86 7e 11 00 	movzwl 0x117e86,%eax
+  101232:	0f b7 c0             	movzwl %ax,%eax
+  101235:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+  101239:	c6 45 f1 0e          	movb   $0xe,-0xf(%ebp)
+  10123d:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  101241:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  101245:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos >> 8);
+  101246:	0f b7 05 84 7e 11 00 	movzwl 0x117e84,%eax
+  10124d:	66 c1 e8 08          	shr    $0x8,%ax
+  101251:	0f b6 c0             	movzbl %al,%eax
+  101254:	0f b7 15 86 7e 11 00 	movzwl 0x117e86,%edx
+  10125b:	83 c2 01             	add    $0x1,%edx
+  10125e:	0f b7 d2             	movzwl %dx,%edx
+  101261:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
+  101265:	88 45 ed             	mov    %al,-0x13(%ebp)
+  101268:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  10126c:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  101270:	ee                   	out    %al,(%dx)
+    outb(addr_6845, 15);
+  101271:	0f b7 05 86 7e 11 00 	movzwl 0x117e86,%eax
+  101278:	0f b7 c0             	movzwl %ax,%eax
+  10127b:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+  10127f:	c6 45 e9 0f          	movb   $0xf,-0x17(%ebp)
+  101283:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  101287:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  10128b:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos);
+  10128c:	0f b7 05 84 7e 11 00 	movzwl 0x117e84,%eax
+  101293:	0f b6 c0             	movzbl %al,%eax
+  101296:	0f b7 15 86 7e 11 00 	movzwl 0x117e86,%edx
+  10129d:	83 c2 01             	add    $0x1,%edx
+  1012a0:	0f b7 d2             	movzwl %dx,%edx
+  1012a3:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
+  1012a7:	88 45 e5             	mov    %al,-0x1b(%ebp)
+  1012aa:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  1012ae:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  1012b2:	ee                   	out    %al,(%dx)
+}
+  1012b3:	83 c4 34             	add    $0x34,%esp
+  1012b6:	5b                   	pop    %ebx
+  1012b7:	5d                   	pop    %ebp
+  1012b8:	c3                   	ret    
+
+001012b9 <serial_putc_sub>:
+
+static void
+serial_putc_sub(int c) {
+  1012b9:	55                   	push   %ebp
+  1012ba:	89 e5                	mov    %esp,%ebp
+  1012bc:	83 ec 10             	sub    $0x10,%esp
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+  1012bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  1012c6:	eb 09                	jmp    1012d1 <serial_putc_sub+0x18>
+        delay();
+  1012c8:	e8 4f fb ff ff       	call   100e1c <delay>
+}
+
+static void
+serial_putc_sub(int c) {
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+  1012cd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  1012d1:	66 c7 45 fa fd 03    	movw   $0x3fd,-0x6(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  1012d7:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+  1012db:	89 c2                	mov    %eax,%edx
+  1012dd:	ec                   	in     (%dx),%al
+  1012de:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+  1012e1:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  1012e5:	0f b6 c0             	movzbl %al,%eax
+  1012e8:	83 e0 20             	and    $0x20,%eax
+  1012eb:	85 c0                	test   %eax,%eax
+  1012ed:	75 09                	jne    1012f8 <serial_putc_sub+0x3f>
+  1012ef:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+  1012f6:	7e d0                	jle    1012c8 <serial_putc_sub+0xf>
+        delay();
+    }
+    outb(COM1 + COM_TX, c);
+  1012f8:	8b 45 08             	mov    0x8(%ebp),%eax
+  1012fb:	0f b6 c0             	movzbl %al,%eax
+  1012fe:	66 c7 45 f6 f8 03    	movw   $0x3f8,-0xa(%ebp)
+  101304:	88 45 f5             	mov    %al,-0xb(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+  101307:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  10130b:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  10130f:	ee                   	out    %al,(%dx)
+}
+  101310:	c9                   	leave  
+  101311:	c3                   	ret    
+
+00101312 <serial_putc>:
+
+/* serial_putc - print character to serial port */
+static void
+serial_putc(int c) {
+  101312:	55                   	push   %ebp
+  101313:	89 e5                	mov    %esp,%ebp
+  101315:	83 ec 04             	sub    $0x4,%esp
+    if (c != '\b') {
+  101318:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+  10131c:	74 0d                	je     10132b <serial_putc+0x19>
+        serial_putc_sub(c);
+  10131e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101321:	89 04 24             	mov    %eax,(%esp)
+  101324:	e8 90 ff ff ff       	call   1012b9 <serial_putc_sub>
+  101329:	eb 24                	jmp    10134f <serial_putc+0x3d>
+    }
+    else {
+        serial_putc_sub('\b');
+  10132b:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  101332:	e8 82 ff ff ff       	call   1012b9 <serial_putc_sub>
+        serial_putc_sub(' ');
+  101337:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  10133e:	e8 76 ff ff ff       	call   1012b9 <serial_putc_sub>
+        serial_putc_sub('\b');
+  101343:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  10134a:	e8 6a ff ff ff       	call   1012b9 <serial_putc_sub>
+    }
+}
+  10134f:	c9                   	leave  
+  101350:	c3                   	ret    
+
+00101351 <cons_intr>:
+/* *
+ * cons_intr - called by device interrupt routines to feed input
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+  101351:	55                   	push   %ebp
+  101352:	89 e5                	mov    %esp,%ebp
+  101354:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = (*proc)()) != -1) {
+  101357:	eb 33                	jmp    10138c <cons_intr+0x3b>
+        if (c != 0) {
+  101359:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  10135d:	74 2d                	je     10138c <cons_intr+0x3b>
+            cons.buf[cons.wpos ++] = c;
+  10135f:	a1 a4 80 11 00       	mov    0x1180a4,%eax
+  101364:	8d 50 01             	lea    0x1(%eax),%edx
+  101367:	89 15 a4 80 11 00    	mov    %edx,0x1180a4
+  10136d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  101370:	88 90 a0 7e 11 00    	mov    %dl,0x117ea0(%eax)
+            if (cons.wpos == CONSBUFSIZE) {
+  101376:	a1 a4 80 11 00       	mov    0x1180a4,%eax
+  10137b:	3d 00 02 00 00       	cmp    $0x200,%eax
+  101380:	75 0a                	jne    10138c <cons_intr+0x3b>
+                cons.wpos = 0;
+  101382:	c7 05 a4 80 11 00 00 	movl   $0x0,0x1180a4
+  101389:	00 00 00 
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+    int c;
+    while ((c = (*proc)()) != -1) {
+  10138c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10138f:	ff d0                	call   *%eax
+  101391:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  101394:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+  101398:	75 bf                	jne    101359 <cons_intr+0x8>
+            if (cons.wpos == CONSBUFSIZE) {
+                cons.wpos = 0;
+            }
+        }
+    }
+}
+  10139a:	c9                   	leave  
+  10139b:	c3                   	ret    
+
+0010139c <serial_proc_data>:
+
+/* serial_proc_data - get data from serial port */
+static int
+serial_proc_data(void) {
+  10139c:	55                   	push   %ebp
+  10139d:	89 e5                	mov    %esp,%ebp
+  10139f:	83 ec 10             	sub    $0x10,%esp
+  1013a2:	66 c7 45 fa fd 03    	movw   $0x3fd,-0x6(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  1013a8:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+  1013ac:	89 c2                	mov    %eax,%edx
+  1013ae:	ec                   	in     (%dx),%al
+  1013af:	88 45 f9             	mov    %al,-0x7(%ebp)
+    return data;
+  1013b2:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {
+  1013b6:	0f b6 c0             	movzbl %al,%eax
+  1013b9:	83 e0 01             	and    $0x1,%eax
+  1013bc:	85 c0                	test   %eax,%eax
+  1013be:	75 07                	jne    1013c7 <serial_proc_data+0x2b>
+        return -1;
+  1013c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  1013c5:	eb 2a                	jmp    1013f1 <serial_proc_data+0x55>
+  1013c7:	66 c7 45 f6 f8 03    	movw   $0x3f8,-0xa(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  1013cd:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  1013d1:	89 c2                	mov    %eax,%edx
+  1013d3:	ec                   	in     (%dx),%al
+  1013d4:	88 45 f5             	mov    %al,-0xb(%ebp)
+    return data;
+  1013d7:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+    }
+    int c = inb(COM1 + COM_RX);
+  1013db:	0f b6 c0             	movzbl %al,%eax
+  1013de:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    if (c == 127) {
+  1013e1:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
+  1013e5:	75 07                	jne    1013ee <serial_proc_data+0x52>
+        c = '\b';
+  1013e7:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
+    }
+    return c;
+  1013ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  1013f1:	c9                   	leave  
+  1013f2:	c3                   	ret    
+
+001013f3 <serial_intr>:
+
+/* serial_intr - try to feed input characters from serial port */
+void
+serial_intr(void) {
+  1013f3:	55                   	push   %ebp
+  1013f4:	89 e5                	mov    %esp,%ebp
+  1013f6:	83 ec 18             	sub    $0x18,%esp
+    if (serial_exists) {
+  1013f9:	a1 88 7e 11 00       	mov    0x117e88,%eax
+  1013fe:	85 c0                	test   %eax,%eax
+  101400:	74 0c                	je     10140e <serial_intr+0x1b>
+        cons_intr(serial_proc_data);
+  101402:	c7 04 24 9c 13 10 00 	movl   $0x10139c,(%esp)
+  101409:	e8 43 ff ff ff       	call   101351 <cons_intr>
+    }
+}
+  10140e:	c9                   	leave  
+  10140f:	c3                   	ret    
+
+00101410 <kbd_proc_data>:
+ *
+ * The kbd_proc_data() function gets data from the keyboard.
+ * If we finish a character, return it, else 0. And return -1 if no data.
+ * */
+static int
+kbd_proc_data(void) {
+  101410:	55                   	push   %ebp
+  101411:	89 e5                	mov    %esp,%ebp
+  101413:	83 ec 38             	sub    $0x38,%esp
+  101416:	66 c7 45 f0 64 00    	movw   $0x64,-0x10(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  10141c:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+  101420:	89 c2                	mov    %eax,%edx
+  101422:	ec                   	in     (%dx),%al
+  101423:	88 45 ef             	mov    %al,-0x11(%ebp)
+    return data;
+  101426:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    int c;
+    uint8_t data;
+    static uint32_t shift;
+
+    if ((inb(KBSTATP) & KBS_DIB) == 0) {
+  10142a:	0f b6 c0             	movzbl %al,%eax
+  10142d:	83 e0 01             	and    $0x1,%eax
+  101430:	85 c0                	test   %eax,%eax
+  101432:	75 0a                	jne    10143e <kbd_proc_data+0x2e>
+        return -1;
+  101434:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  101439:	e9 59 01 00 00       	jmp    101597 <kbd_proc_data+0x187>
+  10143e:	66 c7 45 ec 60 00    	movw   $0x60,-0x14(%ebp)
+static inline void invlpg(void *addr) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
+  101444:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  101448:	89 c2                	mov    %eax,%edx
+  10144a:	ec                   	in     (%dx),%al
+  10144b:	88 45 eb             	mov    %al,-0x15(%ebp)
+    return data;
+  10144e:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+    }
+
+    data = inb(KBDATAP);
+  101452:	88 45 f3             	mov    %al,-0xd(%ebp)
+
+    if (data == 0xE0) {
+  101455:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
+  101459:	75 17                	jne    101472 <kbd_proc_data+0x62>
+        // E0 escape character
+        shift |= E0ESC;
+  10145b:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  101460:	83 c8 40             	or     $0x40,%eax
+  101463:	a3 a8 80 11 00       	mov    %eax,0x1180a8
+        return 0;
+  101468:	b8 00 00 00 00       	mov    $0x0,%eax
+  10146d:	e9 25 01 00 00       	jmp    101597 <kbd_proc_data+0x187>
+    } else if (data & 0x80) {
+  101472:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  101476:	84 c0                	test   %al,%al
+  101478:	79 47                	jns    1014c1 <kbd_proc_data+0xb1>
+        // Key released
+        data = (shift & E0ESC ? data : data & 0x7F);
+  10147a:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  10147f:	83 e0 40             	and    $0x40,%eax
+  101482:	85 c0                	test   %eax,%eax
+  101484:	75 09                	jne    10148f <kbd_proc_data+0x7f>
+  101486:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  10148a:	83 e0 7f             	and    $0x7f,%eax
+  10148d:	eb 04                	jmp    101493 <kbd_proc_data+0x83>
+  10148f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  101493:	88 45 f3             	mov    %al,-0xd(%ebp)
+        shift &= ~(shiftcode[data] | E0ESC);
+  101496:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  10149a:	0f b6 80 60 70 11 00 	movzbl 0x117060(%eax),%eax
+  1014a1:	83 c8 40             	or     $0x40,%eax
+  1014a4:	0f b6 c0             	movzbl %al,%eax
+  1014a7:	f7 d0                	not    %eax
+  1014a9:	89 c2                	mov    %eax,%edx
+  1014ab:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  1014b0:	21 d0                	and    %edx,%eax
+  1014b2:	a3 a8 80 11 00       	mov    %eax,0x1180a8
+        return 0;
+  1014b7:	b8 00 00 00 00       	mov    $0x0,%eax
+  1014bc:	e9 d6 00 00 00       	jmp    101597 <kbd_proc_data+0x187>
+    } else if (shift & E0ESC) {
+  1014c1:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  1014c6:	83 e0 40             	and    $0x40,%eax
+  1014c9:	85 c0                	test   %eax,%eax
+  1014cb:	74 11                	je     1014de <kbd_proc_data+0xce>
+        // Last character was an E0 escape; or with 0x80
+        data |= 0x80;
+  1014cd:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
+        shift &= ~E0ESC;
+  1014d1:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  1014d6:	83 e0 bf             	and    $0xffffffbf,%eax
+  1014d9:	a3 a8 80 11 00       	mov    %eax,0x1180a8
+    }
+
+    shift |= shiftcode[data];
+  1014de:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014e2:	0f b6 80 60 70 11 00 	movzbl 0x117060(%eax),%eax
+  1014e9:	0f b6 d0             	movzbl %al,%edx
+  1014ec:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  1014f1:	09 d0                	or     %edx,%eax
+  1014f3:	a3 a8 80 11 00       	mov    %eax,0x1180a8
+    shift ^= togglecode[data];
+  1014f8:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014fc:	0f b6 80 60 71 11 00 	movzbl 0x117160(%eax),%eax
+  101503:	0f b6 d0             	movzbl %al,%edx
+  101506:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  10150b:	31 d0                	xor    %edx,%eax
+  10150d:	a3 a8 80 11 00       	mov    %eax,0x1180a8
+
+    c = charcode[shift & (CTL | SHIFT)][data];
+  101512:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  101517:	83 e0 03             	and    $0x3,%eax
+  10151a:	8b 14 85 60 75 11 00 	mov    0x117560(,%eax,4),%edx
+  101521:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  101525:	01 d0                	add    %edx,%eax
+  101527:	0f b6 00             	movzbl (%eax),%eax
+  10152a:	0f b6 c0             	movzbl %al,%eax
+  10152d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (shift & CAPSLOCK) {
+  101530:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  101535:	83 e0 08             	and    $0x8,%eax
+  101538:	85 c0                	test   %eax,%eax
+  10153a:	74 22                	je     10155e <kbd_proc_data+0x14e>
+        if ('a' <= c && c <= 'z')
+  10153c:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
+  101540:	7e 0c                	jle    10154e <kbd_proc_data+0x13e>
+  101542:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
+  101546:	7f 06                	jg     10154e <kbd_proc_data+0x13e>
+            c += 'A' - 'a';
+  101548:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
+  10154c:	eb 10                	jmp    10155e <kbd_proc_data+0x14e>
+        else if ('A' <= c && c <= 'Z')
+  10154e:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
+  101552:	7e 0a                	jle    10155e <kbd_proc_data+0x14e>
+  101554:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
+  101558:	7f 04                	jg     10155e <kbd_proc_data+0x14e>
+            c += 'a' - 'A';
+  10155a:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+    }
+
+    // Process special keys
+    // Ctrl-Alt-Del: reboot
+    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+  10155e:	a1 a8 80 11 00       	mov    0x1180a8,%eax
+  101563:	f7 d0                	not    %eax
+  101565:	83 e0 06             	and    $0x6,%eax
+  101568:	85 c0                	test   %eax,%eax
+  10156a:	75 28                	jne    101594 <kbd_proc_data+0x184>
+  10156c:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
+  101573:	75 1f                	jne    101594 <kbd_proc_data+0x184>
+        cprintf("Rebooting!\n");
+  101575:	c7 04 24 7d 63 10 00 	movl   $0x10637d,(%esp)
+  10157c:	e8 bb ed ff ff       	call   10033c <cprintf>
+  101581:	66 c7 45 e8 92 00    	movw   $0x92,-0x18(%ebp)
+  101587:	c6 45 e7 03          	movb   $0x3,-0x19(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+  10158b:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  10158f:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+  101593:	ee                   	out    %al,(%dx)
+        outb(0x92, 0x3); // courtesy of Chris Frost
+    }
+    return c;
+  101594:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  101597:	c9                   	leave  
+  101598:	c3                   	ret    
+
+00101599 <kbd_intr>:
+
+/* kbd_intr - try to feed input characters from keyboard */
+static void
+kbd_intr(void) {
+  101599:	55                   	push   %ebp
+  10159a:	89 e5                	mov    %esp,%ebp
+  10159c:	83 ec 18             	sub    $0x18,%esp
+    cons_intr(kbd_proc_data);
+  10159f:	c7 04 24 10 14 10 00 	movl   $0x101410,(%esp)
+  1015a6:	e8 a6 fd ff ff       	call   101351 <cons_intr>
+}
+  1015ab:	c9                   	leave  
+  1015ac:	c3                   	ret    
+
+001015ad <kbd_init>:
+
+static void
+kbd_init(void) {
+  1015ad:	55                   	push   %ebp
+  1015ae:	89 e5                	mov    %esp,%ebp
+  1015b0:	83 ec 18             	sub    $0x18,%esp
+    // drain the kbd buffer
+    kbd_intr();
+  1015b3:	e8 e1 ff ff ff       	call   101599 <kbd_intr>
+    pic_enable(IRQ_KBD);
+  1015b8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1015bf:	e8 3d 01 00 00       	call   101701 <pic_enable>
+}
+  1015c4:	c9                   	leave  
+  1015c5:	c3                   	ret    
+
+001015c6 <cons_init>:
+
+/* cons_init - initializes the console devices */
+void
+cons_init(void) {
+  1015c6:	55                   	push   %ebp
+  1015c7:	89 e5                	mov    %esp,%ebp
+  1015c9:	83 ec 18             	sub    $0x18,%esp
+    cga_init();
+  1015cc:	e8 93 f8 ff ff       	call   100e64 <cga_init>
+    serial_init();
+  1015d1:	e8 74 f9 ff ff       	call   100f4a <serial_init>
+    kbd_init();
+  1015d6:	e8 d2 ff ff ff       	call   1015ad <kbd_init>
+    if (!serial_exists) {
+  1015db:	a1 88 7e 11 00       	mov    0x117e88,%eax
+  1015e0:	85 c0                	test   %eax,%eax
+  1015e2:	75 0c                	jne    1015f0 <cons_init+0x2a>
+        cprintf("serial port does not exist!!\n");
+  1015e4:	c7 04 24 89 63 10 00 	movl   $0x106389,(%esp)
+  1015eb:	e8 4c ed ff ff       	call   10033c <cprintf>
+    }
+}
+  1015f0:	c9                   	leave  
+  1015f1:	c3                   	ret    
+
+001015f2 <cons_putc>:
+
+/* cons_putc - print a single character @c to console devices */
+void
+cons_putc(int c) {
+  1015f2:	55                   	push   %ebp
+  1015f3:	89 e5                	mov    %esp,%ebp
+  1015f5:	83 ec 28             	sub    $0x28,%esp
+    bool intr_flag;
+    local_intr_save(intr_flag);
+  1015f8:	e8 e2 f7 ff ff       	call   100ddf <__intr_save>
+  1015fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        lpt_putc(c);
+  101600:	8b 45 08             	mov    0x8(%ebp),%eax
+  101603:	89 04 24             	mov    %eax,(%esp)
+  101606:	e8 9b fa ff ff       	call   1010a6 <lpt_putc>
+        cga_putc(c);
+  10160b:	8b 45 08             	mov    0x8(%ebp),%eax
+  10160e:	89 04 24             	mov    %eax,(%esp)
+  101611:	e8 cf fa ff ff       	call   1010e5 <cga_putc>
+        serial_putc(c);
+  101616:	8b 45 08             	mov    0x8(%ebp),%eax
+  101619:	89 04 24             	mov    %eax,(%esp)
+  10161c:	e8 f1 fc ff ff       	call   101312 <serial_putc>
+    }
+    local_intr_restore(intr_flag);
+  101621:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101624:	89 04 24             	mov    %eax,(%esp)
+  101627:	e8 dd f7 ff ff       	call   100e09 <__intr_restore>
+}
+  10162c:	c9                   	leave  
+  10162d:	c3                   	ret    
+
+0010162e <cons_getc>:
+/* *
+ * cons_getc - return the next input character from console,
+ * or 0 if none waiting.
+ * */
+int
+cons_getc(void) {
+  10162e:	55                   	push   %ebp
+  10162f:	89 e5                	mov    %esp,%ebp
+  101631:	83 ec 28             	sub    $0x28,%esp
+    int c = 0;
+  101634:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    bool intr_flag;
+    local_intr_save(intr_flag);
+  10163b:	e8 9f f7 ff ff       	call   100ddf <__intr_save>
+  101640:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    {
+        // poll for any pending input characters,
+        // so that this function works even when interrupts are disabled
+        // (e.g., when called from the kernel monitor).
+        serial_intr();
+  101643:	e8 ab fd ff ff       	call   1013f3 <serial_intr>
+        kbd_intr();
+  101648:	e8 4c ff ff ff       	call   101599 <kbd_intr>
+
+        // grab the next character from the input buffer.
+        if (cons.rpos != cons.wpos) {
+  10164d:	8b 15 a0 80 11 00    	mov    0x1180a0,%edx
+  101653:	a1 a4 80 11 00       	mov    0x1180a4,%eax
+  101658:	39 c2                	cmp    %eax,%edx
+  10165a:	74 31                	je     10168d <cons_getc+0x5f>
+            c = cons.buf[cons.rpos ++];
+  10165c:	a1 a0 80 11 00       	mov    0x1180a0,%eax
+  101661:	8d 50 01             	lea    0x1(%eax),%edx
+  101664:	89 15 a0 80 11 00    	mov    %edx,0x1180a0
+  10166a:	0f b6 80 a0 7e 11 00 	movzbl 0x117ea0(%eax),%eax
+  101671:	0f b6 c0             	movzbl %al,%eax
+  101674:	89 45 f4             	mov    %eax,-0xc(%ebp)
+            if (cons.rpos == CONSBUFSIZE) {
+  101677:	a1 a0 80 11 00       	mov    0x1180a0,%eax
+  10167c:	3d 00 02 00 00       	cmp    $0x200,%eax
+  101681:	75 0a                	jne    10168d <cons_getc+0x5f>
+                cons.rpos = 0;
+  101683:	c7 05 a0 80 11 00 00 	movl   $0x0,0x1180a0
+  10168a:	00 00 00 
+            }
+        }
+    }
+    local_intr_restore(intr_flag);
+  10168d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  101690:	89 04 24             	mov    %eax,(%esp)
+  101693:	e8 71 f7 ff ff       	call   100e09 <__intr_restore>
+    return c;
+  101698:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  10169b:	c9                   	leave  
+  10169c:	c3                   	ret    
+
+0010169d <intr_enable>:
+#include <x86.h>
+#include <intr.h>
+
+/* intr_enable - enable irq interrupt */
+void
+intr_enable(void) {
+  10169d:	55                   	push   %ebp
+  10169e:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+}
+
+static inline void
+sti(void) {
+    asm volatile ("sti");
+  1016a0:	fb                   	sti    
+    sti();
+}
+  1016a1:	5d                   	pop    %ebp
+  1016a2:	c3                   	ret    
+
+001016a3 <intr_disable>:
+
+/* intr_disable - disable irq interrupt */
+void
+intr_disable(void) {
+  1016a3:	55                   	push   %ebp
+  1016a4:	89 e5                	mov    %esp,%ebp
+}
+
+static inline void
+cli(void) {
+    asm volatile ("cli" ::: "memory");
+  1016a6:	fa                   	cli    
+    cli();
+}
+  1016a7:	5d                   	pop    %ebp
+  1016a8:	c3                   	ret    
+
+001016a9 <pic_setmask>:
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static uint16_t irq_mask = 0xFFFF & ~(1 << IRQ_SLAVE);
+static bool did_init = 0;
+
+static void
+pic_setmask(uint16_t mask) {
+  1016a9:	55                   	push   %ebp
+  1016aa:	89 e5                	mov    %esp,%ebp
+  1016ac:	83 ec 14             	sub    $0x14,%esp
+  1016af:	8b 45 08             	mov    0x8(%ebp),%eax
+  1016b2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+    irq_mask = mask;
+  1016b6:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  1016ba:	66 a3 70 75 11 00    	mov    %ax,0x117570
+    if (did_init) {
+  1016c0:	a1 ac 80 11 00       	mov    0x1180ac,%eax
+  1016c5:	85 c0                	test   %eax,%eax
+  1016c7:	74 36                	je     1016ff <pic_setmask+0x56>
+        outb(IO_PIC1 + 1, mask);
+  1016c9:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  1016cd:	0f b6 c0             	movzbl %al,%eax
+  1016d0:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+  1016d6:	88 45 fd             	mov    %al,-0x3(%ebp)
+        : "memory", "cc");
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
+  1016d9:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
+  1016dd:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+  1016e1:	ee                   	out    %al,(%dx)
+        outb(IO_PIC2 + 1, mask >> 8);
+  1016e2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  1016e6:	66 c1 e8 08          	shr    $0x8,%ax
+  1016ea:	0f b6 c0             	movzbl %al,%eax
+  1016ed:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
+  1016f3:	88 45 f9             	mov    %al,-0x7(%ebp)
+  1016f6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  1016fa:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  1016fe:	ee                   	out    %al,(%dx)
+    }
+}
+  1016ff:	c9                   	leave  
+  101700:	c3                   	ret    
+
+00101701 <pic_enable>:
+
+void
+pic_enable(unsigned int irq) {
+  101701:	55                   	push   %ebp
+  101702:	89 e5                	mov    %esp,%ebp
+  101704:	83 ec 04             	sub    $0x4,%esp
+    pic_setmask(irq_mask & ~(1 << irq));
+  101707:	8b 45 08             	mov    0x8(%ebp),%eax
+  10170a:	ba 01 00 00 00       	mov    $0x1,%edx
+  10170f:	89 c1                	mov    %eax,%ecx
+  101711:	d3 e2                	shl    %cl,%edx
+  101713:	89 d0                	mov    %edx,%eax
+  101715:	f7 d0                	not    %eax
+  101717:	89 c2                	mov    %eax,%edx
+  101719:	0f b7 05 70 75 11 00 	movzwl 0x117570,%eax
+  101720:	21 d0                	and    %edx,%eax
+  101722:	0f b7 c0             	movzwl %ax,%eax
+  101725:	89 04 24             	mov    %eax,(%esp)
+  101728:	e8 7c ff ff ff       	call   1016a9 <pic_setmask>
+}
+  10172d:	c9                   	leave  
+  10172e:	c3                   	ret    
+
+0010172f <pic_init>:
+
+/* pic_init - initialize the 8259A interrupt controllers */
+void
+pic_init(void) {
+  10172f:	55                   	push   %ebp
+  101730:	89 e5                	mov    %esp,%ebp
+  101732:	83 ec 44             	sub    $0x44,%esp
+    did_init = 1;
+  101735:	c7 05 ac 80 11 00 01 	movl   $0x1,0x1180ac
+  10173c:	00 00 00 
+  10173f:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+  101745:	c6 45 fd ff          	movb   $0xff,-0x3(%ebp)
+  101749:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
+  10174d:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+  101751:	ee                   	out    %al,(%dx)
+  101752:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
+  101758:	c6 45 f9 ff          	movb   $0xff,-0x7(%ebp)
+  10175c:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  101760:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  101764:	ee                   	out    %al,(%dx)
+  101765:	66 c7 45 f6 20 00    	movw   $0x20,-0xa(%ebp)
+  10176b:	c6 45 f5 11          	movb   $0x11,-0xb(%ebp)
+  10176f:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  101773:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  101777:	ee                   	out    %al,(%dx)
+  101778:	66 c7 45 f2 21 00    	movw   $0x21,-0xe(%ebp)
+  10177e:	c6 45 f1 20          	movb   $0x20,-0xf(%ebp)
+  101782:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  101786:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  10178a:	ee                   	out    %al,(%dx)
+  10178b:	66 c7 45 ee 21 00    	movw   $0x21,-0x12(%ebp)
+  101791:	c6 45 ed 04          	movb   $0x4,-0x13(%ebp)
+  101795:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  101799:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  10179d:	ee                   	out    %al,(%dx)
+  10179e:	66 c7 45 ea 21 00    	movw   $0x21,-0x16(%ebp)
+  1017a4:	c6 45 e9 03          	movb   $0x3,-0x17(%ebp)
+  1017a8:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  1017ac:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  1017b0:	ee                   	out    %al,(%dx)
+  1017b1:	66 c7 45 e6 a0 00    	movw   $0xa0,-0x1a(%ebp)
+  1017b7:	c6 45 e5 11          	movb   $0x11,-0x1b(%ebp)
+  1017bb:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  1017bf:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  1017c3:	ee                   	out    %al,(%dx)
+  1017c4:	66 c7 45 e2 a1 00    	movw   $0xa1,-0x1e(%ebp)
+  1017ca:	c6 45 e1 28          	movb   $0x28,-0x1f(%ebp)
+  1017ce:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+  1017d2:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+  1017d6:	ee                   	out    %al,(%dx)
+  1017d7:	66 c7 45 de a1 00    	movw   $0xa1,-0x22(%ebp)
+  1017dd:	c6 45 dd 02          	movb   $0x2,-0x23(%ebp)
+  1017e1:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+  1017e5:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+  1017e9:	ee                   	out    %al,(%dx)
+  1017ea:	66 c7 45 da a1 00    	movw   $0xa1,-0x26(%ebp)
+  1017f0:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
+  1017f4:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+  1017f8:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
+  1017fc:	ee                   	out    %al,(%dx)
+  1017fd:	66 c7 45 d6 20 00    	movw   $0x20,-0x2a(%ebp)
+  101803:	c6 45 d5 68          	movb   $0x68,-0x2b(%ebp)
+  101807:	0f b6 45 d5          	movzbl -0x2b(%ebp),%eax
+  10180b:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
+  10180f:	ee                   	out    %al,(%dx)
+  101810:	66 c7 45 d2 20 00    	movw   $0x20,-0x2e(%ebp)
+  101816:	c6 45 d1 0a          	movb   $0xa,-0x2f(%ebp)
+  10181a:	0f b6 45 d1          	movzbl -0x2f(%ebp),%eax
+  10181e:	0f b7 55 d2          	movzwl -0x2e(%ebp),%edx
+  101822:	ee                   	out    %al,(%dx)
+  101823:	66 c7 45 ce a0 00    	movw   $0xa0,-0x32(%ebp)
+  101829:	c6 45 cd 68          	movb   $0x68,-0x33(%ebp)
+  10182d:	0f b6 45 cd          	movzbl -0x33(%ebp),%eax
+  101831:	0f b7 55 ce          	movzwl -0x32(%ebp),%edx
+  101835:	ee                   	out    %al,(%dx)
+  101836:	66 c7 45 ca a0 00    	movw   $0xa0,-0x36(%ebp)
+  10183c:	c6 45 c9 0a          	movb   $0xa,-0x37(%ebp)
+  101840:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
+  101844:	0f b7 55 ca          	movzwl -0x36(%ebp),%edx
+  101848:	ee                   	out    %al,(%dx)
+    outb(IO_PIC1, 0x0a);    // read IRR by default
+
+    outb(IO_PIC2, 0x68);    // OCW3
+    outb(IO_PIC2, 0x0a);    // OCW3
+
+    if (irq_mask != 0xFFFF) {
+  101849:	0f b7 05 70 75 11 00 	movzwl 0x117570,%eax
+  101850:	66 83 f8 ff          	cmp    $0xffff,%ax
+  101854:	74 12                	je     101868 <pic_init+0x139>
+        pic_setmask(irq_mask);
+  101856:	0f b7 05 70 75 11 00 	movzwl 0x117570,%eax
+  10185d:	0f b7 c0             	movzwl %ax,%eax
+  101860:	89 04 24             	mov    %eax,(%esp)
+  101863:	e8 41 fe ff ff       	call   1016a9 <pic_setmask>
+    }
+}
+  101868:	c9                   	leave  
+  101869:	c3                   	ret    
+
+0010186a <print_ticks>:
+#include <kdebug.h>
+#include <string.h>
+
+#define TICK_NUM 100
+
+static void print_ticks() {
+  10186a:	55                   	push   %ebp
+  10186b:	89 e5                	mov    %esp,%ebp
+  10186d:	83 ec 18             	sub    $0x18,%esp
+    cprintf("%d ticks\n",TICK_NUM);
+  101870:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+  101877:	00 
+  101878:	c7 04 24 c0 63 10 00 	movl   $0x1063c0,(%esp)
+  10187f:	e8 b8 ea ff ff       	call   10033c <cprintf>
+#ifdef DEBUG_GRADE
+    cprintf("End of Test.\n");
+  101884:	c7 04 24 ca 63 10 00 	movl   $0x1063ca,(%esp)
+  10188b:	e8 ac ea ff ff       	call   10033c <cprintf>
+    panic("EOT: kernel seems ok.");
+  101890:	c7 44 24 08 d8 63 10 	movl   $0x1063d8,0x8(%esp)
+  101897:	00 
+  101898:	c7 44 24 04 13 00 00 	movl   $0x13,0x4(%esp)
+  10189f:	00 
+  1018a0:	c7 04 24 ee 63 10 00 	movl   $0x1063ee,(%esp)
+  1018a7:	e8 14 f4 ff ff       	call   100cc0 <__panic>
+
+001018ac <idt_init>:
+    sizeof(idt) - 1, (uintptr_t)idt
+};
+
+/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
+void
+idt_init(void) {
+  1018ac:	55                   	push   %ebp
+  1018ad:	89 e5                	mov    %esp,%ebp
+  1018af:	83 ec 10             	sub    $0x10,%esp
+      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+	extern uintptr_t __vectors[];
+	int i;
+	for(i=0;i<sizeof(idt)/sizeof(struct gatedesc);i++){
+  1018b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  1018b9:	e9 c3 00 00 00       	jmp    101981 <idt_init+0xd5>
+		SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+  1018be:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1018c1:	8b 04 85 00 76 11 00 	mov    0x117600(,%eax,4),%eax
+  1018c8:	89 c2                	mov    %eax,%edx
+  1018ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1018cd:	66 89 14 c5 c0 80 11 	mov    %dx,0x1180c0(,%eax,8)
+  1018d4:	00 
+  1018d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1018d8:	66 c7 04 c5 c2 80 11 	movw   $0x8,0x1180c2(,%eax,8)
+  1018df:	00 08 00 
+  1018e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1018e5:	0f b6 14 c5 c4 80 11 	movzbl 0x1180c4(,%eax,8),%edx
+  1018ec:	00 
+  1018ed:	83 e2 e0             	and    $0xffffffe0,%edx
+  1018f0:	88 14 c5 c4 80 11 00 	mov    %dl,0x1180c4(,%eax,8)
+  1018f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1018fa:	0f b6 14 c5 c4 80 11 	movzbl 0x1180c4(,%eax,8),%edx
+  101901:	00 
+  101902:	83 e2 1f             	and    $0x1f,%edx
+  101905:	88 14 c5 c4 80 11 00 	mov    %dl,0x1180c4(,%eax,8)
+  10190c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10190f:	0f b6 14 c5 c5 80 11 	movzbl 0x1180c5(,%eax,8),%edx
+  101916:	00 
+  101917:	83 e2 f0             	and    $0xfffffff0,%edx
+  10191a:	83 ca 0e             	or     $0xe,%edx
+  10191d:	88 14 c5 c5 80 11 00 	mov    %dl,0x1180c5(,%eax,8)
+  101924:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101927:	0f b6 14 c5 c5 80 11 	movzbl 0x1180c5(,%eax,8),%edx
+  10192e:	00 
+  10192f:	83 e2 ef             	and    $0xffffffef,%edx
+  101932:	88 14 c5 c5 80 11 00 	mov    %dl,0x1180c5(,%eax,8)
+  101939:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10193c:	0f b6 14 c5 c5 80 11 	movzbl 0x1180c5(,%eax,8),%edx
+  101943:	00 
+  101944:	83 e2 9f             	and    $0xffffff9f,%edx
+  101947:	88 14 c5 c5 80 11 00 	mov    %dl,0x1180c5(,%eax,8)
+  10194e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101951:	0f b6 14 c5 c5 80 11 	movzbl 0x1180c5(,%eax,8),%edx
+  101958:	00 
+  101959:	83 ca 80             	or     $0xffffff80,%edx
+  10195c:	88 14 c5 c5 80 11 00 	mov    %dl,0x1180c5(,%eax,8)
+  101963:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101966:	8b 04 85 00 76 11 00 	mov    0x117600(,%eax,4),%eax
+  10196d:	c1 e8 10             	shr    $0x10,%eax
+  101970:	89 c2                	mov    %eax,%edx
+  101972:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101975:	66 89 14 c5 c6 80 11 	mov    %dx,0x1180c6(,%eax,8)
+  10197c:	00 
+      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+	extern uintptr_t __vectors[];
+	int i;
+	for(i=0;i<sizeof(idt)/sizeof(struct gatedesc);i++){
+  10197d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  101981:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  101984:	3d ff 00 00 00       	cmp    $0xff,%eax
+  101989:	0f 86 2f ff ff ff    	jbe    1018be <idt_init+0x12>
+		SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+	}
+	SETGATE(idt[T_SWITCH_TOK],0,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER);
+  10198f:	a1 e4 77 11 00       	mov    0x1177e4,%eax
+  101994:	66 a3 88 84 11 00    	mov    %ax,0x118488
+  10199a:	66 c7 05 8a 84 11 00 	movw   $0x8,0x11848a
+  1019a1:	08 00 
+  1019a3:	0f b6 05 8c 84 11 00 	movzbl 0x11848c,%eax
+  1019aa:	83 e0 e0             	and    $0xffffffe0,%eax
+  1019ad:	a2 8c 84 11 00       	mov    %al,0x11848c
+  1019b2:	0f b6 05 8c 84 11 00 	movzbl 0x11848c,%eax
+  1019b9:	83 e0 1f             	and    $0x1f,%eax
+  1019bc:	a2 8c 84 11 00       	mov    %al,0x11848c
+  1019c1:	0f b6 05 8d 84 11 00 	movzbl 0x11848d,%eax
+  1019c8:	83 e0 f0             	and    $0xfffffff0,%eax
+  1019cb:	83 c8 0e             	or     $0xe,%eax
+  1019ce:	a2 8d 84 11 00       	mov    %al,0x11848d
+  1019d3:	0f b6 05 8d 84 11 00 	movzbl 0x11848d,%eax
+  1019da:	83 e0 ef             	and    $0xffffffef,%eax
+  1019dd:	a2 8d 84 11 00       	mov    %al,0x11848d
+  1019e2:	0f b6 05 8d 84 11 00 	movzbl 0x11848d,%eax
+  1019e9:	83 c8 60             	or     $0x60,%eax
+  1019ec:	a2 8d 84 11 00       	mov    %al,0x11848d
+  1019f1:	0f b6 05 8d 84 11 00 	movzbl 0x11848d,%eax
+  1019f8:	83 c8 80             	or     $0xffffff80,%eax
+  1019fb:	a2 8d 84 11 00       	mov    %al,0x11848d
+  101a00:	a1 e4 77 11 00       	mov    0x1177e4,%eax
+  101a05:	c1 e8 10             	shr    $0x10,%eax
+  101a08:	66 a3 8e 84 11 00    	mov    %ax,0x11848e
+  101a0e:	c7 45 f8 80 75 11 00 	movl   $0x117580,-0x8(%ebp)
+    }
+}
+
+static inline void
+lidt(struct pseudodesc *pd) {
+    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
+  101a15:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  101a18:	0f 01 18             	lidtl  (%eax)
+	lidt(&idt_pd);
+}
+  101a1b:	c9                   	leave  
+  101a1c:	c3                   	ret    
+
+00101a1d <trapname>:
+
+static const char *
+trapname(int trapno) {
+  101a1d:	55                   	push   %ebp
+  101a1e:	89 e5                	mov    %esp,%ebp
+        "Alignment Check",
+        "Machine-Check",
+        "SIMD Floating-Point Exception"
+    };
+
+    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+  101a20:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a23:	83 f8 13             	cmp    $0x13,%eax
+  101a26:	77 0c                	ja     101a34 <trapname+0x17>
+        return excnames[trapno];
+  101a28:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a2b:	8b 04 85 40 67 10 00 	mov    0x106740(,%eax,4),%eax
+  101a32:	eb 18                	jmp    101a4c <trapname+0x2f>
+    }
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+  101a34:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
+  101a38:	7e 0d                	jle    101a47 <trapname+0x2a>
+  101a3a:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
+  101a3e:	7f 07                	jg     101a47 <trapname+0x2a>
+        return "Hardware Interrupt";
+  101a40:	b8 ff 63 10 00       	mov    $0x1063ff,%eax
+  101a45:	eb 05                	jmp    101a4c <trapname+0x2f>
+    }
+    return "(unknown trap)";
+  101a47:	b8 12 64 10 00       	mov    $0x106412,%eax
+}
+  101a4c:	5d                   	pop    %ebp
+  101a4d:	c3                   	ret    
+
+00101a4e <trap_in_kernel>:
+
+/* trap_in_kernel - test if trap happened in kernel */
+bool
+trap_in_kernel(struct trapframe *tf) {
+  101a4e:	55                   	push   %ebp
+  101a4f:	89 e5                	mov    %esp,%ebp
+    return (tf->tf_cs == (uint16_t)KERNEL_CS);
+  101a51:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a54:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101a58:	66 83 f8 08          	cmp    $0x8,%ax
+  101a5c:	0f 94 c0             	sete   %al
+  101a5f:	0f b6 c0             	movzbl %al,%eax
+}
+  101a62:	5d                   	pop    %ebp
+  101a63:	c3                   	ret    
+
+00101a64 <print_trapframe>:
+    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
+    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+};
+
+void
+print_trapframe(struct trapframe *tf) {
+  101a64:	55                   	push   %ebp
+  101a65:	89 e5                	mov    %esp,%ebp
+  101a67:	83 ec 28             	sub    $0x28,%esp
+    cprintf("trapframe at %p\n", tf);
+  101a6a:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a6d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a71:	c7 04 24 53 64 10 00 	movl   $0x106453,(%esp)
+  101a78:	e8 bf e8 ff ff       	call   10033c <cprintf>
+    print_regs(&tf->tf_regs);
+  101a7d:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a80:	89 04 24             	mov    %eax,(%esp)
+  101a83:	e8 a1 01 00 00       	call   101c29 <print_regs>
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+  101a88:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a8b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
+  101a8f:	0f b7 c0             	movzwl %ax,%eax
+  101a92:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a96:	c7 04 24 64 64 10 00 	movl   $0x106464,(%esp)
+  101a9d:	e8 9a e8 ff ff       	call   10033c <cprintf>
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+  101aa2:	8b 45 08             	mov    0x8(%ebp),%eax
+  101aa5:	0f b7 40 28          	movzwl 0x28(%eax),%eax
+  101aa9:	0f b7 c0             	movzwl %ax,%eax
+  101aac:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101ab0:	c7 04 24 77 64 10 00 	movl   $0x106477,(%esp)
+  101ab7:	e8 80 e8 ff ff       	call   10033c <cprintf>
+    cprintf("  fs   0x----%04x\n", tf->tf_fs);
+  101abc:	8b 45 08             	mov    0x8(%ebp),%eax
+  101abf:	0f b7 40 24          	movzwl 0x24(%eax),%eax
+  101ac3:	0f b7 c0             	movzwl %ax,%eax
+  101ac6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101aca:	c7 04 24 8a 64 10 00 	movl   $0x10648a,(%esp)
+  101ad1:	e8 66 e8 ff ff       	call   10033c <cprintf>
+    cprintf("  gs   0x----%04x\n", tf->tf_gs);
+  101ad6:	8b 45 08             	mov    0x8(%ebp),%eax
+  101ad9:	0f b7 40 20          	movzwl 0x20(%eax),%eax
+  101add:	0f b7 c0             	movzwl %ax,%eax
+  101ae0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101ae4:	c7 04 24 9d 64 10 00 	movl   $0x10649d,(%esp)
+  101aeb:	e8 4c e8 ff ff       	call   10033c <cprintf>
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+  101af0:	8b 45 08             	mov    0x8(%ebp),%eax
+  101af3:	8b 40 30             	mov    0x30(%eax),%eax
+  101af6:	89 04 24             	mov    %eax,(%esp)
+  101af9:	e8 1f ff ff ff       	call   101a1d <trapname>
+  101afe:	8b 55 08             	mov    0x8(%ebp),%edx
+  101b01:	8b 52 30             	mov    0x30(%edx),%edx
+  101b04:	89 44 24 08          	mov    %eax,0x8(%esp)
+  101b08:	89 54 24 04          	mov    %edx,0x4(%esp)
+  101b0c:	c7 04 24 b0 64 10 00 	movl   $0x1064b0,(%esp)
+  101b13:	e8 24 e8 ff ff       	call   10033c <cprintf>
+    cprintf("  err  0x%08x\n", tf->tf_err);
+  101b18:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b1b:	8b 40 34             	mov    0x34(%eax),%eax
+  101b1e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b22:	c7 04 24 c2 64 10 00 	movl   $0x1064c2,(%esp)
+  101b29:	e8 0e e8 ff ff       	call   10033c <cprintf>
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+  101b2e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b31:	8b 40 38             	mov    0x38(%eax),%eax
+  101b34:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b38:	c7 04 24 d1 64 10 00 	movl   $0x1064d1,(%esp)
+  101b3f:	e8 f8 e7 ff ff       	call   10033c <cprintf>
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+  101b44:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b47:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101b4b:	0f b7 c0             	movzwl %ax,%eax
+  101b4e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b52:	c7 04 24 e0 64 10 00 	movl   $0x1064e0,(%esp)
+  101b59:	e8 de e7 ff ff       	call   10033c <cprintf>
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+  101b5e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b61:	8b 40 40             	mov    0x40(%eax),%eax
+  101b64:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b68:	c7 04 24 f3 64 10 00 	movl   $0x1064f3,(%esp)
+  101b6f:	e8 c8 e7 ff ff       	call   10033c <cprintf>
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+  101b74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  101b7b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+  101b82:	eb 3e                	jmp    101bc2 <print_trapframe+0x15e>
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+  101b84:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b87:	8b 50 40             	mov    0x40(%eax),%edx
+  101b8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  101b8d:	21 d0                	and    %edx,%eax
+  101b8f:	85 c0                	test   %eax,%eax
+  101b91:	74 28                	je     101bbb <print_trapframe+0x157>
+  101b93:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101b96:	8b 04 85 a0 75 11 00 	mov    0x1175a0(,%eax,4),%eax
+  101b9d:	85 c0                	test   %eax,%eax
+  101b9f:	74 1a                	je     101bbb <print_trapframe+0x157>
+            cprintf("%s,", IA32flags[i]);
+  101ba1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101ba4:	8b 04 85 a0 75 11 00 	mov    0x1175a0(,%eax,4),%eax
+  101bab:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101baf:	c7 04 24 02 65 10 00 	movl   $0x106502,(%esp)
+  101bb6:	e8 81 e7 ff ff       	call   10033c <cprintf>
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+  101bbb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  101bbf:	d1 65 f0             	shll   -0x10(%ebp)
+  101bc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101bc5:	83 f8 17             	cmp    $0x17,%eax
+  101bc8:	76 ba                	jbe    101b84 <print_trapframe+0x120>
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+            cprintf("%s,", IA32flags[i]);
+        }
+    }
+    cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
+  101bca:	8b 45 08             	mov    0x8(%ebp),%eax
+  101bcd:	8b 40 40             	mov    0x40(%eax),%eax
+  101bd0:	25 00 30 00 00       	and    $0x3000,%eax
+  101bd5:	c1 e8 0c             	shr    $0xc,%eax
+  101bd8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101bdc:	c7 04 24 06 65 10 00 	movl   $0x106506,(%esp)
+  101be3:	e8 54 e7 ff ff       	call   10033c <cprintf>
+
+    if (!trap_in_kernel(tf)) {
+  101be8:	8b 45 08             	mov    0x8(%ebp),%eax
+  101beb:	89 04 24             	mov    %eax,(%esp)
+  101bee:	e8 5b fe ff ff       	call   101a4e <trap_in_kernel>
+  101bf3:	85 c0                	test   %eax,%eax
+  101bf5:	75 30                	jne    101c27 <print_trapframe+0x1c3>
+        cprintf("  esp  0x%08x\n", tf->tf_esp);
+  101bf7:	8b 45 08             	mov    0x8(%ebp),%eax
+  101bfa:	8b 40 44             	mov    0x44(%eax),%eax
+  101bfd:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101c01:	c7 04 24 0f 65 10 00 	movl   $0x10650f,(%esp)
+  101c08:	e8 2f e7 ff ff       	call   10033c <cprintf>
+        cprintf("  ss   0x----%04x\n", tf->tf_ss);
+  101c0d:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c10:	0f b7 40 48          	movzwl 0x48(%eax),%eax
+  101c14:	0f b7 c0             	movzwl %ax,%eax
+  101c17:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101c1b:	c7 04 24 1e 65 10 00 	movl   $0x10651e,(%esp)
+  101c22:	e8 15 e7 ff ff       	call   10033c <cprintf>
+    }
+}
+  101c27:	c9                   	leave  
+  101c28:	c3                   	ret    
+
+00101c29 <print_regs>:
+
+void
+print_regs(struct pushregs *regs) {
+  101c29:	55                   	push   %ebp
+  101c2a:	89 e5                	mov    %esp,%ebp
+  101c2c:	83 ec 18             	sub    $0x18,%esp
+    cprintf("  edi  0x%08x\n", regs->reg_edi);
+  101c2f:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c32:	8b 00                	mov    (%eax),%eax
+  101c34:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101c38:	c7 04 24 31 65 10 00 	movl   $0x106531,(%esp)
+  101c3f:	e8 f8 e6 ff ff       	call   10033c <cprintf>
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+  101c44:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c47:	8b 40 04             	mov    0x4(%eax),%eax
+  101c4a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101c4e:	c7 04 24 40 65 10 00 	movl   $0x106540,(%esp)
+  101c55:	e8 e2 e6 ff ff       	call   10033c <cprintf>
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+  101c5a:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c5d:	8b 40 08             	mov    0x8(%eax),%eax
+  101c60:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101c64:	c7 04 24 4f 65 10 00 	movl   $0x10654f,(%esp)
+  101c6b:	e8 cc e6 ff ff       	call   10033c <cprintf>
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+  101c70:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c73:	8b 40 0c             	mov    0xc(%eax),%eax
+  101c76:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101c7a:	c7 04 24 5e 65 10 00 	movl   $0x10655e,(%esp)
+  101c81:	e8 b6 e6 ff ff       	call   10033c <cprintf>
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+  101c86:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c89:	8b 40 10             	mov    0x10(%eax),%eax
+  101c8c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101c90:	c7 04 24 6d 65 10 00 	movl   $0x10656d,(%esp)
+  101c97:	e8 a0 e6 ff ff       	call   10033c <cprintf>
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+  101c9c:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c9f:	8b 40 14             	mov    0x14(%eax),%eax
+  101ca2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101ca6:	c7 04 24 7c 65 10 00 	movl   $0x10657c,(%esp)
+  101cad:	e8 8a e6 ff ff       	call   10033c <cprintf>
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+  101cb2:	8b 45 08             	mov    0x8(%ebp),%eax
+  101cb5:	8b 40 18             	mov    0x18(%eax),%eax
+  101cb8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101cbc:	c7 04 24 8b 65 10 00 	movl   $0x10658b,(%esp)
+  101cc3:	e8 74 e6 ff ff       	call   10033c <cprintf>
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+  101cc8:	8b 45 08             	mov    0x8(%ebp),%eax
+  101ccb:	8b 40 1c             	mov    0x1c(%eax),%eax
+  101cce:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101cd2:	c7 04 24 9a 65 10 00 	movl   $0x10659a,(%esp)
+  101cd9:	e8 5e e6 ff ff       	call   10033c <cprintf>
+}
+  101cde:	c9                   	leave  
+  101cdf:	c3                   	ret    
+
+00101ce0 <trap_dispatch>:
+
+struct trapframe switchk2u, *switchu2k;
+
+/* trap_dispatch - dispatch based on what type of trap occurred */
+static void
+trap_dispatch(struct trapframe *tf) {
+  101ce0:	55                   	push   %ebp
+  101ce1:	89 e5                	mov    %esp,%ebp
+  101ce3:	57                   	push   %edi
+  101ce4:	56                   	push   %esi
+  101ce5:	53                   	push   %ebx
+  101ce6:	83 ec 2c             	sub    $0x2c,%esp
+    char c;
+
+    switch (tf->tf_trapno) {
+  101ce9:	8b 45 08             	mov    0x8(%ebp),%eax
+  101cec:	8b 40 30             	mov    0x30(%eax),%eax
+  101cef:	83 f8 2f             	cmp    $0x2f,%eax
+  101cf2:	77 21                	ja     101d15 <trap_dispatch+0x35>
+  101cf4:	83 f8 2e             	cmp    $0x2e,%eax
+  101cf7:	0f 83 ec 01 00 00    	jae    101ee9 <trap_dispatch+0x209>
+  101cfd:	83 f8 21             	cmp    $0x21,%eax
+  101d00:	0f 84 8a 00 00 00    	je     101d90 <trap_dispatch+0xb0>
+  101d06:	83 f8 24             	cmp    $0x24,%eax
+  101d09:	74 5c                	je     101d67 <trap_dispatch+0x87>
+  101d0b:	83 f8 20             	cmp    $0x20,%eax
+  101d0e:	74 1c                	je     101d2c <trap_dispatch+0x4c>
+  101d10:	e9 9c 01 00 00       	jmp    101eb1 <trap_dispatch+0x1d1>
+  101d15:	83 f8 78             	cmp    $0x78,%eax
+  101d18:	0f 84 9b 00 00 00    	je     101db9 <trap_dispatch+0xd9>
+  101d1e:	83 f8 79             	cmp    $0x79,%eax
+  101d21:	0f 84 11 01 00 00    	je     101e38 <trap_dispatch+0x158>
+  101d27:	e9 85 01 00 00       	jmp    101eb1 <trap_dispatch+0x1d1>
+        /* handle the timer interrupt */
+        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+	ticks++;
+  101d2c:	a1 4c 89 11 00       	mov    0x11894c,%eax
+  101d31:	83 c0 01             	add    $0x1,%eax
+  101d34:	a3 4c 89 11 00       	mov    %eax,0x11894c
+	if(ticks%TICK_NUM==0){
+  101d39:	8b 0d 4c 89 11 00    	mov    0x11894c,%ecx
+  101d3f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+  101d44:	89 c8                	mov    %ecx,%eax
+  101d46:	f7 e2                	mul    %edx
+  101d48:	89 d0                	mov    %edx,%eax
+  101d4a:	c1 e8 05             	shr    $0x5,%eax
+  101d4d:	6b c0 64             	imul   $0x64,%eax,%eax
+  101d50:	29 c1                	sub    %eax,%ecx
+  101d52:	89 c8                	mov    %ecx,%eax
+  101d54:	85 c0                	test   %eax,%eax
+  101d56:	75 0a                	jne    101d62 <trap_dispatch+0x82>
+		print_ticks();	
+  101d58:	e8 0d fb ff ff       	call   10186a <print_ticks>
+	}
+        break;
+  101d5d:	e9 88 01 00 00       	jmp    101eea <trap_dispatch+0x20a>
+  101d62:	e9 83 01 00 00       	jmp    101eea <trap_dispatch+0x20a>
+    case IRQ_OFFSET + IRQ_COM1:
+        c = cons_getc();
+  101d67:	e8 c2 f8 ff ff       	call   10162e <cons_getc>
+  101d6c:	88 45 e7             	mov    %al,-0x19(%ebp)
+        cprintf("serial [%03d] %c\n", c, c);
+  101d6f:	0f be 55 e7          	movsbl -0x19(%ebp),%edx
+  101d73:	0f be 45 e7          	movsbl -0x19(%ebp),%eax
+  101d77:	89 54 24 08          	mov    %edx,0x8(%esp)
+  101d7b:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101d7f:	c7 04 24 a9 65 10 00 	movl   $0x1065a9,(%esp)
+  101d86:	e8 b1 e5 ff ff       	call   10033c <cprintf>
+        break;
+  101d8b:	e9 5a 01 00 00       	jmp    101eea <trap_dispatch+0x20a>
+    case IRQ_OFFSET + IRQ_KBD:
+        c = cons_getc();
+  101d90:	e8 99 f8 ff ff       	call   10162e <cons_getc>
+  101d95:	88 45 e7             	mov    %al,-0x19(%ebp)
+        cprintf("kbd [%03d] %c\n", c, c);
+  101d98:	0f be 55 e7          	movsbl -0x19(%ebp),%edx
+  101d9c:	0f be 45 e7          	movsbl -0x19(%ebp),%eax
+  101da0:	89 54 24 08          	mov    %edx,0x8(%esp)
+  101da4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101da8:	c7 04 24 bb 65 10 00 	movl   $0x1065bb,(%esp)
+  101daf:	e8 88 e5 ff ff       	call   10033c <cprintf>
+	break;
+  101db4:	e9 31 01 00 00       	jmp    101eea <trap_dispatch+0x20a>
+    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    case T_SWITCH_TOU:
+	if (tf->tf_cs != USER_CS) {
+  101db9:	8b 45 08             	mov    0x8(%ebp),%eax
+  101dbc:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101dc0:	66 83 f8 1b          	cmp    $0x1b,%ax
+  101dc4:	74 6d                	je     101e33 <trap_dispatch+0x153>
+	        switchk2u = *tf;
+  101dc6:	8b 45 08             	mov    0x8(%ebp),%eax
+  101dc9:	ba 60 89 11 00       	mov    $0x118960,%edx
+  101dce:	89 c3                	mov    %eax,%ebx
+  101dd0:	b8 13 00 00 00       	mov    $0x13,%eax
+  101dd5:	89 d7                	mov    %edx,%edi
+  101dd7:	89 de                	mov    %ebx,%esi
+  101dd9:	89 c1                	mov    %eax,%ecx
+  101ddb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+	        switchk2u.tf_cs = USER_CS;
+  101ddd:	66 c7 05 9c 89 11 00 	movw   $0x1b,0x11899c
+  101de4:	1b 00 
+	        switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;
+  101de6:	66 c7 05 a8 89 11 00 	movw   $0x23,0x1189a8
+  101ded:	23 00 
+  101def:	0f b7 05 a8 89 11 00 	movzwl 0x1189a8,%eax
+  101df6:	66 a3 88 89 11 00    	mov    %ax,0x118988
+  101dfc:	0f b7 05 88 89 11 00 	movzwl 0x118988,%eax
+  101e03:	66 a3 8c 89 11 00    	mov    %ax,0x11898c
+	        switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8;
+  101e09:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e0c:	83 c0 44             	add    $0x44,%eax
+  101e0f:	a3 a4 89 11 00       	mov    %eax,0x1189a4
+		switchk2u.tf_eflags |= FL_IOPL_MASK;
+  101e14:	a1 a0 89 11 00       	mov    0x1189a0,%eax
+  101e19:	80 cc 30             	or     $0x30,%ah
+  101e1c:	a3 a0 89 11 00       	mov    %eax,0x1189a0
+		*((uint32_t *)tf - 1) = (uint32_t)&switchk2u;
+  101e21:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e24:	8d 50 fc             	lea    -0x4(%eax),%edx
+  101e27:	b8 60 89 11 00       	mov    $0x118960,%eax
+  101e2c:	89 02                	mov    %eax,(%edx)
+	}
+	break;
+  101e2e:	e9 b7 00 00 00       	jmp    101eea <trap_dispatch+0x20a>
+  101e33:	e9 b2 00 00 00       	jmp    101eea <trap_dispatch+0x20a>
+    case T_SWITCH_TOK:
+        if (tf->tf_cs != KERNEL_CS) {
+  101e38:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e3b:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101e3f:	66 83 f8 08          	cmp    $0x8,%ax
+  101e43:	74 6a                	je     101eaf <trap_dispatch+0x1cf>
+            tf->tf_cs = KERNEL_CS;
+  101e45:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e48:	66 c7 40 3c 08 00    	movw   $0x8,0x3c(%eax)
+            tf->tf_ds = tf->tf_es = KERNEL_DS;
+  101e4e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e51:	66 c7 40 28 10 00    	movw   $0x10,0x28(%eax)
+  101e57:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e5a:	0f b7 50 28          	movzwl 0x28(%eax),%edx
+  101e5e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e61:	66 89 50 2c          	mov    %dx,0x2c(%eax)
+            tf->tf_eflags &= ~FL_IOPL_MASK;
+  101e65:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e68:	8b 40 40             	mov    0x40(%eax),%eax
+  101e6b:	80 e4 cf             	and    $0xcf,%ah
+  101e6e:	89 c2                	mov    %eax,%edx
+  101e70:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e73:	89 50 40             	mov    %edx,0x40(%eax)
+            switchu2k = (struct trapframe *)(tf->tf_esp - (sizeof(struct trapframe) - 8));
+  101e76:	8b 45 08             	mov    0x8(%ebp),%eax
+  101e79:	8b 40 44             	mov    0x44(%eax),%eax
+  101e7c:	83 e8 44             	sub    $0x44,%eax
+  101e7f:	a3 ac 89 11 00       	mov    %eax,0x1189ac
+            memmove(switchu2k, tf, sizeof(struct trapframe) - 8);
+  101e84:	a1 ac 89 11 00       	mov    0x1189ac,%eax
+  101e89:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
+  101e90:	00 
+  101e91:	8b 55 08             	mov    0x8(%ebp),%edx
+  101e94:	89 54 24 04          	mov    %edx,0x4(%esp)
+  101e98:	89 04 24             	mov    %eax,(%esp)
+  101e9b:	e8 65 40 00 00       	call   105f05 <memmove>
+            *((uint32_t *)tf - 1) = (uint32_t)switchu2k;
+  101ea0:	8b 45 08             	mov    0x8(%ebp),%eax
+  101ea3:	8d 50 fc             	lea    -0x4(%eax),%edx
+  101ea6:	a1 ac 89 11 00       	mov    0x1189ac,%eax
+  101eab:	89 02                	mov    %eax,(%edx)
+        }
+        break;
+  101ead:	eb 3b                	jmp    101eea <trap_dispatch+0x20a>
+  101eaf:	eb 39                	jmp    101eea <trap_dispatch+0x20a>
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+    default:
+        // in kernel, it must be a mistake
+        if ((tf->tf_cs & 3) == 0) {
+  101eb1:	8b 45 08             	mov    0x8(%ebp),%eax
+  101eb4:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101eb8:	0f b7 c0             	movzwl %ax,%eax
+  101ebb:	83 e0 03             	and    $0x3,%eax
+  101ebe:	85 c0                	test   %eax,%eax
+  101ec0:	75 28                	jne    101eea <trap_dispatch+0x20a>
+            print_trapframe(tf);
+  101ec2:	8b 45 08             	mov    0x8(%ebp),%eax
+  101ec5:	89 04 24             	mov    %eax,(%esp)
+  101ec8:	e8 97 fb ff ff       	call   101a64 <print_trapframe>
+            panic("unexpected trap in kernel.\n");
+  101ecd:	c7 44 24 08 ca 65 10 	movl   $0x1065ca,0x8(%esp)
+  101ed4:	00 
+  101ed5:	c7 44 24 04 cb 00 00 	movl   $0xcb,0x4(%esp)
+  101edc:	00 
+  101edd:	c7 04 24 ee 63 10 00 	movl   $0x1063ee,(%esp)
+  101ee4:	e8 d7 ed ff ff       	call   100cc0 <__panic>
+        break;
+
+    case IRQ_OFFSET + IRQ_IDE1:
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+  101ee9:	90                   	nop
+        if ((tf->tf_cs & 3) == 0) {
+            print_trapframe(tf);
+            panic("unexpected trap in kernel.\n");
+        }
+    }
+}
+  101eea:	83 c4 2c             	add    $0x2c,%esp
+  101eed:	5b                   	pop    %ebx
+  101eee:	5e                   	pop    %esi
+  101eef:	5f                   	pop    %edi
+  101ef0:	5d                   	pop    %ebp
+  101ef1:	c3                   	ret    
+
+00101ef2 <trap>:
+ * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
+ * the code in kern/trap/trapentry.S restores the old CPU state saved in the
+ * trapframe and then uses the iret instruction to return from the exception.
+ * */
+void
+trap(struct trapframe *tf) {
+  101ef2:	55                   	push   %ebp
+  101ef3:	89 e5                	mov    %esp,%ebp
+  101ef5:	83 ec 18             	sub    $0x18,%esp
+    // dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+  101ef8:	8b 45 08             	mov    0x8(%ebp),%eax
+  101efb:	89 04 24             	mov    %eax,(%esp)
+  101efe:	e8 dd fd ff ff       	call   101ce0 <trap_dispatch>
+}
+  101f03:	c9                   	leave  
+  101f04:	c3                   	ret    
+
+00101f05 <__alltraps>:
+.text
+.globl __alltraps
+__alltraps:
+    # push registers to build a trap frame
+    # therefore make the stack look like a struct trapframe
+    pushl %ds
+  101f05:	1e                   	push   %ds
+    pushl %es
+  101f06:	06                   	push   %es
+    pushl %fs
+  101f07:	0f a0                	push   %fs
+    pushl %gs
+  101f09:	0f a8                	push   %gs
+    pushal
+  101f0b:	60                   	pusha  
+
+    # load GD_KDATA into %ds and %es to set up data segments for kernel
+    movl $GD_KDATA, %eax
+  101f0c:	b8 10 00 00 00       	mov    $0x10,%eax
+    movw %ax, %ds
+  101f11:	8e d8                	mov    %eax,%ds
+    movw %ax, %es
+  101f13:	8e c0                	mov    %eax,%es
+
+    # push %esp to pass a pointer to the trapframe as an argument to trap()
+    pushl %esp
+  101f15:	54                   	push   %esp
+
+    # call trap(tf), where tf=%esp
+    call trap
+  101f16:	e8 d7 ff ff ff       	call   101ef2 <trap>
+
+    # pop the pushed stack pointer
+    popl %esp
+  101f1b:	5c                   	pop    %esp
+
+00101f1c <__trapret>:
+
+    # return falls through to trapret...
+.globl __trapret
+__trapret:
+    # restore registers from stack
+    popal
+  101f1c:	61                   	popa   
+
+    # restore %ds, %es, %fs and %gs
+    popl %gs
+  101f1d:	0f a9                	pop    %gs
+    popl %fs
+  101f1f:	0f a1                	pop    %fs
+    popl %es
+  101f21:	07                   	pop    %es
+    popl %ds
+  101f22:	1f                   	pop    %ds
+
+    # get rid of the trap number and error code
+    addl $0x8, %esp
+  101f23:	83 c4 08             	add    $0x8,%esp
+    iret
+  101f26:	cf                   	iret   
+
+00101f27 <vector0>:
+# handler
+.text
+.globl __alltraps
+.globl vector0
+vector0:
+  pushl $0
+  101f27:	6a 00                	push   $0x0
+  pushl $0
+  101f29:	6a 00                	push   $0x0
+  jmp __alltraps
+  101f2b:	e9 d5 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f30 <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+  101f30:	6a 00                	push   $0x0
+  pushl $1
+  101f32:	6a 01                	push   $0x1
+  jmp __alltraps
+  101f34:	e9 cc ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f39 <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+  101f39:	6a 00                	push   $0x0
+  pushl $2
+  101f3b:	6a 02                	push   $0x2
+  jmp __alltraps
+  101f3d:	e9 c3 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f42 <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+  101f42:	6a 00                	push   $0x0
+  pushl $3
+  101f44:	6a 03                	push   $0x3
+  jmp __alltraps
+  101f46:	e9 ba ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f4b <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+  101f4b:	6a 00                	push   $0x0
+  pushl $4
+  101f4d:	6a 04                	push   $0x4
+  jmp __alltraps
+  101f4f:	e9 b1 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f54 <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+  101f54:	6a 00                	push   $0x0
+  pushl $5
+  101f56:	6a 05                	push   $0x5
+  jmp __alltraps
+  101f58:	e9 a8 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f5d <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+  101f5d:	6a 00                	push   $0x0
+  pushl $6
+  101f5f:	6a 06                	push   $0x6
+  jmp __alltraps
+  101f61:	e9 9f ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f66 <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+  101f66:	6a 00                	push   $0x0
+  pushl $7
+  101f68:	6a 07                	push   $0x7
+  jmp __alltraps
+  101f6a:	e9 96 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f6f <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+  101f6f:	6a 08                	push   $0x8
+  jmp __alltraps
+  101f71:	e9 8f ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f76 <vector9>:
+.globl vector9
+vector9:
+  pushl $9
+  101f76:	6a 09                	push   $0x9
+  jmp __alltraps
+  101f78:	e9 88 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f7d <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+  101f7d:	6a 0a                	push   $0xa
+  jmp __alltraps
+  101f7f:	e9 81 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f84 <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+  101f84:	6a 0b                	push   $0xb
+  jmp __alltraps
+  101f86:	e9 7a ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f8b <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+  101f8b:	6a 0c                	push   $0xc
+  jmp __alltraps
+  101f8d:	e9 73 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f92 <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+  101f92:	6a 0d                	push   $0xd
+  jmp __alltraps
+  101f94:	e9 6c ff ff ff       	jmp    101f05 <__alltraps>
+
+00101f99 <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+  101f99:	6a 0e                	push   $0xe
+  jmp __alltraps
+  101f9b:	e9 65 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fa0 <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+  101fa0:	6a 00                	push   $0x0
+  pushl $15
+  101fa2:	6a 0f                	push   $0xf
+  jmp __alltraps
+  101fa4:	e9 5c ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fa9 <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+  101fa9:	6a 00                	push   $0x0
+  pushl $16
+  101fab:	6a 10                	push   $0x10
+  jmp __alltraps
+  101fad:	e9 53 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fb2 <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+  101fb2:	6a 11                	push   $0x11
+  jmp __alltraps
+  101fb4:	e9 4c ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fb9 <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+  101fb9:	6a 00                	push   $0x0
+  pushl $18
+  101fbb:	6a 12                	push   $0x12
+  jmp __alltraps
+  101fbd:	e9 43 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fc2 <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+  101fc2:	6a 00                	push   $0x0
+  pushl $19
+  101fc4:	6a 13                	push   $0x13
+  jmp __alltraps
+  101fc6:	e9 3a ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fcb <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+  101fcb:	6a 00                	push   $0x0
+  pushl $20
+  101fcd:	6a 14                	push   $0x14
+  jmp __alltraps
+  101fcf:	e9 31 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fd4 <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+  101fd4:	6a 00                	push   $0x0
+  pushl $21
+  101fd6:	6a 15                	push   $0x15
+  jmp __alltraps
+  101fd8:	e9 28 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fdd <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+  101fdd:	6a 00                	push   $0x0
+  pushl $22
+  101fdf:	6a 16                	push   $0x16
+  jmp __alltraps
+  101fe1:	e9 1f ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fe6 <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+  101fe6:	6a 00                	push   $0x0
+  pushl $23
+  101fe8:	6a 17                	push   $0x17
+  jmp __alltraps
+  101fea:	e9 16 ff ff ff       	jmp    101f05 <__alltraps>
+
+00101fef <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+  101fef:	6a 00                	push   $0x0
+  pushl $24
+  101ff1:	6a 18                	push   $0x18
+  jmp __alltraps
+  101ff3:	e9 0d ff ff ff       	jmp    101f05 <__alltraps>
+
+00101ff8 <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+  101ff8:	6a 00                	push   $0x0
+  pushl $25
+  101ffa:	6a 19                	push   $0x19
+  jmp __alltraps
+  101ffc:	e9 04 ff ff ff       	jmp    101f05 <__alltraps>
+
+00102001 <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+  102001:	6a 00                	push   $0x0
+  pushl $26
+  102003:	6a 1a                	push   $0x1a
+  jmp __alltraps
+  102005:	e9 fb fe ff ff       	jmp    101f05 <__alltraps>
+
+0010200a <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+  10200a:	6a 00                	push   $0x0
+  pushl $27
+  10200c:	6a 1b                	push   $0x1b
+  jmp __alltraps
+  10200e:	e9 f2 fe ff ff       	jmp    101f05 <__alltraps>
+
+00102013 <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+  102013:	6a 00                	push   $0x0
+  pushl $28
+  102015:	6a 1c                	push   $0x1c
+  jmp __alltraps
+  102017:	e9 e9 fe ff ff       	jmp    101f05 <__alltraps>
+
+0010201c <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+  10201c:	6a 00                	push   $0x0
+  pushl $29
+  10201e:	6a 1d                	push   $0x1d
+  jmp __alltraps
+  102020:	e9 e0 fe ff ff       	jmp    101f05 <__alltraps>
+
+00102025 <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+  102025:	6a 00                	push   $0x0
+  pushl $30
+  102027:	6a 1e                	push   $0x1e
+  jmp __alltraps
+  102029:	e9 d7 fe ff ff       	jmp    101f05 <__alltraps>
+
+0010202e <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+  10202e:	6a 00                	push   $0x0
+  pushl $31
+  102030:	6a 1f                	push   $0x1f
+  jmp __alltraps
+  102032:	e9 ce fe ff ff       	jmp    101f05 <__alltraps>
+
+00102037 <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+  102037:	6a 00                	push   $0x0
+  pushl $32
+  102039:	6a 20                	push   $0x20
+  jmp __alltraps
+  10203b:	e9 c5 fe ff ff       	jmp    101f05 <__alltraps>
+
+00102040 <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+  102040:	6a 00                	push   $0x0
+  pushl $33
+  102042:	6a 21                	push   $0x21
+  jmp __alltraps
+  102044:	e9 bc fe ff ff       	jmp    101f05 <__alltraps>
+
+00102049 <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+  102049:	6a 00                	push   $0x0
+  pushl $34
+  10204b:	6a 22                	push   $0x22
+  jmp __alltraps
+  10204d:	e9 b3 fe ff ff       	jmp    101f05 <__alltraps>
+
+00102052 <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+  102052:	6a 00                	push   $0x0
+  pushl $35
+  102054:	6a 23                	push   $0x23
+  jmp __alltraps
+  102056:	e9 aa fe ff ff       	jmp    101f05 <__alltraps>
+
+0010205b <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+  10205b:	6a 00                	push   $0x0
+  pushl $36
+  10205d:	6a 24                	push   $0x24
+  jmp __alltraps
+  10205f:	e9 a1 fe ff ff       	jmp    101f05 <__alltraps>
+
+00102064 <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+  102064:	6a 00                	push   $0x0
+  pushl $37
+  102066:	6a 25                	push   $0x25
+  jmp __alltraps
+  102068:	e9 98 fe ff ff       	jmp    101f05 <__alltraps>
+
+0010206d <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+  10206d:	6a 00                	push   $0x0
+  pushl $38
+  10206f:	6a 26                	push   $0x26
+  jmp __alltraps
+  102071:	e9 8f fe ff ff       	jmp    101f05 <__alltraps>
+
+00102076 <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+  102076:	6a 00                	push   $0x0
+  pushl $39
+  102078:	6a 27                	push   $0x27
+  jmp __alltraps
+  10207a:	e9 86 fe ff ff       	jmp    101f05 <__alltraps>
+
+0010207f <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+  10207f:	6a 00                	push   $0x0
+  pushl $40
+  102081:	6a 28                	push   $0x28
+  jmp __alltraps
+  102083:	e9 7d fe ff ff       	jmp    101f05 <__alltraps>
+
+00102088 <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+  102088:	6a 00                	push   $0x0
+  pushl $41
+  10208a:	6a 29                	push   $0x29
+  jmp __alltraps
+  10208c:	e9 74 fe ff ff       	jmp    101f05 <__alltraps>
+
+00102091 <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+  102091:	6a 00                	push   $0x0
+  pushl $42
+  102093:	6a 2a                	push   $0x2a
+  jmp __alltraps
+  102095:	e9 6b fe ff ff       	jmp    101f05 <__alltraps>
+
+0010209a <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+  10209a:	6a 00                	push   $0x0
+  pushl $43
+  10209c:	6a 2b                	push   $0x2b
+  jmp __alltraps
+  10209e:	e9 62 fe ff ff       	jmp    101f05 <__alltraps>
+
+001020a3 <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+  1020a3:	6a 00                	push   $0x0
+  pushl $44
+  1020a5:	6a 2c                	push   $0x2c
+  jmp __alltraps
+  1020a7:	e9 59 fe ff ff       	jmp    101f05 <__alltraps>
+
+001020ac <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+  1020ac:	6a 00                	push   $0x0
+  pushl $45
+  1020ae:	6a 2d                	push   $0x2d
+  jmp __alltraps
+  1020b0:	e9 50 fe ff ff       	jmp    101f05 <__alltraps>
+
+001020b5 <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+  1020b5:	6a 00                	push   $0x0
+  pushl $46
+  1020b7:	6a 2e                	push   $0x2e
+  jmp __alltraps
+  1020b9:	e9 47 fe ff ff       	jmp    101f05 <__alltraps>
+
+001020be <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+  1020be:	6a 00                	push   $0x0
+  pushl $47
+  1020c0:	6a 2f                	push   $0x2f
+  jmp __alltraps
+  1020c2:	e9 3e fe ff ff       	jmp    101f05 <__alltraps>
+
+001020c7 <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+  1020c7:	6a 00                	push   $0x0
+  pushl $48
+  1020c9:	6a 30                	push   $0x30
+  jmp __alltraps
+  1020cb:	e9 35 fe ff ff       	jmp    101f05 <__alltraps>
+
+001020d0 <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+  1020d0:	6a 00                	push   $0x0
+  pushl $49
+  1020d2:	6a 31                	push   $0x31
+  jmp __alltraps
+  1020d4:	e9 2c fe ff ff       	jmp    101f05 <__alltraps>
+
+001020d9 <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+  1020d9:	6a 00                	push   $0x0
+  pushl $50
+  1020db:	6a 32                	push   $0x32
+  jmp __alltraps
+  1020dd:	e9 23 fe ff ff       	jmp    101f05 <__alltraps>
+
+001020e2 <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+  1020e2:	6a 00                	push   $0x0
+  pushl $51
+  1020e4:	6a 33                	push   $0x33
+  jmp __alltraps
+  1020e6:	e9 1a fe ff ff       	jmp    101f05 <__alltraps>
+
+001020eb <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+  1020eb:	6a 00                	push   $0x0
+  pushl $52
+  1020ed:	6a 34                	push   $0x34
+  jmp __alltraps
+  1020ef:	e9 11 fe ff ff       	jmp    101f05 <__alltraps>
+
+001020f4 <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+  1020f4:	6a 00                	push   $0x0
+  pushl $53
+  1020f6:	6a 35                	push   $0x35
+  jmp __alltraps
+  1020f8:	e9 08 fe ff ff       	jmp    101f05 <__alltraps>
+
+001020fd <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+  1020fd:	6a 00                	push   $0x0
+  pushl $54
+  1020ff:	6a 36                	push   $0x36
+  jmp __alltraps
+  102101:	e9 ff fd ff ff       	jmp    101f05 <__alltraps>
+
+00102106 <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+  102106:	6a 00                	push   $0x0
+  pushl $55
+  102108:	6a 37                	push   $0x37
+  jmp __alltraps
+  10210a:	e9 f6 fd ff ff       	jmp    101f05 <__alltraps>
+
+0010210f <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+  10210f:	6a 00                	push   $0x0
+  pushl $56
+  102111:	6a 38                	push   $0x38
+  jmp __alltraps
+  102113:	e9 ed fd ff ff       	jmp    101f05 <__alltraps>
+
+00102118 <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+  102118:	6a 00                	push   $0x0
+  pushl $57
+  10211a:	6a 39                	push   $0x39
+  jmp __alltraps
+  10211c:	e9 e4 fd ff ff       	jmp    101f05 <__alltraps>
+
+00102121 <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+  102121:	6a 00                	push   $0x0
+  pushl $58
+  102123:	6a 3a                	push   $0x3a
+  jmp __alltraps
+  102125:	e9 db fd ff ff       	jmp    101f05 <__alltraps>
+
+0010212a <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+  10212a:	6a 00                	push   $0x0
+  pushl $59
+  10212c:	6a 3b                	push   $0x3b
+  jmp __alltraps
+  10212e:	e9 d2 fd ff ff       	jmp    101f05 <__alltraps>
+
+00102133 <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+  102133:	6a 00                	push   $0x0
+  pushl $60
+  102135:	6a 3c                	push   $0x3c
+  jmp __alltraps
+  102137:	e9 c9 fd ff ff       	jmp    101f05 <__alltraps>
+
+0010213c <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+  10213c:	6a 00                	push   $0x0
+  pushl $61
+  10213e:	6a 3d                	push   $0x3d
+  jmp __alltraps
+  102140:	e9 c0 fd ff ff       	jmp    101f05 <__alltraps>
+
+00102145 <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+  102145:	6a 00                	push   $0x0
+  pushl $62
+  102147:	6a 3e                	push   $0x3e
+  jmp __alltraps
+  102149:	e9 b7 fd ff ff       	jmp    101f05 <__alltraps>
+
+0010214e <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+  10214e:	6a 00                	push   $0x0
+  pushl $63
+  102150:	6a 3f                	push   $0x3f
+  jmp __alltraps
+  102152:	e9 ae fd ff ff       	jmp    101f05 <__alltraps>
+
+00102157 <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+  102157:	6a 00                	push   $0x0
+  pushl $64
+  102159:	6a 40                	push   $0x40
+  jmp __alltraps
+  10215b:	e9 a5 fd ff ff       	jmp    101f05 <__alltraps>
+
+00102160 <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+  102160:	6a 00                	push   $0x0
+  pushl $65
+  102162:	6a 41                	push   $0x41
+  jmp __alltraps
+  102164:	e9 9c fd ff ff       	jmp    101f05 <__alltraps>
+
+00102169 <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+  102169:	6a 00                	push   $0x0
+  pushl $66
+  10216b:	6a 42                	push   $0x42
+  jmp __alltraps
+  10216d:	e9 93 fd ff ff       	jmp    101f05 <__alltraps>
+
+00102172 <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+  102172:	6a 00                	push   $0x0
+  pushl $67
+  102174:	6a 43                	push   $0x43
+  jmp __alltraps
+  102176:	e9 8a fd ff ff       	jmp    101f05 <__alltraps>
+
+0010217b <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+  10217b:	6a 00                	push   $0x0
+  pushl $68
+  10217d:	6a 44                	push   $0x44
+  jmp __alltraps
+  10217f:	e9 81 fd ff ff       	jmp    101f05 <__alltraps>
+
+00102184 <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+  102184:	6a 00                	push   $0x0
+  pushl $69
+  102186:	6a 45                	push   $0x45
+  jmp __alltraps
+  102188:	e9 78 fd ff ff       	jmp    101f05 <__alltraps>
+
+0010218d <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+  10218d:	6a 00                	push   $0x0
+  pushl $70
+  10218f:	6a 46                	push   $0x46
+  jmp __alltraps
+  102191:	e9 6f fd ff ff       	jmp    101f05 <__alltraps>
+
+00102196 <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+  102196:	6a 00                	push   $0x0
+  pushl $71
+  102198:	6a 47                	push   $0x47
+  jmp __alltraps
+  10219a:	e9 66 fd ff ff       	jmp    101f05 <__alltraps>
+
+0010219f <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+  10219f:	6a 00                	push   $0x0
+  pushl $72
+  1021a1:	6a 48                	push   $0x48
+  jmp __alltraps
+  1021a3:	e9 5d fd ff ff       	jmp    101f05 <__alltraps>
+
+001021a8 <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+  1021a8:	6a 00                	push   $0x0
+  pushl $73
+  1021aa:	6a 49                	push   $0x49
+  jmp __alltraps
+  1021ac:	e9 54 fd ff ff       	jmp    101f05 <__alltraps>
+
+001021b1 <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+  1021b1:	6a 00                	push   $0x0
+  pushl $74
+  1021b3:	6a 4a                	push   $0x4a
+  jmp __alltraps
+  1021b5:	e9 4b fd ff ff       	jmp    101f05 <__alltraps>
+
+001021ba <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+  1021ba:	6a 00                	push   $0x0
+  pushl $75
+  1021bc:	6a 4b                	push   $0x4b
+  jmp __alltraps
+  1021be:	e9 42 fd ff ff       	jmp    101f05 <__alltraps>
+
+001021c3 <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+  1021c3:	6a 00                	push   $0x0
+  pushl $76
+  1021c5:	6a 4c                	push   $0x4c
+  jmp __alltraps
+  1021c7:	e9 39 fd ff ff       	jmp    101f05 <__alltraps>
+
+001021cc <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+  1021cc:	6a 00                	push   $0x0
+  pushl $77
+  1021ce:	6a 4d                	push   $0x4d
+  jmp __alltraps
+  1021d0:	e9 30 fd ff ff       	jmp    101f05 <__alltraps>
+
+001021d5 <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+  1021d5:	6a 00                	push   $0x0
+  pushl $78
+  1021d7:	6a 4e                	push   $0x4e
+  jmp __alltraps
+  1021d9:	e9 27 fd ff ff       	jmp    101f05 <__alltraps>
+
+001021de <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+  1021de:	6a 00                	push   $0x0
+  pushl $79
+  1021e0:	6a 4f                	push   $0x4f
+  jmp __alltraps
+  1021e2:	e9 1e fd ff ff       	jmp    101f05 <__alltraps>
+
+001021e7 <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+  1021e7:	6a 00                	push   $0x0
+  pushl $80
+  1021e9:	6a 50                	push   $0x50
+  jmp __alltraps
+  1021eb:	e9 15 fd ff ff       	jmp    101f05 <__alltraps>
+
+001021f0 <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+  1021f0:	6a 00                	push   $0x0
+  pushl $81
+  1021f2:	6a 51                	push   $0x51
+  jmp __alltraps
+  1021f4:	e9 0c fd ff ff       	jmp    101f05 <__alltraps>
+
+001021f9 <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+  1021f9:	6a 00                	push   $0x0
+  pushl $82
+  1021fb:	6a 52                	push   $0x52
+  jmp __alltraps
+  1021fd:	e9 03 fd ff ff       	jmp    101f05 <__alltraps>
+
+00102202 <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+  102202:	6a 00                	push   $0x0
+  pushl $83
+  102204:	6a 53                	push   $0x53
+  jmp __alltraps
+  102206:	e9 fa fc ff ff       	jmp    101f05 <__alltraps>
+
+0010220b <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+  10220b:	6a 00                	push   $0x0
+  pushl $84
+  10220d:	6a 54                	push   $0x54
+  jmp __alltraps
+  10220f:	e9 f1 fc ff ff       	jmp    101f05 <__alltraps>
+
+00102214 <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+  102214:	6a 00                	push   $0x0
+  pushl $85
+  102216:	6a 55                	push   $0x55
+  jmp __alltraps
+  102218:	e9 e8 fc ff ff       	jmp    101f05 <__alltraps>
+
+0010221d <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+  10221d:	6a 00                	push   $0x0
+  pushl $86
+  10221f:	6a 56                	push   $0x56
+  jmp __alltraps
+  102221:	e9 df fc ff ff       	jmp    101f05 <__alltraps>
+
+00102226 <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+  102226:	6a 00                	push   $0x0
+  pushl $87
+  102228:	6a 57                	push   $0x57
+  jmp __alltraps
+  10222a:	e9 d6 fc ff ff       	jmp    101f05 <__alltraps>
+
+0010222f <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+  10222f:	6a 00                	push   $0x0
+  pushl $88
+  102231:	6a 58                	push   $0x58
+  jmp __alltraps
+  102233:	e9 cd fc ff ff       	jmp    101f05 <__alltraps>
+
+00102238 <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+  102238:	6a 00                	push   $0x0
+  pushl $89
+  10223a:	6a 59                	push   $0x59
+  jmp __alltraps
+  10223c:	e9 c4 fc ff ff       	jmp    101f05 <__alltraps>
+
+00102241 <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+  102241:	6a 00                	push   $0x0
+  pushl $90
+  102243:	6a 5a                	push   $0x5a
+  jmp __alltraps
+  102245:	e9 bb fc ff ff       	jmp    101f05 <__alltraps>
+
+0010224a <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+  10224a:	6a 00                	push   $0x0
+  pushl $91
+  10224c:	6a 5b                	push   $0x5b
+  jmp __alltraps
+  10224e:	e9 b2 fc ff ff       	jmp    101f05 <__alltraps>
+
+00102253 <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+  102253:	6a 00                	push   $0x0
+  pushl $92
+  102255:	6a 5c                	push   $0x5c
+  jmp __alltraps
+  102257:	e9 a9 fc ff ff       	jmp    101f05 <__alltraps>
+
+0010225c <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+  10225c:	6a 00                	push   $0x0
+  pushl $93
+  10225e:	6a 5d                	push   $0x5d
+  jmp __alltraps
+  102260:	e9 a0 fc ff ff       	jmp    101f05 <__alltraps>
+
+00102265 <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+  102265:	6a 00                	push   $0x0
+  pushl $94
+  102267:	6a 5e                	push   $0x5e
+  jmp __alltraps
+  102269:	e9 97 fc ff ff       	jmp    101f05 <__alltraps>
+
+0010226e <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+  10226e:	6a 00                	push   $0x0
+  pushl $95
+  102270:	6a 5f                	push   $0x5f
+  jmp __alltraps
+  102272:	e9 8e fc ff ff       	jmp    101f05 <__alltraps>
+
+00102277 <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+  102277:	6a 00                	push   $0x0
+  pushl $96
+  102279:	6a 60                	push   $0x60
+  jmp __alltraps
+  10227b:	e9 85 fc ff ff       	jmp    101f05 <__alltraps>
+
+00102280 <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+  102280:	6a 00                	push   $0x0
+  pushl $97
+  102282:	6a 61                	push   $0x61
+  jmp __alltraps
+  102284:	e9 7c fc ff ff       	jmp    101f05 <__alltraps>
+
+00102289 <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+  102289:	6a 00                	push   $0x0
+  pushl $98
+  10228b:	6a 62                	push   $0x62
+  jmp __alltraps
+  10228d:	e9 73 fc ff ff       	jmp    101f05 <__alltraps>
+
+00102292 <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+  102292:	6a 00                	push   $0x0
+  pushl $99
+  102294:	6a 63                	push   $0x63
+  jmp __alltraps
+  102296:	e9 6a fc ff ff       	jmp    101f05 <__alltraps>
+
+0010229b <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+  10229b:	6a 00                	push   $0x0
+  pushl $100
+  10229d:	6a 64                	push   $0x64
+  jmp __alltraps
+  10229f:	e9 61 fc ff ff       	jmp    101f05 <__alltraps>
+
+001022a4 <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+  1022a4:	6a 00                	push   $0x0
+  pushl $101
+  1022a6:	6a 65                	push   $0x65
+  jmp __alltraps
+  1022a8:	e9 58 fc ff ff       	jmp    101f05 <__alltraps>
+
+001022ad <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+  1022ad:	6a 00                	push   $0x0
+  pushl $102
+  1022af:	6a 66                	push   $0x66
+  jmp __alltraps
+  1022b1:	e9 4f fc ff ff       	jmp    101f05 <__alltraps>
+
+001022b6 <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+  1022b6:	6a 00                	push   $0x0
+  pushl $103
+  1022b8:	6a 67                	push   $0x67
+  jmp __alltraps
+  1022ba:	e9 46 fc ff ff       	jmp    101f05 <__alltraps>
+
+001022bf <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+  1022bf:	6a 00                	push   $0x0
+  pushl $104
+  1022c1:	6a 68                	push   $0x68
+  jmp __alltraps
+  1022c3:	e9 3d fc ff ff       	jmp    101f05 <__alltraps>
+
+001022c8 <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+  1022c8:	6a 00                	push   $0x0
+  pushl $105
+  1022ca:	6a 69                	push   $0x69
+  jmp __alltraps
+  1022cc:	e9 34 fc ff ff       	jmp    101f05 <__alltraps>
+
+001022d1 <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+  1022d1:	6a 00                	push   $0x0
+  pushl $106
+  1022d3:	6a 6a                	push   $0x6a
+  jmp __alltraps
+  1022d5:	e9 2b fc ff ff       	jmp    101f05 <__alltraps>
+
+001022da <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+  1022da:	6a 00                	push   $0x0
+  pushl $107
+  1022dc:	6a 6b                	push   $0x6b
+  jmp __alltraps
+  1022de:	e9 22 fc ff ff       	jmp    101f05 <__alltraps>
+
+001022e3 <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+  1022e3:	6a 00                	push   $0x0
+  pushl $108
+  1022e5:	6a 6c                	push   $0x6c
+  jmp __alltraps
+  1022e7:	e9 19 fc ff ff       	jmp    101f05 <__alltraps>
+
+001022ec <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+  1022ec:	6a 00                	push   $0x0
+  pushl $109
+  1022ee:	6a 6d                	push   $0x6d
+  jmp __alltraps
+  1022f0:	e9 10 fc ff ff       	jmp    101f05 <__alltraps>
+
+001022f5 <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+  1022f5:	6a 00                	push   $0x0
+  pushl $110
+  1022f7:	6a 6e                	push   $0x6e
+  jmp __alltraps
+  1022f9:	e9 07 fc ff ff       	jmp    101f05 <__alltraps>
+
+001022fe <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+  1022fe:	6a 00                	push   $0x0
+  pushl $111
+  102300:	6a 6f                	push   $0x6f
+  jmp __alltraps
+  102302:	e9 fe fb ff ff       	jmp    101f05 <__alltraps>
+
+00102307 <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+  102307:	6a 00                	push   $0x0
+  pushl $112
+  102309:	6a 70                	push   $0x70
+  jmp __alltraps
+  10230b:	e9 f5 fb ff ff       	jmp    101f05 <__alltraps>
+
+00102310 <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+  102310:	6a 00                	push   $0x0
+  pushl $113
+  102312:	6a 71                	push   $0x71
+  jmp __alltraps
+  102314:	e9 ec fb ff ff       	jmp    101f05 <__alltraps>
+
+00102319 <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+  102319:	6a 00                	push   $0x0
+  pushl $114
+  10231b:	6a 72                	push   $0x72
+  jmp __alltraps
+  10231d:	e9 e3 fb ff ff       	jmp    101f05 <__alltraps>
+
+00102322 <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+  102322:	6a 00                	push   $0x0
+  pushl $115
+  102324:	6a 73                	push   $0x73
+  jmp __alltraps
+  102326:	e9 da fb ff ff       	jmp    101f05 <__alltraps>
+
+0010232b <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+  10232b:	6a 00                	push   $0x0
+  pushl $116
+  10232d:	6a 74                	push   $0x74
+  jmp __alltraps
+  10232f:	e9 d1 fb ff ff       	jmp    101f05 <__alltraps>
+
+00102334 <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+  102334:	6a 00                	push   $0x0
+  pushl $117
+  102336:	6a 75                	push   $0x75
+  jmp __alltraps
+  102338:	e9 c8 fb ff ff       	jmp    101f05 <__alltraps>
+
+0010233d <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+  10233d:	6a 00                	push   $0x0
+  pushl $118
+  10233f:	6a 76                	push   $0x76
+  jmp __alltraps
+  102341:	e9 bf fb ff ff       	jmp    101f05 <__alltraps>
+
+00102346 <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+  102346:	6a 00                	push   $0x0
+  pushl $119
+  102348:	6a 77                	push   $0x77
+  jmp __alltraps
+  10234a:	e9 b6 fb ff ff       	jmp    101f05 <__alltraps>
+
+0010234f <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+  10234f:	6a 00                	push   $0x0
+  pushl $120
+  102351:	6a 78                	push   $0x78
+  jmp __alltraps
+  102353:	e9 ad fb ff ff       	jmp    101f05 <__alltraps>
+
+00102358 <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+  102358:	6a 00                	push   $0x0
+  pushl $121
+  10235a:	6a 79                	push   $0x79
+  jmp __alltraps
+  10235c:	e9 a4 fb ff ff       	jmp    101f05 <__alltraps>
+
+00102361 <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+  102361:	6a 00                	push   $0x0
+  pushl $122
+  102363:	6a 7a                	push   $0x7a
+  jmp __alltraps
+  102365:	e9 9b fb ff ff       	jmp    101f05 <__alltraps>
+
+0010236a <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+  10236a:	6a 00                	push   $0x0
+  pushl $123
+  10236c:	6a 7b                	push   $0x7b
+  jmp __alltraps
+  10236e:	e9 92 fb ff ff       	jmp    101f05 <__alltraps>
+
+00102373 <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+  102373:	6a 00                	push   $0x0
+  pushl $124
+  102375:	6a 7c                	push   $0x7c
+  jmp __alltraps
+  102377:	e9 89 fb ff ff       	jmp    101f05 <__alltraps>
+
+0010237c <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+  10237c:	6a 00                	push   $0x0
+  pushl $125
+  10237e:	6a 7d                	push   $0x7d
+  jmp __alltraps
+  102380:	e9 80 fb ff ff       	jmp    101f05 <__alltraps>
+
+00102385 <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+  102385:	6a 00                	push   $0x0
+  pushl $126
+  102387:	6a 7e                	push   $0x7e
+  jmp __alltraps
+  102389:	e9 77 fb ff ff       	jmp    101f05 <__alltraps>
+
+0010238e <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+  10238e:	6a 00                	push   $0x0
+  pushl $127
+  102390:	6a 7f                	push   $0x7f
+  jmp __alltraps
+  102392:	e9 6e fb ff ff       	jmp    101f05 <__alltraps>
+
+00102397 <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+  102397:	6a 00                	push   $0x0
+  pushl $128
+  102399:	68 80 00 00 00       	push   $0x80
+  jmp __alltraps
+  10239e:	e9 62 fb ff ff       	jmp    101f05 <__alltraps>
+
+001023a3 <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+  1023a3:	6a 00                	push   $0x0
+  pushl $129
+  1023a5:	68 81 00 00 00       	push   $0x81
+  jmp __alltraps
+  1023aa:	e9 56 fb ff ff       	jmp    101f05 <__alltraps>
+
+001023af <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+  1023af:	6a 00                	push   $0x0
+  pushl $130
+  1023b1:	68 82 00 00 00       	push   $0x82
+  jmp __alltraps
+  1023b6:	e9 4a fb ff ff       	jmp    101f05 <__alltraps>
+
+001023bb <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+  1023bb:	6a 00                	push   $0x0
+  pushl $131
+  1023bd:	68 83 00 00 00       	push   $0x83
+  jmp __alltraps
+  1023c2:	e9 3e fb ff ff       	jmp    101f05 <__alltraps>
+
+001023c7 <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+  1023c7:	6a 00                	push   $0x0
+  pushl $132
+  1023c9:	68 84 00 00 00       	push   $0x84
+  jmp __alltraps
+  1023ce:	e9 32 fb ff ff       	jmp    101f05 <__alltraps>
+
+001023d3 <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+  1023d3:	6a 00                	push   $0x0
+  pushl $133
+  1023d5:	68 85 00 00 00       	push   $0x85
+  jmp __alltraps
+  1023da:	e9 26 fb ff ff       	jmp    101f05 <__alltraps>
+
+001023df <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+  1023df:	6a 00                	push   $0x0
+  pushl $134
+  1023e1:	68 86 00 00 00       	push   $0x86
+  jmp __alltraps
+  1023e6:	e9 1a fb ff ff       	jmp    101f05 <__alltraps>
+
+001023eb <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+  1023eb:	6a 00                	push   $0x0
+  pushl $135
+  1023ed:	68 87 00 00 00       	push   $0x87
+  jmp __alltraps
+  1023f2:	e9 0e fb ff ff       	jmp    101f05 <__alltraps>
+
+001023f7 <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+  1023f7:	6a 00                	push   $0x0
+  pushl $136
+  1023f9:	68 88 00 00 00       	push   $0x88
+  jmp __alltraps
+  1023fe:	e9 02 fb ff ff       	jmp    101f05 <__alltraps>
+
+00102403 <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+  102403:	6a 00                	push   $0x0
+  pushl $137
+  102405:	68 89 00 00 00       	push   $0x89
+  jmp __alltraps
+  10240a:	e9 f6 fa ff ff       	jmp    101f05 <__alltraps>
+
+0010240f <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+  10240f:	6a 00                	push   $0x0
+  pushl $138
+  102411:	68 8a 00 00 00       	push   $0x8a
+  jmp __alltraps
+  102416:	e9 ea fa ff ff       	jmp    101f05 <__alltraps>
+
+0010241b <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+  10241b:	6a 00                	push   $0x0
+  pushl $139
+  10241d:	68 8b 00 00 00       	push   $0x8b
+  jmp __alltraps
+  102422:	e9 de fa ff ff       	jmp    101f05 <__alltraps>
+
+00102427 <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+  102427:	6a 00                	push   $0x0
+  pushl $140
+  102429:	68 8c 00 00 00       	push   $0x8c
+  jmp __alltraps
+  10242e:	e9 d2 fa ff ff       	jmp    101f05 <__alltraps>
+
+00102433 <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+  102433:	6a 00                	push   $0x0
+  pushl $141
+  102435:	68 8d 00 00 00       	push   $0x8d
+  jmp __alltraps
+  10243a:	e9 c6 fa ff ff       	jmp    101f05 <__alltraps>
+
+0010243f <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+  10243f:	6a 00                	push   $0x0
+  pushl $142
+  102441:	68 8e 00 00 00       	push   $0x8e
+  jmp __alltraps
+  102446:	e9 ba fa ff ff       	jmp    101f05 <__alltraps>
+
+0010244b <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+  10244b:	6a 00                	push   $0x0
+  pushl $143
+  10244d:	68 8f 00 00 00       	push   $0x8f
+  jmp __alltraps
+  102452:	e9 ae fa ff ff       	jmp    101f05 <__alltraps>
+
+00102457 <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+  102457:	6a 00                	push   $0x0
+  pushl $144
+  102459:	68 90 00 00 00       	push   $0x90
+  jmp __alltraps
+  10245e:	e9 a2 fa ff ff       	jmp    101f05 <__alltraps>
+
+00102463 <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+  102463:	6a 00                	push   $0x0
+  pushl $145
+  102465:	68 91 00 00 00       	push   $0x91
+  jmp __alltraps
+  10246a:	e9 96 fa ff ff       	jmp    101f05 <__alltraps>
+
+0010246f <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+  10246f:	6a 00                	push   $0x0
+  pushl $146
+  102471:	68 92 00 00 00       	push   $0x92
+  jmp __alltraps
+  102476:	e9 8a fa ff ff       	jmp    101f05 <__alltraps>
+
+0010247b <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+  10247b:	6a 00                	push   $0x0
+  pushl $147
+  10247d:	68 93 00 00 00       	push   $0x93
+  jmp __alltraps
+  102482:	e9 7e fa ff ff       	jmp    101f05 <__alltraps>
+
+00102487 <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+  102487:	6a 00                	push   $0x0
+  pushl $148
+  102489:	68 94 00 00 00       	push   $0x94
+  jmp __alltraps
+  10248e:	e9 72 fa ff ff       	jmp    101f05 <__alltraps>
+
+00102493 <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+  102493:	6a 00                	push   $0x0
+  pushl $149
+  102495:	68 95 00 00 00       	push   $0x95
+  jmp __alltraps
+  10249a:	e9 66 fa ff ff       	jmp    101f05 <__alltraps>
+
+0010249f <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+  10249f:	6a 00                	push   $0x0
+  pushl $150
+  1024a1:	68 96 00 00 00       	push   $0x96
+  jmp __alltraps
+  1024a6:	e9 5a fa ff ff       	jmp    101f05 <__alltraps>
+
+001024ab <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+  1024ab:	6a 00                	push   $0x0
+  pushl $151
+  1024ad:	68 97 00 00 00       	push   $0x97
+  jmp __alltraps
+  1024b2:	e9 4e fa ff ff       	jmp    101f05 <__alltraps>
+
+001024b7 <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+  1024b7:	6a 00                	push   $0x0
+  pushl $152
+  1024b9:	68 98 00 00 00       	push   $0x98
+  jmp __alltraps
+  1024be:	e9 42 fa ff ff       	jmp    101f05 <__alltraps>
+
+001024c3 <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+  1024c3:	6a 00                	push   $0x0
+  pushl $153
+  1024c5:	68 99 00 00 00       	push   $0x99
+  jmp __alltraps
+  1024ca:	e9 36 fa ff ff       	jmp    101f05 <__alltraps>
+
+001024cf <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+  1024cf:	6a 00                	push   $0x0
+  pushl $154
+  1024d1:	68 9a 00 00 00       	push   $0x9a
+  jmp __alltraps
+  1024d6:	e9 2a fa ff ff       	jmp    101f05 <__alltraps>
+
+001024db <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+  1024db:	6a 00                	push   $0x0
+  pushl $155
+  1024dd:	68 9b 00 00 00       	push   $0x9b
+  jmp __alltraps
+  1024e2:	e9 1e fa ff ff       	jmp    101f05 <__alltraps>
+
+001024e7 <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+  1024e7:	6a 00                	push   $0x0
+  pushl $156
+  1024e9:	68 9c 00 00 00       	push   $0x9c
+  jmp __alltraps
+  1024ee:	e9 12 fa ff ff       	jmp    101f05 <__alltraps>
+
+001024f3 <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+  1024f3:	6a 00                	push   $0x0
+  pushl $157
+  1024f5:	68 9d 00 00 00       	push   $0x9d
+  jmp __alltraps
+  1024fa:	e9 06 fa ff ff       	jmp    101f05 <__alltraps>
+
+001024ff <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+  1024ff:	6a 00                	push   $0x0
+  pushl $158
+  102501:	68 9e 00 00 00       	push   $0x9e
+  jmp __alltraps
+  102506:	e9 fa f9 ff ff       	jmp    101f05 <__alltraps>
+
+0010250b <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+  10250b:	6a 00                	push   $0x0
+  pushl $159
+  10250d:	68 9f 00 00 00       	push   $0x9f
+  jmp __alltraps
+  102512:	e9 ee f9 ff ff       	jmp    101f05 <__alltraps>
+
+00102517 <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+  102517:	6a 00                	push   $0x0
+  pushl $160
+  102519:	68 a0 00 00 00       	push   $0xa0
+  jmp __alltraps
+  10251e:	e9 e2 f9 ff ff       	jmp    101f05 <__alltraps>
+
+00102523 <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+  102523:	6a 00                	push   $0x0
+  pushl $161
+  102525:	68 a1 00 00 00       	push   $0xa1
+  jmp __alltraps
+  10252a:	e9 d6 f9 ff ff       	jmp    101f05 <__alltraps>
+
+0010252f <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+  10252f:	6a 00                	push   $0x0
+  pushl $162
+  102531:	68 a2 00 00 00       	push   $0xa2
+  jmp __alltraps
+  102536:	e9 ca f9 ff ff       	jmp    101f05 <__alltraps>
+
+0010253b <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+  10253b:	6a 00                	push   $0x0
+  pushl $163
+  10253d:	68 a3 00 00 00       	push   $0xa3
+  jmp __alltraps
+  102542:	e9 be f9 ff ff       	jmp    101f05 <__alltraps>
+
+00102547 <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+  102547:	6a 00                	push   $0x0
+  pushl $164
+  102549:	68 a4 00 00 00       	push   $0xa4
+  jmp __alltraps
+  10254e:	e9 b2 f9 ff ff       	jmp    101f05 <__alltraps>
+
+00102553 <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+  102553:	6a 00                	push   $0x0
+  pushl $165
+  102555:	68 a5 00 00 00       	push   $0xa5
+  jmp __alltraps
+  10255a:	e9 a6 f9 ff ff       	jmp    101f05 <__alltraps>
+
+0010255f <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+  10255f:	6a 00                	push   $0x0
+  pushl $166
+  102561:	68 a6 00 00 00       	push   $0xa6
+  jmp __alltraps
+  102566:	e9 9a f9 ff ff       	jmp    101f05 <__alltraps>
+
+0010256b <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+  10256b:	6a 00                	push   $0x0
+  pushl $167
+  10256d:	68 a7 00 00 00       	push   $0xa7
+  jmp __alltraps
+  102572:	e9 8e f9 ff ff       	jmp    101f05 <__alltraps>
+
+00102577 <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+  102577:	6a 00                	push   $0x0
+  pushl $168
+  102579:	68 a8 00 00 00       	push   $0xa8
+  jmp __alltraps
+  10257e:	e9 82 f9 ff ff       	jmp    101f05 <__alltraps>
+
+00102583 <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+  102583:	6a 00                	push   $0x0
+  pushl $169
+  102585:	68 a9 00 00 00       	push   $0xa9
+  jmp __alltraps
+  10258a:	e9 76 f9 ff ff       	jmp    101f05 <__alltraps>
+
+0010258f <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+  10258f:	6a 00                	push   $0x0
+  pushl $170
+  102591:	68 aa 00 00 00       	push   $0xaa
+  jmp __alltraps
+  102596:	e9 6a f9 ff ff       	jmp    101f05 <__alltraps>
+
+0010259b <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+  10259b:	6a 00                	push   $0x0
+  pushl $171
+  10259d:	68 ab 00 00 00       	push   $0xab
+  jmp __alltraps
+  1025a2:	e9 5e f9 ff ff       	jmp    101f05 <__alltraps>
+
+001025a7 <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+  1025a7:	6a 00                	push   $0x0
+  pushl $172
+  1025a9:	68 ac 00 00 00       	push   $0xac
+  jmp __alltraps
+  1025ae:	e9 52 f9 ff ff       	jmp    101f05 <__alltraps>
+
+001025b3 <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+  1025b3:	6a 00                	push   $0x0
+  pushl $173
+  1025b5:	68 ad 00 00 00       	push   $0xad
+  jmp __alltraps
+  1025ba:	e9 46 f9 ff ff       	jmp    101f05 <__alltraps>
+
+001025bf <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+  1025bf:	6a 00                	push   $0x0
+  pushl $174
+  1025c1:	68 ae 00 00 00       	push   $0xae
+  jmp __alltraps
+  1025c6:	e9 3a f9 ff ff       	jmp    101f05 <__alltraps>
+
+001025cb <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+  1025cb:	6a 00                	push   $0x0
+  pushl $175
+  1025cd:	68 af 00 00 00       	push   $0xaf
+  jmp __alltraps
+  1025d2:	e9 2e f9 ff ff       	jmp    101f05 <__alltraps>
+
+001025d7 <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+  1025d7:	6a 00                	push   $0x0
+  pushl $176
+  1025d9:	68 b0 00 00 00       	push   $0xb0
+  jmp __alltraps
+  1025de:	e9 22 f9 ff ff       	jmp    101f05 <__alltraps>
+
+001025e3 <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+  1025e3:	6a 00                	push   $0x0
+  pushl $177
+  1025e5:	68 b1 00 00 00       	push   $0xb1
+  jmp __alltraps
+  1025ea:	e9 16 f9 ff ff       	jmp    101f05 <__alltraps>
+
+001025ef <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+  1025ef:	6a 00                	push   $0x0
+  pushl $178
+  1025f1:	68 b2 00 00 00       	push   $0xb2
+  jmp __alltraps
+  1025f6:	e9 0a f9 ff ff       	jmp    101f05 <__alltraps>
+
+001025fb <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+  1025fb:	6a 00                	push   $0x0
+  pushl $179
+  1025fd:	68 b3 00 00 00       	push   $0xb3
+  jmp __alltraps
+  102602:	e9 fe f8 ff ff       	jmp    101f05 <__alltraps>
+
+00102607 <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+  102607:	6a 00                	push   $0x0
+  pushl $180
+  102609:	68 b4 00 00 00       	push   $0xb4
+  jmp __alltraps
+  10260e:	e9 f2 f8 ff ff       	jmp    101f05 <__alltraps>
+
+00102613 <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+  102613:	6a 00                	push   $0x0
+  pushl $181
+  102615:	68 b5 00 00 00       	push   $0xb5
+  jmp __alltraps
+  10261a:	e9 e6 f8 ff ff       	jmp    101f05 <__alltraps>
+
+0010261f <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+  10261f:	6a 00                	push   $0x0
+  pushl $182
+  102621:	68 b6 00 00 00       	push   $0xb6
+  jmp __alltraps
+  102626:	e9 da f8 ff ff       	jmp    101f05 <__alltraps>
+
+0010262b <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+  10262b:	6a 00                	push   $0x0
+  pushl $183
+  10262d:	68 b7 00 00 00       	push   $0xb7
+  jmp __alltraps
+  102632:	e9 ce f8 ff ff       	jmp    101f05 <__alltraps>
+
+00102637 <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+  102637:	6a 00                	push   $0x0
+  pushl $184
+  102639:	68 b8 00 00 00       	push   $0xb8
+  jmp __alltraps
+  10263e:	e9 c2 f8 ff ff       	jmp    101f05 <__alltraps>
+
+00102643 <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+  102643:	6a 00                	push   $0x0
+  pushl $185
+  102645:	68 b9 00 00 00       	push   $0xb9
+  jmp __alltraps
+  10264a:	e9 b6 f8 ff ff       	jmp    101f05 <__alltraps>
+
+0010264f <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+  10264f:	6a 00                	push   $0x0
+  pushl $186
+  102651:	68 ba 00 00 00       	push   $0xba
+  jmp __alltraps
+  102656:	e9 aa f8 ff ff       	jmp    101f05 <__alltraps>
+
+0010265b <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+  10265b:	6a 00                	push   $0x0
+  pushl $187
+  10265d:	68 bb 00 00 00       	push   $0xbb
+  jmp __alltraps
+  102662:	e9 9e f8 ff ff       	jmp    101f05 <__alltraps>
+
+00102667 <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+  102667:	6a 00                	push   $0x0
+  pushl $188
+  102669:	68 bc 00 00 00       	push   $0xbc
+  jmp __alltraps
+  10266e:	e9 92 f8 ff ff       	jmp    101f05 <__alltraps>
+
+00102673 <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+  102673:	6a 00                	push   $0x0
+  pushl $189
+  102675:	68 bd 00 00 00       	push   $0xbd
+  jmp __alltraps
+  10267a:	e9 86 f8 ff ff       	jmp    101f05 <__alltraps>
+
+0010267f <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+  10267f:	6a 00                	push   $0x0
+  pushl $190
+  102681:	68 be 00 00 00       	push   $0xbe
+  jmp __alltraps
+  102686:	e9 7a f8 ff ff       	jmp    101f05 <__alltraps>
+
+0010268b <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+  10268b:	6a 00                	push   $0x0
+  pushl $191
+  10268d:	68 bf 00 00 00       	push   $0xbf
+  jmp __alltraps
+  102692:	e9 6e f8 ff ff       	jmp    101f05 <__alltraps>
+
+00102697 <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+  102697:	6a 00                	push   $0x0
+  pushl $192
+  102699:	68 c0 00 00 00       	push   $0xc0
+  jmp __alltraps
+  10269e:	e9 62 f8 ff ff       	jmp    101f05 <__alltraps>
+
+001026a3 <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+  1026a3:	6a 00                	push   $0x0
+  pushl $193
+  1026a5:	68 c1 00 00 00       	push   $0xc1
+  jmp __alltraps
+  1026aa:	e9 56 f8 ff ff       	jmp    101f05 <__alltraps>
+
+001026af <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+  1026af:	6a 00                	push   $0x0
+  pushl $194
+  1026b1:	68 c2 00 00 00       	push   $0xc2
+  jmp __alltraps
+  1026b6:	e9 4a f8 ff ff       	jmp    101f05 <__alltraps>
+
+001026bb <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+  1026bb:	6a 00                	push   $0x0
+  pushl $195
+  1026bd:	68 c3 00 00 00       	push   $0xc3
+  jmp __alltraps
+  1026c2:	e9 3e f8 ff ff       	jmp    101f05 <__alltraps>
+
+001026c7 <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+  1026c7:	6a 00                	push   $0x0
+  pushl $196
+  1026c9:	68 c4 00 00 00       	push   $0xc4
+  jmp __alltraps
+  1026ce:	e9 32 f8 ff ff       	jmp    101f05 <__alltraps>
+
+001026d3 <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+  1026d3:	6a 00                	push   $0x0
+  pushl $197
+  1026d5:	68 c5 00 00 00       	push   $0xc5
+  jmp __alltraps
+  1026da:	e9 26 f8 ff ff       	jmp    101f05 <__alltraps>
+
+001026df <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+  1026df:	6a 00                	push   $0x0
+  pushl $198
+  1026e1:	68 c6 00 00 00       	push   $0xc6
+  jmp __alltraps
+  1026e6:	e9 1a f8 ff ff       	jmp    101f05 <__alltraps>
+
+001026eb <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+  1026eb:	6a 00                	push   $0x0
+  pushl $199
+  1026ed:	68 c7 00 00 00       	push   $0xc7
+  jmp __alltraps
+  1026f2:	e9 0e f8 ff ff       	jmp    101f05 <__alltraps>
+
+001026f7 <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+  1026f7:	6a 00                	push   $0x0
+  pushl $200
+  1026f9:	68 c8 00 00 00       	push   $0xc8
+  jmp __alltraps
+  1026fe:	e9 02 f8 ff ff       	jmp    101f05 <__alltraps>
+
+00102703 <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+  102703:	6a 00                	push   $0x0
+  pushl $201
+  102705:	68 c9 00 00 00       	push   $0xc9
+  jmp __alltraps
+  10270a:	e9 f6 f7 ff ff       	jmp    101f05 <__alltraps>
+
+0010270f <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+  10270f:	6a 00                	push   $0x0
+  pushl $202
+  102711:	68 ca 00 00 00       	push   $0xca
+  jmp __alltraps
+  102716:	e9 ea f7 ff ff       	jmp    101f05 <__alltraps>
+
+0010271b <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+  10271b:	6a 00                	push   $0x0
+  pushl $203
+  10271d:	68 cb 00 00 00       	push   $0xcb
+  jmp __alltraps
+  102722:	e9 de f7 ff ff       	jmp    101f05 <__alltraps>
+
+00102727 <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+  102727:	6a 00                	push   $0x0
+  pushl $204
+  102729:	68 cc 00 00 00       	push   $0xcc
+  jmp __alltraps
+  10272e:	e9 d2 f7 ff ff       	jmp    101f05 <__alltraps>
+
+00102733 <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+  102733:	6a 00                	push   $0x0
+  pushl $205
+  102735:	68 cd 00 00 00       	push   $0xcd
+  jmp __alltraps
+  10273a:	e9 c6 f7 ff ff       	jmp    101f05 <__alltraps>
+
+0010273f <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+  10273f:	6a 00                	push   $0x0
+  pushl $206
+  102741:	68 ce 00 00 00       	push   $0xce
+  jmp __alltraps
+  102746:	e9 ba f7 ff ff       	jmp    101f05 <__alltraps>
+
+0010274b <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+  10274b:	6a 00                	push   $0x0
+  pushl $207
+  10274d:	68 cf 00 00 00       	push   $0xcf
+  jmp __alltraps
+  102752:	e9 ae f7 ff ff       	jmp    101f05 <__alltraps>
+
+00102757 <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+  102757:	6a 00                	push   $0x0
+  pushl $208
+  102759:	68 d0 00 00 00       	push   $0xd0
+  jmp __alltraps
+  10275e:	e9 a2 f7 ff ff       	jmp    101f05 <__alltraps>
+
+00102763 <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+  102763:	6a 00                	push   $0x0
+  pushl $209
+  102765:	68 d1 00 00 00       	push   $0xd1
+  jmp __alltraps
+  10276a:	e9 96 f7 ff ff       	jmp    101f05 <__alltraps>
+
+0010276f <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+  10276f:	6a 00                	push   $0x0
+  pushl $210
+  102771:	68 d2 00 00 00       	push   $0xd2
+  jmp __alltraps
+  102776:	e9 8a f7 ff ff       	jmp    101f05 <__alltraps>
+
+0010277b <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+  10277b:	6a 00                	push   $0x0
+  pushl $211
+  10277d:	68 d3 00 00 00       	push   $0xd3
+  jmp __alltraps
+  102782:	e9 7e f7 ff ff       	jmp    101f05 <__alltraps>
+
+00102787 <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+  102787:	6a 00                	push   $0x0
+  pushl $212
+  102789:	68 d4 00 00 00       	push   $0xd4
+  jmp __alltraps
+  10278e:	e9 72 f7 ff ff       	jmp    101f05 <__alltraps>
+
+00102793 <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+  102793:	6a 00                	push   $0x0
+  pushl $213
+  102795:	68 d5 00 00 00       	push   $0xd5
+  jmp __alltraps
+  10279a:	e9 66 f7 ff ff       	jmp    101f05 <__alltraps>
+
+0010279f <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+  10279f:	6a 00                	push   $0x0
+  pushl $214
+  1027a1:	68 d6 00 00 00       	push   $0xd6
+  jmp __alltraps
+  1027a6:	e9 5a f7 ff ff       	jmp    101f05 <__alltraps>
+
+001027ab <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+  1027ab:	6a 00                	push   $0x0
+  pushl $215
+  1027ad:	68 d7 00 00 00       	push   $0xd7
+  jmp __alltraps
+  1027b2:	e9 4e f7 ff ff       	jmp    101f05 <__alltraps>
+
+001027b7 <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+  1027b7:	6a 00                	push   $0x0
+  pushl $216
+  1027b9:	68 d8 00 00 00       	push   $0xd8
+  jmp __alltraps
+  1027be:	e9 42 f7 ff ff       	jmp    101f05 <__alltraps>
+
+001027c3 <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+  1027c3:	6a 00                	push   $0x0
+  pushl $217
+  1027c5:	68 d9 00 00 00       	push   $0xd9
+  jmp __alltraps
+  1027ca:	e9 36 f7 ff ff       	jmp    101f05 <__alltraps>
+
+001027cf <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+  1027cf:	6a 00                	push   $0x0
+  pushl $218
+  1027d1:	68 da 00 00 00       	push   $0xda
+  jmp __alltraps
+  1027d6:	e9 2a f7 ff ff       	jmp    101f05 <__alltraps>
+
+001027db <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+  1027db:	6a 00                	push   $0x0
+  pushl $219
+  1027dd:	68 db 00 00 00       	push   $0xdb
+  jmp __alltraps
+  1027e2:	e9 1e f7 ff ff       	jmp    101f05 <__alltraps>
+
+001027e7 <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+  1027e7:	6a 00                	push   $0x0
+  pushl $220
+  1027e9:	68 dc 00 00 00       	push   $0xdc
+  jmp __alltraps
+  1027ee:	e9 12 f7 ff ff       	jmp    101f05 <__alltraps>
+
+001027f3 <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+  1027f3:	6a 00                	push   $0x0
+  pushl $221
+  1027f5:	68 dd 00 00 00       	push   $0xdd
+  jmp __alltraps
+  1027fa:	e9 06 f7 ff ff       	jmp    101f05 <__alltraps>
+
+001027ff <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+  1027ff:	6a 00                	push   $0x0
+  pushl $222
+  102801:	68 de 00 00 00       	push   $0xde
+  jmp __alltraps
+  102806:	e9 fa f6 ff ff       	jmp    101f05 <__alltraps>
+
+0010280b <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+  10280b:	6a 00                	push   $0x0
+  pushl $223
+  10280d:	68 df 00 00 00       	push   $0xdf
+  jmp __alltraps
+  102812:	e9 ee f6 ff ff       	jmp    101f05 <__alltraps>
+
+00102817 <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+  102817:	6a 00                	push   $0x0
+  pushl $224
+  102819:	68 e0 00 00 00       	push   $0xe0
+  jmp __alltraps
+  10281e:	e9 e2 f6 ff ff       	jmp    101f05 <__alltraps>
+
+00102823 <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+  102823:	6a 00                	push   $0x0
+  pushl $225
+  102825:	68 e1 00 00 00       	push   $0xe1
+  jmp __alltraps
+  10282a:	e9 d6 f6 ff ff       	jmp    101f05 <__alltraps>
+
+0010282f <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+  10282f:	6a 00                	push   $0x0
+  pushl $226
+  102831:	68 e2 00 00 00       	push   $0xe2
+  jmp __alltraps
+  102836:	e9 ca f6 ff ff       	jmp    101f05 <__alltraps>
+
+0010283b <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+  10283b:	6a 00                	push   $0x0
+  pushl $227
+  10283d:	68 e3 00 00 00       	push   $0xe3
+  jmp __alltraps
+  102842:	e9 be f6 ff ff       	jmp    101f05 <__alltraps>
+
+00102847 <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+  102847:	6a 00                	push   $0x0
+  pushl $228
+  102849:	68 e4 00 00 00       	push   $0xe4
+  jmp __alltraps
+  10284e:	e9 b2 f6 ff ff       	jmp    101f05 <__alltraps>
+
+00102853 <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+  102853:	6a 00                	push   $0x0
+  pushl $229
+  102855:	68 e5 00 00 00       	push   $0xe5
+  jmp __alltraps
+  10285a:	e9 a6 f6 ff ff       	jmp    101f05 <__alltraps>
+
+0010285f <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+  10285f:	6a 00                	push   $0x0
+  pushl $230
+  102861:	68 e6 00 00 00       	push   $0xe6
+  jmp __alltraps
+  102866:	e9 9a f6 ff ff       	jmp    101f05 <__alltraps>
+
+0010286b <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+  10286b:	6a 00                	push   $0x0
+  pushl $231
+  10286d:	68 e7 00 00 00       	push   $0xe7
+  jmp __alltraps
+  102872:	e9 8e f6 ff ff       	jmp    101f05 <__alltraps>
+
+00102877 <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+  102877:	6a 00                	push   $0x0
+  pushl $232
+  102879:	68 e8 00 00 00       	push   $0xe8
+  jmp __alltraps
+  10287e:	e9 82 f6 ff ff       	jmp    101f05 <__alltraps>
+
+00102883 <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+  102883:	6a 00                	push   $0x0
+  pushl $233
+  102885:	68 e9 00 00 00       	push   $0xe9
+  jmp __alltraps
+  10288a:	e9 76 f6 ff ff       	jmp    101f05 <__alltraps>
+
+0010288f <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+  10288f:	6a 00                	push   $0x0
+  pushl $234
+  102891:	68 ea 00 00 00       	push   $0xea
+  jmp __alltraps
+  102896:	e9 6a f6 ff ff       	jmp    101f05 <__alltraps>
+
+0010289b <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+  10289b:	6a 00                	push   $0x0
+  pushl $235
+  10289d:	68 eb 00 00 00       	push   $0xeb
+  jmp __alltraps
+  1028a2:	e9 5e f6 ff ff       	jmp    101f05 <__alltraps>
+
+001028a7 <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+  1028a7:	6a 00                	push   $0x0
+  pushl $236
+  1028a9:	68 ec 00 00 00       	push   $0xec
+  jmp __alltraps
+  1028ae:	e9 52 f6 ff ff       	jmp    101f05 <__alltraps>
+
+001028b3 <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+  1028b3:	6a 00                	push   $0x0
+  pushl $237
+  1028b5:	68 ed 00 00 00       	push   $0xed
+  jmp __alltraps
+  1028ba:	e9 46 f6 ff ff       	jmp    101f05 <__alltraps>
+
+001028bf <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+  1028bf:	6a 00                	push   $0x0
+  pushl $238
+  1028c1:	68 ee 00 00 00       	push   $0xee
+  jmp __alltraps
+  1028c6:	e9 3a f6 ff ff       	jmp    101f05 <__alltraps>
+
+001028cb <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+  1028cb:	6a 00                	push   $0x0
+  pushl $239
+  1028cd:	68 ef 00 00 00       	push   $0xef
+  jmp __alltraps
+  1028d2:	e9 2e f6 ff ff       	jmp    101f05 <__alltraps>
+
+001028d7 <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+  1028d7:	6a 00                	push   $0x0
+  pushl $240
+  1028d9:	68 f0 00 00 00       	push   $0xf0
+  jmp __alltraps
+  1028de:	e9 22 f6 ff ff       	jmp    101f05 <__alltraps>
+
+001028e3 <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+  1028e3:	6a 00                	push   $0x0
+  pushl $241
+  1028e5:	68 f1 00 00 00       	push   $0xf1
+  jmp __alltraps
+  1028ea:	e9 16 f6 ff ff       	jmp    101f05 <__alltraps>
+
+001028ef <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+  1028ef:	6a 00                	push   $0x0
+  pushl $242
+  1028f1:	68 f2 00 00 00       	push   $0xf2
+  jmp __alltraps
+  1028f6:	e9 0a f6 ff ff       	jmp    101f05 <__alltraps>
+
+001028fb <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+  1028fb:	6a 00                	push   $0x0
+  pushl $243
+  1028fd:	68 f3 00 00 00       	push   $0xf3
+  jmp __alltraps
+  102902:	e9 fe f5 ff ff       	jmp    101f05 <__alltraps>
+
+00102907 <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+  102907:	6a 00                	push   $0x0
+  pushl $244
+  102909:	68 f4 00 00 00       	push   $0xf4
+  jmp __alltraps
+  10290e:	e9 f2 f5 ff ff       	jmp    101f05 <__alltraps>
+
+00102913 <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+  102913:	6a 00                	push   $0x0
+  pushl $245
+  102915:	68 f5 00 00 00       	push   $0xf5
+  jmp __alltraps
+  10291a:	e9 e6 f5 ff ff       	jmp    101f05 <__alltraps>
+
+0010291f <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+  10291f:	6a 00                	push   $0x0
+  pushl $246
+  102921:	68 f6 00 00 00       	push   $0xf6
+  jmp __alltraps
+  102926:	e9 da f5 ff ff       	jmp    101f05 <__alltraps>
+
+0010292b <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+  10292b:	6a 00                	push   $0x0
+  pushl $247
+  10292d:	68 f7 00 00 00       	push   $0xf7
+  jmp __alltraps
+  102932:	e9 ce f5 ff ff       	jmp    101f05 <__alltraps>
+
+00102937 <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+  102937:	6a 00                	push   $0x0
+  pushl $248
+  102939:	68 f8 00 00 00       	push   $0xf8
+  jmp __alltraps
+  10293e:	e9 c2 f5 ff ff       	jmp    101f05 <__alltraps>
+
+00102943 <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+  102943:	6a 00                	push   $0x0
+  pushl $249
+  102945:	68 f9 00 00 00       	push   $0xf9
+  jmp __alltraps
+  10294a:	e9 b6 f5 ff ff       	jmp    101f05 <__alltraps>
+
+0010294f <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+  10294f:	6a 00                	push   $0x0
+  pushl $250
+  102951:	68 fa 00 00 00       	push   $0xfa
+  jmp __alltraps
+  102956:	e9 aa f5 ff ff       	jmp    101f05 <__alltraps>
+
+0010295b <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+  10295b:	6a 00                	push   $0x0
+  pushl $251
+  10295d:	68 fb 00 00 00       	push   $0xfb
+  jmp __alltraps
+  102962:	e9 9e f5 ff ff       	jmp    101f05 <__alltraps>
+
+00102967 <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+  102967:	6a 00                	push   $0x0
+  pushl $252
+  102969:	68 fc 00 00 00       	push   $0xfc
+  jmp __alltraps
+  10296e:	e9 92 f5 ff ff       	jmp    101f05 <__alltraps>
+
+00102973 <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+  102973:	6a 00                	push   $0x0
+  pushl $253
+  102975:	68 fd 00 00 00       	push   $0xfd
+  jmp __alltraps
+  10297a:	e9 86 f5 ff ff       	jmp    101f05 <__alltraps>
+
+0010297f <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+  10297f:	6a 00                	push   $0x0
+  pushl $254
+  102981:	68 fe 00 00 00       	push   $0xfe
+  jmp __alltraps
+  102986:	e9 7a f5 ff ff       	jmp    101f05 <__alltraps>
+
+0010298b <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+  10298b:	6a 00                	push   $0x0
+  pushl $255
+  10298d:	68 ff 00 00 00       	push   $0xff
+  jmp __alltraps
+  102992:	e9 6e f5 ff ff       	jmp    101f05 <__alltraps>
+
+00102997 <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+  102997:	55                   	push   %ebp
+  102998:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+  10299a:	8b 55 08             	mov    0x8(%ebp),%edx
+  10299d:	a1 c4 89 11 00       	mov    0x1189c4,%eax
+  1029a2:	29 c2                	sub    %eax,%edx
+  1029a4:	89 d0                	mov    %edx,%eax
+  1029a6:	c1 f8 02             	sar    $0x2,%eax
+  1029a9:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
+}
+  1029af:	5d                   	pop    %ebp
+  1029b0:	c3                   	ret    
+
+001029b1 <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+  1029b1:	55                   	push   %ebp
+  1029b2:	89 e5                	mov    %esp,%ebp
+  1029b4:	83 ec 04             	sub    $0x4,%esp
+    return page2ppn(page) << PGSHIFT;
+  1029b7:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029ba:	89 04 24             	mov    %eax,(%esp)
+  1029bd:	e8 d5 ff ff ff       	call   102997 <page2ppn>
+  1029c2:	c1 e0 0c             	shl    $0xc,%eax
+}
+  1029c5:	c9                   	leave  
+  1029c6:	c3                   	ret    
+
+001029c7 <page_ref>:
+pde2page(pde_t pde) {
+    return pa2page(PDE_ADDR(pde));
+}
+
+static inline int
+page_ref(struct Page *page) {
+  1029c7:	55                   	push   %ebp
+  1029c8:	89 e5                	mov    %esp,%ebp
+    return page->ref;
+  1029ca:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029cd:	8b 00                	mov    (%eax),%eax
+}
+  1029cf:	5d                   	pop    %ebp
+  1029d0:	c3                   	ret    
+
+001029d1 <set_page_ref>:
+
+static inline void
+set_page_ref(struct Page *page, int val) {
+  1029d1:	55                   	push   %ebp
+  1029d2:	89 e5                	mov    %esp,%ebp
+    page->ref = val;
+  1029d4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029d7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  1029da:	89 10                	mov    %edx,(%eax)
+}
+  1029dc:	5d                   	pop    %ebp
+  1029dd:	c3                   	ret    
+
+001029de <default_init>:
+
+#define free_list (free_area.free_list)
+#define nr_free (free_area.nr_free)
+
+static void
+default_init(void) {
+  1029de:	55                   	push   %ebp
+  1029df:	89 e5                	mov    %esp,%ebp
+  1029e1:	83 ec 10             	sub    $0x10,%esp
+  1029e4:	c7 45 fc b0 89 11 00 	movl   $0x1189b0,-0x4(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+  1029eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1029ee:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  1029f1:	89 50 04             	mov    %edx,0x4(%eax)
+  1029f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1029f7:	8b 50 04             	mov    0x4(%eax),%edx
+  1029fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1029fd:	89 10                	mov    %edx,(%eax)
+    list_init(&free_list);
+    nr_free = 0;
+  1029ff:	c7 05 b8 89 11 00 00 	movl   $0x0,0x1189b8
+  102a06:	00 00 00 
+}
+  102a09:	c9                   	leave  
+  102a0a:	c3                   	ret    
+
+00102a0b <default_init_memmap>:
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+  102a0b:	55                   	push   %ebp
+  102a0c:	89 e5                	mov    %esp,%ebp
+  102a0e:	83 ec 48             	sub    $0x48,%esp
+    assert(n > 0);
+  102a11:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  102a15:	75 24                	jne    102a3b <default_init_memmap+0x30>
+  102a17:	c7 44 24 0c 90 67 10 	movl   $0x106790,0xc(%esp)
+  102a1e:	00 
+  102a1f:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  102a26:	00 
+  102a27:	c7 44 24 04 46 00 00 	movl   $0x46,0x4(%esp)
+  102a2e:	00 
+  102a2f:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  102a36:	e8 85 e2 ff ff       	call   100cc0 <__panic>
+    struct Page *p = base;
+  102a3b:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    for (; p != base + n; p ++) {
+  102a41:	e9 de 00 00 00       	jmp    102b24 <default_init_memmap+0x119>
+        assert(PageReserved(p));
+  102a46:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102a49:	83 c0 04             	add    $0x4,%eax
+  102a4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  102a53:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+  102a56:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102a59:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  102a5c:	0f a3 10             	bt     %edx,(%eax)
+  102a5f:	19 c0                	sbb    %eax,%eax
+  102a61:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    return oldbit != 0;
+  102a64:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  102a68:	0f 95 c0             	setne  %al
+  102a6b:	0f b6 c0             	movzbl %al,%eax
+  102a6e:	85 c0                	test   %eax,%eax
+  102a70:	75 24                	jne    102a96 <default_init_memmap+0x8b>
+  102a72:	c7 44 24 0c c1 67 10 	movl   $0x1067c1,0xc(%esp)
+  102a79:	00 
+  102a7a:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  102a81:	00 
+  102a82:	c7 44 24 04 49 00 00 	movl   $0x49,0x4(%esp)
+  102a89:	00 
+  102a8a:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  102a91:	e8 2a e2 ff ff       	call   100cc0 <__panic>
+        p->flags = p->property = 0;
+  102a96:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102a99:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+  102aa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102aa3:	8b 50 08             	mov    0x8(%eax),%edx
+  102aa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102aa9:	89 50 04             	mov    %edx,0x4(%eax)
+	SetPageProperty(p); //#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
+  102aac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102aaf:	83 c0 04             	add    $0x4,%eax
+  102ab2:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
+  102ab9:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+  102abc:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  102abf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  102ac2:	0f ab 10             	bts    %edx,(%eax)
+        set_page_ref(p, 0);
+  102ac5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  102acc:	00 
+  102acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102ad0:	89 04 24             	mov    %eax,(%esp)
+  102ad3:	e8 f9 fe ff ff       	call   1029d1 <set_page_ref>
+	list_add_before(&free_list, &(p->page_link));
+  102ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102adb:	83 c0 0c             	add    $0xc,%eax
+  102ade:	c7 45 dc b0 89 11 00 	movl   $0x1189b0,-0x24(%ebp)
+  102ae5:	89 45 d8             	mov    %eax,-0x28(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+  102ae8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102aeb:	8b 00                	mov    (%eax),%eax
+  102aed:	8b 55 d8             	mov    -0x28(%ebp),%edx
+  102af0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  102af3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  102af6:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102af9:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+  102afc:	8b 45 cc             	mov    -0x34(%ebp),%eax
+  102aff:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  102b02:	89 10                	mov    %edx,(%eax)
+  102b04:	8b 45 cc             	mov    -0x34(%ebp),%eax
+  102b07:	8b 10                	mov    (%eax),%edx
+  102b09:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  102b0c:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+  102b0f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  102b12:	8b 55 cc             	mov    -0x34(%ebp),%edx
+  102b15:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+  102b18:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  102b1b:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  102b1e:	89 10                	mov    %edx,(%eax)
+
+static void
+default_init_memmap(struct Page *base, size_t n) {
+    assert(n > 0);
+    struct Page *p = base;
+    for (; p != base + n; p ++) {
+  102b20:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
+  102b24:	8b 55 0c             	mov    0xc(%ebp),%edx
+  102b27:	89 d0                	mov    %edx,%eax
+  102b29:	c1 e0 02             	shl    $0x2,%eax
+  102b2c:	01 d0                	add    %edx,%eax
+  102b2e:	c1 e0 02             	shl    $0x2,%eax
+  102b31:	89 c2                	mov    %eax,%edx
+  102b33:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b36:	01 d0                	add    %edx,%eax
+  102b38:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  102b3b:	0f 85 05 ff ff ff    	jne    102a46 <default_init_memmap+0x3b>
+        p->flags = p->property = 0;
+	SetPageProperty(p); //#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
+        set_page_ref(p, 0);
+	list_add_before(&free_list, &(p->page_link));
+    }
+    base->property = n;
+  102b41:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b44:	8b 55 0c             	mov    0xc(%ebp),%edx
+  102b47:	89 50 08             	mov    %edx,0x8(%eax)
+    //SetPageProperty(base);
+    nr_free += n;
+  102b4a:	8b 15 b8 89 11 00    	mov    0x1189b8,%edx
+  102b50:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102b53:	01 d0                	add    %edx,%eax
+  102b55:	a3 b8 89 11 00       	mov    %eax,0x1189b8
+    //list_add(&free_list, &(base->page_link));
+}
+  102b5a:	c9                   	leave  
+  102b5b:	c3                   	ret    
+
+00102b5c <default_alloc_pages>:
+
+static struct Page *
+default_alloc_pages(size_t n) {
+  102b5c:	55                   	push   %ebp
+  102b5d:	89 e5                	mov    %esp,%ebp
+  102b5f:	83 ec 68             	sub    $0x68,%esp
+    assert(n > 0);
+  102b62:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  102b66:	75 24                	jne    102b8c <default_alloc_pages+0x30>
+  102b68:	c7 44 24 0c 90 67 10 	movl   $0x106790,0xc(%esp)
+  102b6f:	00 
+  102b70:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  102b77:	00 
+  102b78:	c7 44 24 04 57 00 00 	movl   $0x57,0x4(%esp)
+  102b7f:	00 
+  102b80:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  102b87:	e8 34 e1 ff ff       	call   100cc0 <__panic>
+    if (n > nr_free) {
+  102b8c:	a1 b8 89 11 00       	mov    0x1189b8,%eax
+  102b91:	3b 45 08             	cmp    0x8(%ebp),%eax
+  102b94:	73 0a                	jae    102ba0 <default_alloc_pages+0x44>
+        return NULL;
+  102b96:	b8 00 00 00 00       	mov    $0x0,%eax
+  102b9b:	e9 37 01 00 00       	jmp    102cd7 <default_alloc_pages+0x17b>
+    }
+    list_entry_t *le = &free_list;
+  102ba0:	c7 45 f4 b0 89 11 00 	movl   $0x1189b0,-0xc(%ebp)
+    list_entry_t *len;
+    while ((le = list_next(le)) != &free_list) {
+  102ba7:	e9 0a 01 00 00       	jmp    102cb6 <default_alloc_pages+0x15a>
+        struct Page *p = le2page(le, page_link);
+  102bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102baf:	83 e8 0c             	sub    $0xc,%eax
+  102bb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        if (p->property >= n) {
+  102bb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102bb8:	8b 40 08             	mov    0x8(%eax),%eax
+  102bbb:	3b 45 08             	cmp    0x8(%ebp),%eax
+  102bbe:	0f 82 f2 00 00 00    	jb     102cb6 <default_alloc_pages+0x15a>
+		int i;
+		for(i=0;i<n;i++){
+  102bc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  102bcb:	eb 7c                	jmp    102c49 <default_alloc_pages+0xed>
+  102bcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102bd0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+  102bd3:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  102bd6:	8b 40 04             	mov    0x4(%eax),%eax
+		  len = list_next(le);
+  102bd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
+		  struct Page *pp = le2page(le, page_link);
+  102bdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102bdf:	83 e8 0c             	sub    $0xc,%eax
+  102be2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		  SetPageReserved(pp);
+  102be5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  102be8:	83 c0 04             	add    $0x4,%eax
+  102beb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  102bf2:	89 45 d8             	mov    %eax,-0x28(%ebp)
+  102bf5:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  102bf8:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  102bfb:	0f ab 10             	bts    %edx,(%eax)
+		  ClearPageProperty(pp);
+  102bfe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  102c01:	83 c0 04             	add    $0x4,%eax
+  102c04:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
+  102c0b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ * @nr:     the bit to clear
+ * @addr:   the address to start counting from
+ * */
+static inline void
+clear_bit(int nr, volatile void *addr) {
+    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+  102c0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  102c11:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  102c14:	0f b3 10             	btr    %edx,(%eax)
+  102c17:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102c1a:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * Note: list_empty() on @listelm does not return true after this, the entry is
+ * in an undefined state.
+ * */
+static inline void
+list_del(list_entry_t *listelm) {
+    __list_del(listelm->prev, listelm->next);
+  102c1d:	8b 45 cc             	mov    -0x34(%ebp),%eax
+  102c20:	8b 40 04             	mov    0x4(%eax),%eax
+  102c23:	8b 55 cc             	mov    -0x34(%ebp),%edx
+  102c26:	8b 12                	mov    (%edx),%edx
+  102c28:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  102c2b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_del(list_entry_t *prev, list_entry_t *next) {
+    prev->next = next;
+  102c2e:	8b 45 c8             	mov    -0x38(%ebp),%eax
+  102c31:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+  102c34:	89 50 04             	mov    %edx,0x4(%eax)
+    next->prev = prev;
+  102c37:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+  102c3a:	8b 55 c8             	mov    -0x38(%ebp),%edx
+  102c3d:	89 10                	mov    %edx,(%eax)
+		  list_del(le);
+		  le = len;
+  102c3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102c42:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    list_entry_t *len;
+    while ((le = list_next(le)) != &free_list) {
+        struct Page *p = le2page(le, page_link);
+        if (p->property >= n) {
+		int i;
+		for(i=0;i<n;i++){
+  102c45:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  102c49:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102c4c:	3b 45 08             	cmp    0x8(%ebp),%eax
+  102c4f:	0f 82 78 ff ff ff    	jb     102bcd <default_alloc_pages+0x71>
+		  SetPageReserved(pp);
+		  ClearPageProperty(pp);
+		  list_del(le);
+		  le = len;
+		}
+		if(p->property>n){
+  102c55:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102c58:	8b 40 08             	mov    0x8(%eax),%eax
+  102c5b:	3b 45 08             	cmp    0x8(%ebp),%eax
+  102c5e:	76 12                	jbe    102c72 <default_alloc_pages+0x116>
+		  (le2page(le,page_link))->property = p->property - n;
+  102c60:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102c63:	8d 50 f4             	lea    -0xc(%eax),%edx
+  102c66:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102c69:	8b 40 08             	mov    0x8(%eax),%eax
+  102c6c:	2b 45 08             	sub    0x8(%ebp),%eax
+  102c6f:	89 42 08             	mov    %eax,0x8(%edx)
+		}
+		ClearPageProperty(p);
+  102c72:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102c75:	83 c0 04             	add    $0x4,%eax
+  102c78:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%ebp)
+  102c7f:	89 45 bc             	mov    %eax,-0x44(%ebp)
+  102c82:	8b 45 bc             	mov    -0x44(%ebp),%eax
+  102c85:	8b 55 c0             	mov    -0x40(%ebp),%edx
+  102c88:	0f b3 10             	btr    %edx,(%eax)
+		SetPageReserved(p);
+  102c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102c8e:	83 c0 04             	add    $0x4,%eax
+  102c91:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
+  102c98:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+  102c9b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+  102c9e:	8b 55 b8             	mov    -0x48(%ebp),%edx
+  102ca1:	0f ab 10             	bts    %edx,(%eax)
+		nr_free -= n;
+  102ca4:	a1 b8 89 11 00       	mov    0x1189b8,%eax
+  102ca9:	2b 45 08             	sub    0x8(%ebp),%eax
+  102cac:	a3 b8 89 11 00       	mov    %eax,0x1189b8
+		return p;
+  102cb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102cb4:	eb 21                	jmp    102cd7 <default_alloc_pages+0x17b>
+  102cb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102cb9:	89 45 b0             	mov    %eax,-0x50(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+  102cbc:	8b 45 b0             	mov    -0x50(%ebp),%eax
+  102cbf:	8b 40 04             	mov    0x4(%eax),%eax
+    if (n > nr_free) {
+        return NULL;
+    }
+    list_entry_t *le = &free_list;
+    list_entry_t *len;
+    while ((le = list_next(le)) != &free_list) {
+  102cc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102cc5:	81 7d f4 b0 89 11 00 	cmpl   $0x1189b0,-0xc(%ebp)
+  102ccc:	0f 85 da fe ff ff    	jne    102bac <default_alloc_pages+0x50>
+		SetPageReserved(p);
+		nr_free -= n;
+		return p;
+        }
+    }
+    return	NULL;
+  102cd2:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  102cd7:	c9                   	leave  
+  102cd8:	c3                   	ret    
+
+00102cd9 <default_free_pages>:
+
+static void
+default_free_pages(struct Page *base, size_t n) {
+  102cd9:	55                   	push   %ebp
+  102cda:	89 e5                	mov    %esp,%ebp
+  102cdc:	83 ec 68             	sub    $0x68,%esp
+    assert(n > 0);
+  102cdf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  102ce3:	75 24                	jne    102d09 <default_free_pages+0x30>
+  102ce5:	c7 44 24 0c 90 67 10 	movl   $0x106790,0xc(%esp)
+  102cec:	00 
+  102ced:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  102cf4:	00 
+  102cf5:	c7 44 24 04 77 00 00 	movl   $0x77,0x4(%esp)
+  102cfc:	00 
+  102cfd:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  102d04:	e8 b7 df ff ff       	call   100cc0 <__panic>
+    assert(PageReserved(base));
+  102d09:	8b 45 08             	mov    0x8(%ebp),%eax
+  102d0c:	83 c0 04             	add    $0x4,%eax
+  102d0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  102d16:	89 45 e8             	mov    %eax,-0x18(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+  102d19:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102d1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  102d1f:	0f a3 10             	bt     %edx,(%eax)
+  102d22:	19 c0                	sbb    %eax,%eax
+  102d24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    return oldbit != 0;
+  102d27:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  102d2b:	0f 95 c0             	setne  %al
+  102d2e:	0f b6 c0             	movzbl %al,%eax
+  102d31:	85 c0                	test   %eax,%eax
+  102d33:	75 24                	jne    102d59 <default_free_pages+0x80>
+  102d35:	c7 44 24 0c d1 67 10 	movl   $0x1067d1,0xc(%esp)
+  102d3c:	00 
+  102d3d:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  102d44:	00 
+  102d45:	c7 44 24 04 78 00 00 	movl   $0x78,0x4(%esp)
+  102d4c:	00 
+  102d4d:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  102d54:	e8 67 df ff ff       	call   100cc0 <__panic>
+
+    list_entry_t *le = &free_list;
+  102d59:	c7 45 f4 b0 89 11 00 	movl   $0x1189b0,-0xc(%ebp)
+    struct Page * p;
+    while((le=list_next(le)) != &free_list) {
+  102d60:	eb 13                	jmp    102d75 <default_free_pages+0x9c>
+      p = le2page(le, page_link);
+  102d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102d65:	83 e8 0c             	sub    $0xc,%eax
+  102d68:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      if(p>base){
+  102d6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102d6e:	3b 45 08             	cmp    0x8(%ebp),%eax
+  102d71:	76 02                	jbe    102d75 <default_free_pages+0x9c>
+        break;
+  102d73:	eb 18                	jmp    102d8d <default_free_pages+0xb4>
+  102d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102d78:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  102d7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  102d7e:	8b 40 04             	mov    0x4(%eax),%eax
+    assert(n > 0);
+    assert(PageReserved(base));
+
+    list_entry_t *le = &free_list;
+    struct Page * p;
+    while((le=list_next(le)) != &free_list) {
+  102d81:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102d84:	81 7d f4 b0 89 11 00 	cmpl   $0x1189b0,-0xc(%ebp)
+  102d8b:	75 d5                	jne    102d62 <default_free_pages+0x89>
+      if(p>base){
+        break;
+      }
+    }
+    //list_add_before(le, base->page_link);
+    for(p=base;p<base+n;p++){
+  102d8d:	8b 45 08             	mov    0x8(%ebp),%eax
+  102d90:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102d93:	eb 4b                	jmp    102de0 <default_free_pages+0x107>
+      list_add_before(le, &(p->page_link));
+  102d95:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102d98:	8d 50 0c             	lea    0xc(%eax),%edx
+  102d9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102d9e:	89 45 dc             	mov    %eax,-0x24(%ebp)
+  102da1:	89 55 d8             	mov    %edx,-0x28(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
+ * is already in the list.
+ * */
+static inline void
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+  102da4:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102da7:	8b 00                	mov    (%eax),%eax
+  102da9:	8b 55 d8             	mov    -0x28(%ebp),%edx
+  102dac:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  102daf:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  102db2:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102db5:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ * */
+static inline void
+__list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
+    prev->next = next->prev = elm;
+  102db8:	8b 45 cc             	mov    -0x34(%ebp),%eax
+  102dbb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  102dbe:	89 10                	mov    %edx,(%eax)
+  102dc0:	8b 45 cc             	mov    -0x34(%ebp),%eax
+  102dc3:	8b 10                	mov    (%eax),%edx
+  102dc5:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  102dc8:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->next = next;
+  102dcb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  102dce:	8b 55 cc             	mov    -0x34(%ebp),%edx
+  102dd1:	89 50 04             	mov    %edx,0x4(%eax)
+    elm->prev = prev;
+  102dd4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  102dd7:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  102dda:	89 10                	mov    %edx,(%eax)
+      if(p>base){
+        break;
+      }
+    }
+    //list_add_before(le, base->page_link);
+    for(p=base;p<base+n;p++){
+  102ddc:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)
+  102de0:	8b 55 0c             	mov    0xc(%ebp),%edx
+  102de3:	89 d0                	mov    %edx,%eax
+  102de5:	c1 e0 02             	shl    $0x2,%eax
+  102de8:	01 d0                	add    %edx,%eax
+  102dea:	c1 e0 02             	shl    $0x2,%eax
+  102ded:	89 c2                	mov    %eax,%edx
+  102def:	8b 45 08             	mov    0x8(%ebp),%eax
+  102df2:	01 d0                	add    %edx,%eax
+  102df4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  102df7:	77 9c                	ja     102d95 <default_free_pages+0xbc>
+      list_add_before(le, &(p->page_link));
+    }
+    base->flags = 0;
+  102df9:	8b 45 08             	mov    0x8(%ebp),%eax
+  102dfc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    set_page_ref(base, 0);
+  102e03:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  102e0a:	00 
+  102e0b:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e0e:	89 04 24             	mov    %eax,(%esp)
+  102e11:	e8 bb fb ff ff       	call   1029d1 <set_page_ref>
+    ClearPageProperty(base);
+  102e16:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e19:	83 c0 04             	add    $0x4,%eax
+  102e1c:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
+  102e23:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+ * @nr:     the bit to clear
+ * @addr:   the address to start counting from
+ * */
+static inline void
+clear_bit(int nr, volatile void *addr) {
+    asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+  102e26:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+  102e29:	8b 55 c8             	mov    -0x38(%ebp),%edx
+  102e2c:	0f b3 10             	btr    %edx,(%eax)
+    SetPageProperty(base);
+  102e2f:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e32:	83 c0 04             	add    $0x4,%eax
+  102e35:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%ebp)
+  102e3c:	89 45 bc             	mov    %eax,-0x44(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+  102e3f:	8b 45 bc             	mov    -0x44(%ebp),%eax
+  102e42:	8b 55 c0             	mov    -0x40(%ebp),%edx
+  102e45:	0f ab 10             	bts    %edx,(%eax)
+    base->property = n;
+  102e48:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e4b:	8b 55 0c             	mov    0xc(%ebp),%edx
+  102e4e:	89 50 08             	mov    %edx,0x8(%eax)
+
+    p = le2page(le,page_link) ;
+  102e51:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102e54:	83 e8 0c             	sub    $0xc,%eax
+  102e57:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if( base+n == p ){
+  102e5a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  102e5d:	89 d0                	mov    %edx,%eax
+  102e5f:	c1 e0 02             	shl    $0x2,%eax
+  102e62:	01 d0                	add    %edx,%eax
+  102e64:	c1 e0 02             	shl    $0x2,%eax
+  102e67:	89 c2                	mov    %eax,%edx
+  102e69:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e6c:	01 d0                	add    %edx,%eax
+  102e6e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  102e71:	75 1e                	jne    102e91 <default_free_pages+0x1b8>
+      base->property += p->property;
+  102e73:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e76:	8b 50 08             	mov    0x8(%eax),%edx
+  102e79:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102e7c:	8b 40 08             	mov    0x8(%eax),%eax
+  102e7f:	01 c2                	add    %eax,%edx
+  102e81:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e84:	89 50 08             	mov    %edx,0x8(%eax)
+      p->property = 0;
+  102e87:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102e8a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+    }
+    le = list_prev(&(base->page_link));
+  102e91:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e94:	83 c0 0c             	add    $0xc,%eax
+  102e97:	89 45 b8             	mov    %eax,-0x48(%ebp)
+ * list_prev - get the previous entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_prev(list_entry_t *listelm) {
+    return listelm->prev;
+  102e9a:	8b 45 b8             	mov    -0x48(%ebp),%eax
+  102e9d:	8b 00                	mov    (%eax),%eax
+  102e9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    p = le2page(le, page_link);
+  102ea2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102ea5:	83 e8 0c             	sub    $0xc,%eax
+  102ea8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(le!=&free_list && p==base-1){
+  102eab:	81 7d f4 b0 89 11 00 	cmpl   $0x1189b0,-0xc(%ebp)
+  102eb2:	74 57                	je     102f0b <default_free_pages+0x232>
+  102eb4:	8b 45 08             	mov    0x8(%ebp),%eax
+  102eb7:	83 e8 14             	sub    $0x14,%eax
+  102eba:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  102ebd:	75 4c                	jne    102f0b <default_free_pages+0x232>
+      while(le!=&free_list){
+  102ebf:	eb 41                	jmp    102f02 <default_free_pages+0x229>
+        if(p->property){
+  102ec1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102ec4:	8b 40 08             	mov    0x8(%eax),%eax
+  102ec7:	85 c0                	test   %eax,%eax
+  102ec9:	74 20                	je     102eeb <default_free_pages+0x212>
+          p->property += base->property;
+  102ecb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102ece:	8b 50 08             	mov    0x8(%eax),%edx
+  102ed1:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ed4:	8b 40 08             	mov    0x8(%eax),%eax
+  102ed7:	01 c2                	add    %eax,%edx
+  102ed9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102edc:	89 50 08             	mov    %edx,0x8(%eax)
+          base->property = 0;
+  102edf:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ee2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+          break;
+  102ee9:	eb 20                	jmp    102f0b <default_free_pages+0x232>
+  102eeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102eee:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+  102ef1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+  102ef4:	8b 00                	mov    (%eax),%eax
+        }
+        le = list_prev(le);
+  102ef6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        p = le2page(le,page_link);
+  102ef9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102efc:	83 e8 0c             	sub    $0xc,%eax
+  102eff:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      p->property = 0;
+    }
+    le = list_prev(&(base->page_link));
+    p = le2page(le, page_link);
+    if(le!=&free_list && p==base-1){
+      while(le!=&free_list){
+  102f02:	81 7d f4 b0 89 11 00 	cmpl   $0x1189b0,-0xc(%ebp)
+  102f09:	75 b6                	jne    102ec1 <default_free_pages+0x1e8>
+        le = list_prev(le);
+        p = le2page(le,page_link);
+      }
+    }
+
+    nr_free += n;
+  102f0b:	8b 15 b8 89 11 00    	mov    0x1189b8,%edx
+  102f11:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102f14:	01 d0                	add    %edx,%eax
+  102f16:	a3 b8 89 11 00       	mov    %eax,0x1189b8
+    return ;
+  102f1b:	90                   	nop
+}
+  102f1c:	c9                   	leave  
+  102f1d:	c3                   	ret    
+
+00102f1e <default_nr_free_pages>:
+
+static size_t
+default_nr_free_pages(void) {
+  102f1e:	55                   	push   %ebp
+  102f1f:	89 e5                	mov    %esp,%ebp
+    return nr_free;
+  102f21:	a1 b8 89 11 00       	mov    0x1189b8,%eax
+}
+  102f26:	5d                   	pop    %ebp
+  102f27:	c3                   	ret    
+
+00102f28 <basic_check>:
+
+static void
+basic_check(void) {
+  102f28:	55                   	push   %ebp
+  102f29:	89 e5                	mov    %esp,%ebp
+  102f2b:	83 ec 48             	sub    $0x48,%esp
+    struct Page *p0, *p1, *p2;
+    p0 = p1 = p2 = NULL;
+  102f2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  102f35:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102f38:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102f3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102f3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    assert((p0 = alloc_page()) != NULL);
+  102f41:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  102f48:	e8 85 0e 00 00       	call   103dd2 <alloc_pages>
+  102f4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  102f50:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+  102f54:	75 24                	jne    102f7a <basic_check+0x52>
+  102f56:	c7 44 24 0c e4 67 10 	movl   $0x1067e4,0xc(%esp)
+  102f5d:	00 
+  102f5e:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  102f65:	00 
+  102f66:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
+  102f6d:	00 
+  102f6e:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  102f75:	e8 46 dd ff ff       	call   100cc0 <__panic>
+    assert((p1 = alloc_page()) != NULL);
+  102f7a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  102f81:	e8 4c 0e 00 00       	call   103dd2 <alloc_pages>
+  102f86:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102f89:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  102f8d:	75 24                	jne    102fb3 <basic_check+0x8b>
+  102f8f:	c7 44 24 0c 00 68 10 	movl   $0x106800,0xc(%esp)
+  102f96:	00 
+  102f97:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  102f9e:	00 
+  102f9f:	c7 44 24 04 ad 00 00 	movl   $0xad,0x4(%esp)
+  102fa6:	00 
+  102fa7:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  102fae:	e8 0d dd ff ff       	call   100cc0 <__panic>
+    assert((p2 = alloc_page()) != NULL);
+  102fb3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  102fba:	e8 13 0e 00 00       	call   103dd2 <alloc_pages>
+  102fbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102fc2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  102fc6:	75 24                	jne    102fec <basic_check+0xc4>
+  102fc8:	c7 44 24 0c 1c 68 10 	movl   $0x10681c,0xc(%esp)
+  102fcf:	00 
+  102fd0:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  102fd7:	00 
+  102fd8:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
+  102fdf:	00 
+  102fe0:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  102fe7:	e8 d4 dc ff ff       	call   100cc0 <__panic>
+
+    assert(p0 != p1 && p0 != p2 && p1 != p2);
+  102fec:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102fef:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  102ff2:	74 10                	je     103004 <basic_check+0xdc>
+  102ff4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102ff7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  102ffa:	74 08                	je     103004 <basic_check+0xdc>
+  102ffc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102fff:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  103002:	75 24                	jne    103028 <basic_check+0x100>
+  103004:	c7 44 24 0c 38 68 10 	movl   $0x106838,0xc(%esp)
+  10300b:	00 
+  10300c:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103013:	00 
+  103014:	c7 44 24 04 b0 00 00 	movl   $0xb0,0x4(%esp)
+  10301b:	00 
+  10301c:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103023:	e8 98 dc ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
+  103028:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  10302b:	89 04 24             	mov    %eax,(%esp)
+  10302e:	e8 94 f9 ff ff       	call   1029c7 <page_ref>
+  103033:	85 c0                	test   %eax,%eax
+  103035:	75 1e                	jne    103055 <basic_check+0x12d>
+  103037:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10303a:	89 04 24             	mov    %eax,(%esp)
+  10303d:	e8 85 f9 ff ff       	call   1029c7 <page_ref>
+  103042:	85 c0                	test   %eax,%eax
+  103044:	75 0f                	jne    103055 <basic_check+0x12d>
+  103046:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  103049:	89 04 24             	mov    %eax,(%esp)
+  10304c:	e8 76 f9 ff ff       	call   1029c7 <page_ref>
+  103051:	85 c0                	test   %eax,%eax
+  103053:	74 24                	je     103079 <basic_check+0x151>
+  103055:	c7 44 24 0c 5c 68 10 	movl   $0x10685c,0xc(%esp)
+  10305c:	00 
+  10305d:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103064:	00 
+  103065:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
+  10306c:	00 
+  10306d:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103074:	e8 47 dc ff ff       	call   100cc0 <__panic>
+
+    assert(page2pa(p0) < npage * PGSIZE);
+  103079:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  10307c:	89 04 24             	mov    %eax,(%esp)
+  10307f:	e8 2d f9 ff ff       	call   1029b1 <page2pa>
+  103084:	8b 15 c0 88 11 00    	mov    0x1188c0,%edx
+  10308a:	c1 e2 0c             	shl    $0xc,%edx
+  10308d:	39 d0                	cmp    %edx,%eax
+  10308f:	72 24                	jb     1030b5 <basic_check+0x18d>
+  103091:	c7 44 24 0c 98 68 10 	movl   $0x106898,0xc(%esp)
+  103098:	00 
+  103099:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1030a0:	00 
+  1030a1:	c7 44 24 04 b3 00 00 	movl   $0xb3,0x4(%esp)
+  1030a8:	00 
+  1030a9:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1030b0:	e8 0b dc ff ff       	call   100cc0 <__panic>
+    assert(page2pa(p1) < npage * PGSIZE);
+  1030b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1030b8:	89 04 24             	mov    %eax,(%esp)
+  1030bb:	e8 f1 f8 ff ff       	call   1029b1 <page2pa>
+  1030c0:	8b 15 c0 88 11 00    	mov    0x1188c0,%edx
+  1030c6:	c1 e2 0c             	shl    $0xc,%edx
+  1030c9:	39 d0                	cmp    %edx,%eax
+  1030cb:	72 24                	jb     1030f1 <basic_check+0x1c9>
+  1030cd:	c7 44 24 0c b5 68 10 	movl   $0x1068b5,0xc(%esp)
+  1030d4:	00 
+  1030d5:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1030dc:	00 
+  1030dd:	c7 44 24 04 b4 00 00 	movl   $0xb4,0x4(%esp)
+  1030e4:	00 
+  1030e5:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1030ec:	e8 cf db ff ff       	call   100cc0 <__panic>
+    assert(page2pa(p2) < npage * PGSIZE);
+  1030f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1030f4:	89 04 24             	mov    %eax,(%esp)
+  1030f7:	e8 b5 f8 ff ff       	call   1029b1 <page2pa>
+  1030fc:	8b 15 c0 88 11 00    	mov    0x1188c0,%edx
+  103102:	c1 e2 0c             	shl    $0xc,%edx
+  103105:	39 d0                	cmp    %edx,%eax
+  103107:	72 24                	jb     10312d <basic_check+0x205>
+  103109:	c7 44 24 0c d2 68 10 	movl   $0x1068d2,0xc(%esp)
+  103110:	00 
+  103111:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103118:	00 
+  103119:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
+  103120:	00 
+  103121:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103128:	e8 93 db ff ff       	call   100cc0 <__panic>
+
+    list_entry_t free_list_store = free_list;
+  10312d:	a1 b0 89 11 00       	mov    0x1189b0,%eax
+  103132:	8b 15 b4 89 11 00    	mov    0x1189b4,%edx
+  103138:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  10313b:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  10313e:	c7 45 e0 b0 89 11 00 	movl   $0x1189b0,-0x20(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+  103145:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  103148:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  10314b:	89 50 04             	mov    %edx,0x4(%eax)
+  10314e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  103151:	8b 50 04             	mov    0x4(%eax),%edx
+  103154:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  103157:	89 10                	mov    %edx,(%eax)
+  103159:	c7 45 dc b0 89 11 00 	movl   $0x1189b0,-0x24(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+  103160:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  103163:	8b 40 04             	mov    0x4(%eax),%eax
+  103166:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+  103169:	0f 94 c0             	sete   %al
+  10316c:	0f b6 c0             	movzbl %al,%eax
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+  10316f:	85 c0                	test   %eax,%eax
+  103171:	75 24                	jne    103197 <basic_check+0x26f>
+  103173:	c7 44 24 0c ef 68 10 	movl   $0x1068ef,0xc(%esp)
+  10317a:	00 
+  10317b:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103182:	00 
+  103183:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
+  10318a:	00 
+  10318b:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103192:	e8 29 db ff ff       	call   100cc0 <__panic>
+
+    unsigned int nr_free_store = nr_free;
+  103197:	a1 b8 89 11 00       	mov    0x1189b8,%eax
+  10319c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    nr_free = 0;
+  10319f:	c7 05 b8 89 11 00 00 	movl   $0x0,0x1189b8
+  1031a6:	00 00 00 
+
+    assert(alloc_page() == NULL);
+  1031a9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1031b0:	e8 1d 0c 00 00       	call   103dd2 <alloc_pages>
+  1031b5:	85 c0                	test   %eax,%eax
+  1031b7:	74 24                	je     1031dd <basic_check+0x2b5>
+  1031b9:	c7 44 24 0c 06 69 10 	movl   $0x106906,0xc(%esp)
+  1031c0:	00 
+  1031c1:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1031c8:	00 
+  1031c9:	c7 44 24 04 be 00 00 	movl   $0xbe,0x4(%esp)
+  1031d0:	00 
+  1031d1:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1031d8:	e8 e3 da ff ff       	call   100cc0 <__panic>
+
+    free_page(p0);
+  1031dd:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  1031e4:	00 
+  1031e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1031e8:	89 04 24             	mov    %eax,(%esp)
+  1031eb:	e8 1a 0c 00 00       	call   103e0a <free_pages>
+    free_page(p1);
+  1031f0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  1031f7:	00 
+  1031f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1031fb:	89 04 24             	mov    %eax,(%esp)
+  1031fe:	e8 07 0c 00 00       	call   103e0a <free_pages>
+    free_page(p2);
+  103203:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  10320a:	00 
+  10320b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10320e:	89 04 24             	mov    %eax,(%esp)
+  103211:	e8 f4 0b 00 00       	call   103e0a <free_pages>
+    assert(nr_free == 3);
+  103216:	a1 b8 89 11 00       	mov    0x1189b8,%eax
+  10321b:	83 f8 03             	cmp    $0x3,%eax
+  10321e:	74 24                	je     103244 <basic_check+0x31c>
+  103220:	c7 44 24 0c 1b 69 10 	movl   $0x10691b,0xc(%esp)
+  103227:	00 
+  103228:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  10322f:	00 
+  103230:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
+  103237:	00 
+  103238:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  10323f:	e8 7c da ff ff       	call   100cc0 <__panic>
+
+    assert((p0 = alloc_page()) != NULL);
+  103244:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  10324b:	e8 82 0b 00 00       	call   103dd2 <alloc_pages>
+  103250:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  103253:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+  103257:	75 24                	jne    10327d <basic_check+0x355>
+  103259:	c7 44 24 0c e4 67 10 	movl   $0x1067e4,0xc(%esp)
+  103260:	00 
+  103261:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103268:	00 
+  103269:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
+  103270:	00 
+  103271:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103278:	e8 43 da ff ff       	call   100cc0 <__panic>
+    assert((p1 = alloc_page()) != NULL);
+  10327d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  103284:	e8 49 0b 00 00       	call   103dd2 <alloc_pages>
+  103289:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  10328c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  103290:	75 24                	jne    1032b6 <basic_check+0x38e>
+  103292:	c7 44 24 0c 00 68 10 	movl   $0x106800,0xc(%esp)
+  103299:	00 
+  10329a:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1032a1:	00 
+  1032a2:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
+  1032a9:	00 
+  1032aa:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1032b1:	e8 0a da ff ff       	call   100cc0 <__panic>
+    assert((p2 = alloc_page()) != NULL);
+  1032b6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1032bd:	e8 10 0b 00 00       	call   103dd2 <alloc_pages>
+  1032c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  1032c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  1032c9:	75 24                	jne    1032ef <basic_check+0x3c7>
+  1032cb:	c7 44 24 0c 1c 68 10 	movl   $0x10681c,0xc(%esp)
+  1032d2:	00 
+  1032d3:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1032da:	00 
+  1032db:	c7 44 24 04 c7 00 00 	movl   $0xc7,0x4(%esp)
+  1032e2:	00 
+  1032e3:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1032ea:	e8 d1 d9 ff ff       	call   100cc0 <__panic>
+
+    assert(alloc_page() == NULL);
+  1032ef:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1032f6:	e8 d7 0a 00 00       	call   103dd2 <alloc_pages>
+  1032fb:	85 c0                	test   %eax,%eax
+  1032fd:	74 24                	je     103323 <basic_check+0x3fb>
+  1032ff:	c7 44 24 0c 06 69 10 	movl   $0x106906,0xc(%esp)
+  103306:	00 
+  103307:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  10330e:	00 
+  10330f:	c7 44 24 04 c9 00 00 	movl   $0xc9,0x4(%esp)
+  103316:	00 
+  103317:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  10331e:	e8 9d d9 ff ff       	call   100cc0 <__panic>
+
+    free_page(p0);
+  103323:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  10332a:	00 
+  10332b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  10332e:	89 04 24             	mov    %eax,(%esp)
+  103331:	e8 d4 0a 00 00       	call   103e0a <free_pages>
+  103336:	c7 45 d8 b0 89 11 00 	movl   $0x1189b0,-0x28(%ebp)
+  10333d:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  103340:	8b 40 04             	mov    0x4(%eax),%eax
+  103343:	39 45 d8             	cmp    %eax,-0x28(%ebp)
+  103346:	0f 94 c0             	sete   %al
+  103349:	0f b6 c0             	movzbl %al,%eax
+    assert(!list_empty(&free_list));
+  10334c:	85 c0                	test   %eax,%eax
+  10334e:	74 24                	je     103374 <basic_check+0x44c>
+  103350:	c7 44 24 0c 28 69 10 	movl   $0x106928,0xc(%esp)
+  103357:	00 
+  103358:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  10335f:	00 
+  103360:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
+  103367:	00 
+  103368:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  10336f:	e8 4c d9 ff ff       	call   100cc0 <__panic>
+
+    struct Page *p;
+    assert((p = alloc_page()) == p0);
+  103374:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  10337b:	e8 52 0a 00 00       	call   103dd2 <alloc_pages>
+  103380:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  103383:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  103386:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  103389:	74 24                	je     1033af <basic_check+0x487>
+  10338b:	c7 44 24 0c 40 69 10 	movl   $0x106940,0xc(%esp)
+  103392:	00 
+  103393:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  10339a:	00 
+  10339b:	c7 44 24 04 cf 00 00 	movl   $0xcf,0x4(%esp)
+  1033a2:	00 
+  1033a3:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1033aa:	e8 11 d9 ff ff       	call   100cc0 <__panic>
+    assert(alloc_page() == NULL);
+  1033af:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1033b6:	e8 17 0a 00 00       	call   103dd2 <alloc_pages>
+  1033bb:	85 c0                	test   %eax,%eax
+  1033bd:	74 24                	je     1033e3 <basic_check+0x4bb>
+  1033bf:	c7 44 24 0c 06 69 10 	movl   $0x106906,0xc(%esp)
+  1033c6:	00 
+  1033c7:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1033ce:	00 
+  1033cf:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
+  1033d6:	00 
+  1033d7:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1033de:	e8 dd d8 ff ff       	call   100cc0 <__panic>
+
+    assert(nr_free == 0);
+  1033e3:	a1 b8 89 11 00       	mov    0x1189b8,%eax
+  1033e8:	85 c0                	test   %eax,%eax
+  1033ea:	74 24                	je     103410 <basic_check+0x4e8>
+  1033ec:	c7 44 24 0c 59 69 10 	movl   $0x106959,0xc(%esp)
+  1033f3:	00 
+  1033f4:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1033fb:	00 
+  1033fc:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
+  103403:	00 
+  103404:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  10340b:	e8 b0 d8 ff ff       	call   100cc0 <__panic>
+    free_list = free_list_store;
+  103410:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  103413:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  103416:	a3 b0 89 11 00       	mov    %eax,0x1189b0
+  10341b:	89 15 b4 89 11 00    	mov    %edx,0x1189b4
+    nr_free = nr_free_store;
+  103421:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  103424:	a3 b8 89 11 00       	mov    %eax,0x1189b8
+
+    free_page(p);
+  103429:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  103430:	00 
+  103431:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  103434:	89 04 24             	mov    %eax,(%esp)
+  103437:	e8 ce 09 00 00       	call   103e0a <free_pages>
+    free_page(p1);
+  10343c:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  103443:	00 
+  103444:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  103447:	89 04 24             	mov    %eax,(%esp)
+  10344a:	e8 bb 09 00 00       	call   103e0a <free_pages>
+    free_page(p2);
+  10344f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  103456:	00 
+  103457:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10345a:	89 04 24             	mov    %eax,(%esp)
+  10345d:	e8 a8 09 00 00       	call   103e0a <free_pages>
+}
+  103462:	c9                   	leave  
+  103463:	c3                   	ret    
+
+00103464 <default_check>:
+
+// LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+  103464:	55                   	push   %ebp
+  103465:	89 e5                	mov    %esp,%ebp
+  103467:	53                   	push   %ebx
+  103468:	81 ec 94 00 00 00    	sub    $0x94,%esp
+    int count = 0, total = 0;
+  10346e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  103475:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    list_entry_t *le = &free_list;
+  10347c:	c7 45 ec b0 89 11 00 	movl   $0x1189b0,-0x14(%ebp)
+    while ((le = list_next(le)) != &free_list) {
+  103483:	eb 6b                	jmp    1034f0 <default_check+0x8c>
+        struct Page *p = le2page(le, page_link);
+  103485:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  103488:	83 e8 0c             	sub    $0xc,%eax
+  10348b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        assert(PageProperty(p));
+  10348e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  103491:	83 c0 04             	add    $0x4,%eax
+  103494:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
+  10349b:	89 45 cc             	mov    %eax,-0x34(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+  10349e:	8b 45 cc             	mov    -0x34(%ebp),%eax
+  1034a1:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  1034a4:	0f a3 10             	bt     %edx,(%eax)
+  1034a7:	19 c0                	sbb    %eax,%eax
+  1034a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
+    return oldbit != 0;
+  1034ac:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
+  1034b0:	0f 95 c0             	setne  %al
+  1034b3:	0f b6 c0             	movzbl %al,%eax
+  1034b6:	85 c0                	test   %eax,%eax
+  1034b8:	75 24                	jne    1034de <default_check+0x7a>
+  1034ba:	c7 44 24 0c 66 69 10 	movl   $0x106966,0xc(%esp)
+  1034c1:	00 
+  1034c2:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1034c9:	00 
+  1034ca:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
+  1034d1:	00 
+  1034d2:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1034d9:	e8 e2 d7 ff ff       	call   100cc0 <__panic>
+        count ++, total += p->property;
+  1034de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  1034e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  1034e5:	8b 50 08             	mov    0x8(%eax),%edx
+  1034e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1034eb:	01 d0                	add    %edx,%eax
+  1034ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  1034f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1034f3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+  1034f6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+  1034f9:	8b 40 04             	mov    0x4(%eax),%eax
+// NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
+static void
+default_check(void) {
+    int count = 0, total = 0;
+    list_entry_t *le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+  1034fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  1034ff:	81 7d ec b0 89 11 00 	cmpl   $0x1189b0,-0x14(%ebp)
+  103506:	0f 85 79 ff ff ff    	jne    103485 <default_check+0x21>
+        struct Page *p = le2page(le, page_link);
+        assert(PageProperty(p));
+        count ++, total += p->property;
+    }
+    assert(total == nr_free_pages());
+  10350c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
+  10350f:	e8 28 09 00 00       	call   103e3c <nr_free_pages>
+  103514:	39 c3                	cmp    %eax,%ebx
+  103516:	74 24                	je     10353c <default_check+0xd8>
+  103518:	c7 44 24 0c 76 69 10 	movl   $0x106976,0xc(%esp)
+  10351f:	00 
+  103520:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103527:	00 
+  103528:	c7 44 24 04 e6 00 00 	movl   $0xe6,0x4(%esp)
+  10352f:	00 
+  103530:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103537:	e8 84 d7 ff ff       	call   100cc0 <__panic>
+
+    basic_check();
+  10353c:	e8 e7 f9 ff ff       	call   102f28 <basic_check>
+
+    struct Page *p0 = alloc_pages(5), *p1, *p2;
+  103541:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
+  103548:	e8 85 08 00 00       	call   103dd2 <alloc_pages>
+  10354d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    assert(p0 != NULL);
+  103550:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  103554:	75 24                	jne    10357a <default_check+0x116>
+  103556:	c7 44 24 0c 8f 69 10 	movl   $0x10698f,0xc(%esp)
+  10355d:	00 
+  10355e:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103565:	00 
+  103566:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
+  10356d:	00 
+  10356e:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103575:	e8 46 d7 ff ff       	call   100cc0 <__panic>
+    assert(!PageProperty(p0));
+  10357a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10357d:	83 c0 04             	add    $0x4,%eax
+  103580:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%ebp)
+  103587:	89 45 bc             	mov    %eax,-0x44(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+  10358a:	8b 45 bc             	mov    -0x44(%ebp),%eax
+  10358d:	8b 55 c0             	mov    -0x40(%ebp),%edx
+  103590:	0f a3 10             	bt     %edx,(%eax)
+  103593:	19 c0                	sbb    %eax,%eax
+  103595:	89 45 b8             	mov    %eax,-0x48(%ebp)
+    return oldbit != 0;
+  103598:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+  10359c:	0f 95 c0             	setne  %al
+  10359f:	0f b6 c0             	movzbl %al,%eax
+  1035a2:	85 c0                	test   %eax,%eax
+  1035a4:	74 24                	je     1035ca <default_check+0x166>
+  1035a6:	c7 44 24 0c 9a 69 10 	movl   $0x10699a,0xc(%esp)
+  1035ad:	00 
+  1035ae:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1035b5:	00 
+  1035b6:	c7 44 24 04 ec 00 00 	movl   $0xec,0x4(%esp)
+  1035bd:	00 
+  1035be:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1035c5:	e8 f6 d6 ff ff       	call   100cc0 <__panic>
+
+    list_entry_t free_list_store = free_list;
+  1035ca:	a1 b0 89 11 00       	mov    0x1189b0,%eax
+  1035cf:	8b 15 b4 89 11 00    	mov    0x1189b4,%edx
+  1035d5:	89 45 80             	mov    %eax,-0x80(%ebp)
+  1035d8:	89 55 84             	mov    %edx,-0x7c(%ebp)
+  1035db:	c7 45 b4 b0 89 11 00 	movl   $0x1189b0,-0x4c(%ebp)
+ * list_init - initialize a new entry
+ * @elm:        new entry to be initialized
+ * */
+static inline void
+list_init(list_entry_t *elm) {
+    elm->prev = elm->next = elm;
+  1035e2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+  1035e5:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+  1035e8:	89 50 04             	mov    %edx,0x4(%eax)
+  1035eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+  1035ee:	8b 50 04             	mov    0x4(%eax),%edx
+  1035f1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+  1035f4:	89 10                	mov    %edx,(%eax)
+  1035f6:	c7 45 b0 b0 89 11 00 	movl   $0x1189b0,-0x50(%ebp)
+ * list_empty - tests whether a list is empty
+ * @list:       the list to test.
+ * */
+static inline bool
+list_empty(list_entry_t *list) {
+    return list->next == list;
+  1035fd:	8b 45 b0             	mov    -0x50(%ebp),%eax
+  103600:	8b 40 04             	mov    0x4(%eax),%eax
+  103603:	39 45 b0             	cmp    %eax,-0x50(%ebp)
+  103606:	0f 94 c0             	sete   %al
+  103609:	0f b6 c0             	movzbl %al,%eax
+    list_init(&free_list);
+    assert(list_empty(&free_list));
+  10360c:	85 c0                	test   %eax,%eax
+  10360e:	75 24                	jne    103634 <default_check+0x1d0>
+  103610:	c7 44 24 0c ef 68 10 	movl   $0x1068ef,0xc(%esp)
+  103617:	00 
+  103618:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  10361f:	00 
+  103620:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
+  103627:	00 
+  103628:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  10362f:	e8 8c d6 ff ff       	call   100cc0 <__panic>
+    assert(alloc_page() == NULL);
+  103634:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  10363b:	e8 92 07 00 00       	call   103dd2 <alloc_pages>
+  103640:	85 c0                	test   %eax,%eax
+  103642:	74 24                	je     103668 <default_check+0x204>
+  103644:	c7 44 24 0c 06 69 10 	movl   $0x106906,0xc(%esp)
+  10364b:	00 
+  10364c:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103653:	00 
+  103654:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
+  10365b:	00 
+  10365c:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103663:	e8 58 d6 ff ff       	call   100cc0 <__panic>
+
+    unsigned int nr_free_store = nr_free;
+  103668:	a1 b8 89 11 00       	mov    0x1189b8,%eax
+  10366d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    nr_free = 0;
+  103670:	c7 05 b8 89 11 00 00 	movl   $0x0,0x1189b8
+  103677:	00 00 00 
+
+    free_pages(p0 + 2, 3);
+  10367a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10367d:	83 c0 28             	add    $0x28,%eax
+  103680:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+  103687:	00 
+  103688:	89 04 24             	mov    %eax,(%esp)
+  10368b:	e8 7a 07 00 00       	call   103e0a <free_pages>
+    assert(alloc_pages(4) == NULL);
+  103690:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+  103697:	e8 36 07 00 00       	call   103dd2 <alloc_pages>
+  10369c:	85 c0                	test   %eax,%eax
+  10369e:	74 24                	je     1036c4 <default_check+0x260>
+  1036a0:	c7 44 24 0c ac 69 10 	movl   $0x1069ac,0xc(%esp)
+  1036a7:	00 
+  1036a8:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1036af:	00 
+  1036b0:	c7 44 24 04 f7 00 00 	movl   $0xf7,0x4(%esp)
+  1036b7:	00 
+  1036b8:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1036bf:	e8 fc d5 ff ff       	call   100cc0 <__panic>
+    assert(PageProperty(p0 + 2) && p0[2].property == 3);
+  1036c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1036c7:	83 c0 28             	add    $0x28,%eax
+  1036ca:	83 c0 04             	add    $0x4,%eax
+  1036cd:	c7 45 ac 01 00 00 00 	movl   $0x1,-0x54(%ebp)
+  1036d4:	89 45 a8             	mov    %eax,-0x58(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+  1036d7:	8b 45 a8             	mov    -0x58(%ebp),%eax
+  1036da:	8b 55 ac             	mov    -0x54(%ebp),%edx
+  1036dd:	0f a3 10             	bt     %edx,(%eax)
+  1036e0:	19 c0                	sbb    %eax,%eax
+  1036e2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+    return oldbit != 0;
+  1036e5:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
+  1036e9:	0f 95 c0             	setne  %al
+  1036ec:	0f b6 c0             	movzbl %al,%eax
+  1036ef:	85 c0                	test   %eax,%eax
+  1036f1:	74 0e                	je     103701 <default_check+0x29d>
+  1036f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1036f6:	83 c0 28             	add    $0x28,%eax
+  1036f9:	8b 40 08             	mov    0x8(%eax),%eax
+  1036fc:	83 f8 03             	cmp    $0x3,%eax
+  1036ff:	74 24                	je     103725 <default_check+0x2c1>
+  103701:	c7 44 24 0c c4 69 10 	movl   $0x1069c4,0xc(%esp)
+  103708:	00 
+  103709:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103710:	00 
+  103711:	c7 44 24 04 f8 00 00 	movl   $0xf8,0x4(%esp)
+  103718:	00 
+  103719:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103720:	e8 9b d5 ff ff       	call   100cc0 <__panic>
+    assert((p1 = alloc_pages(3)) != NULL);
+  103725:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+  10372c:	e8 a1 06 00 00       	call   103dd2 <alloc_pages>
+  103731:	89 45 dc             	mov    %eax,-0x24(%ebp)
+  103734:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  103738:	75 24                	jne    10375e <default_check+0x2fa>
+  10373a:	c7 44 24 0c f0 69 10 	movl   $0x1069f0,0xc(%esp)
+  103741:	00 
+  103742:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103749:	00 
+  10374a:	c7 44 24 04 f9 00 00 	movl   $0xf9,0x4(%esp)
+  103751:	00 
+  103752:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103759:	e8 62 d5 ff ff       	call   100cc0 <__panic>
+    assert(alloc_page() == NULL);
+  10375e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  103765:	e8 68 06 00 00       	call   103dd2 <alloc_pages>
+  10376a:	85 c0                	test   %eax,%eax
+  10376c:	74 24                	je     103792 <default_check+0x32e>
+  10376e:	c7 44 24 0c 06 69 10 	movl   $0x106906,0xc(%esp)
+  103775:	00 
+  103776:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  10377d:	00 
+  10377e:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
+  103785:	00 
+  103786:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  10378d:	e8 2e d5 ff ff       	call   100cc0 <__panic>
+    assert(p0 + 2 == p1);
+  103792:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  103795:	83 c0 28             	add    $0x28,%eax
+  103798:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+  10379b:	74 24                	je     1037c1 <default_check+0x35d>
+  10379d:	c7 44 24 0c 0e 6a 10 	movl   $0x106a0e,0xc(%esp)
+  1037a4:	00 
+  1037a5:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1037ac:	00 
+  1037ad:	c7 44 24 04 fb 00 00 	movl   $0xfb,0x4(%esp)
+  1037b4:	00 
+  1037b5:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1037bc:	e8 ff d4 ff ff       	call   100cc0 <__panic>
+
+    p2 = p0 + 1;
+  1037c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1037c4:	83 c0 14             	add    $0x14,%eax
+  1037c7:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    free_page(p0);
+  1037ca:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  1037d1:	00 
+  1037d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1037d5:	89 04 24             	mov    %eax,(%esp)
+  1037d8:	e8 2d 06 00 00       	call   103e0a <free_pages>
+    free_pages(p1, 3);
+  1037dd:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+  1037e4:	00 
+  1037e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  1037e8:	89 04 24             	mov    %eax,(%esp)
+  1037eb:	e8 1a 06 00 00       	call   103e0a <free_pages>
+    assert(PageProperty(p0) && p0->property == 1);
+  1037f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1037f3:	83 c0 04             	add    $0x4,%eax
+  1037f6:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
+  1037fd:	89 45 9c             	mov    %eax,-0x64(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+  103800:	8b 45 9c             	mov    -0x64(%ebp),%eax
+  103803:	8b 55 a0             	mov    -0x60(%ebp),%edx
+  103806:	0f a3 10             	bt     %edx,(%eax)
+  103809:	19 c0                	sbb    %eax,%eax
+  10380b:	89 45 98             	mov    %eax,-0x68(%ebp)
+    return oldbit != 0;
+  10380e:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
+  103812:	0f 95 c0             	setne  %al
+  103815:	0f b6 c0             	movzbl %al,%eax
+  103818:	85 c0                	test   %eax,%eax
+  10381a:	74 0b                	je     103827 <default_check+0x3c3>
+  10381c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10381f:	8b 40 08             	mov    0x8(%eax),%eax
+  103822:	83 f8 01             	cmp    $0x1,%eax
+  103825:	74 24                	je     10384b <default_check+0x3e7>
+  103827:	c7 44 24 0c 1c 6a 10 	movl   $0x106a1c,0xc(%esp)
+  10382e:	00 
+  10382f:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103836:	00 
+  103837:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
+  10383e:	00 
+  10383f:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103846:	e8 75 d4 ff ff       	call   100cc0 <__panic>
+    assert(PageProperty(p1) && p1->property == 3);
+  10384b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  10384e:	83 c0 04             	add    $0x4,%eax
+  103851:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
+  103858:	89 45 90             	mov    %eax,-0x70(%ebp)
+ * @addr:   the address to count from
+ * */
+static inline bool
+test_bit(int nr, volatile void *addr) {
+    int oldbit;
+    asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
+  10385b:	8b 45 90             	mov    -0x70(%ebp),%eax
+  10385e:	8b 55 94             	mov    -0x6c(%ebp),%edx
+  103861:	0f a3 10             	bt     %edx,(%eax)
+  103864:	19 c0                	sbb    %eax,%eax
+  103866:	89 45 8c             	mov    %eax,-0x74(%ebp)
+    return oldbit != 0;
+  103869:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
+  10386d:	0f 95 c0             	setne  %al
+  103870:	0f b6 c0             	movzbl %al,%eax
+  103873:	85 c0                	test   %eax,%eax
+  103875:	74 0b                	je     103882 <default_check+0x41e>
+  103877:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  10387a:	8b 40 08             	mov    0x8(%eax),%eax
+  10387d:	83 f8 03             	cmp    $0x3,%eax
+  103880:	74 24                	je     1038a6 <default_check+0x442>
+  103882:	c7 44 24 0c 44 6a 10 	movl   $0x106a44,0xc(%esp)
+  103889:	00 
+  10388a:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103891:	00 
+  103892:	c7 44 24 04 01 01 00 	movl   $0x101,0x4(%esp)
+  103899:	00 
+  10389a:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1038a1:	e8 1a d4 ff ff       	call   100cc0 <__panic>
+
+    assert((p0 = alloc_page()) == p2 - 1);
+  1038a6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1038ad:	e8 20 05 00 00       	call   103dd2 <alloc_pages>
+  1038b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  1038b5:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  1038b8:	83 e8 14             	sub    $0x14,%eax
+  1038bb:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+  1038be:	74 24                	je     1038e4 <default_check+0x480>
+  1038c0:	c7 44 24 0c 6a 6a 10 	movl   $0x106a6a,0xc(%esp)
+  1038c7:	00 
+  1038c8:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1038cf:	00 
+  1038d0:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
+  1038d7:	00 
+  1038d8:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1038df:	e8 dc d3 ff ff       	call   100cc0 <__panic>
+    free_page(p0);
+  1038e4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  1038eb:	00 
+  1038ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1038ef:	89 04 24             	mov    %eax,(%esp)
+  1038f2:	e8 13 05 00 00       	call   103e0a <free_pages>
+    assert((p0 = alloc_pages(2)) == p2 + 1);
+  1038f7:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+  1038fe:	e8 cf 04 00 00       	call   103dd2 <alloc_pages>
+  103903:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  103906:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  103909:	83 c0 14             	add    $0x14,%eax
+  10390c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+  10390f:	74 24                	je     103935 <default_check+0x4d1>
+  103911:	c7 44 24 0c 88 6a 10 	movl   $0x106a88,0xc(%esp)
+  103918:	00 
+  103919:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103920:	00 
+  103921:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
+  103928:	00 
+  103929:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103930:	e8 8b d3 ff ff       	call   100cc0 <__panic>
+
+    free_pages(p0, 2);
+  103935:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+  10393c:	00 
+  10393d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  103940:	89 04 24             	mov    %eax,(%esp)
+  103943:	e8 c2 04 00 00       	call   103e0a <free_pages>
+    free_page(p2);
+  103948:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  10394f:	00 
+  103950:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  103953:	89 04 24             	mov    %eax,(%esp)
+  103956:	e8 af 04 00 00       	call   103e0a <free_pages>
+
+    assert((p0 = alloc_pages(5)) != NULL);
+  10395b:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
+  103962:	e8 6b 04 00 00       	call   103dd2 <alloc_pages>
+  103967:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  10396a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  10396e:	75 24                	jne    103994 <default_check+0x530>
+  103970:	c7 44 24 0c a8 6a 10 	movl   $0x106aa8,0xc(%esp)
+  103977:	00 
+  103978:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  10397f:	00 
+  103980:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
+  103987:	00 
+  103988:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  10398f:	e8 2c d3 ff ff       	call   100cc0 <__panic>
+    assert(alloc_page() == NULL);
+  103994:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  10399b:	e8 32 04 00 00       	call   103dd2 <alloc_pages>
+  1039a0:	85 c0                	test   %eax,%eax
+  1039a2:	74 24                	je     1039c8 <default_check+0x564>
+  1039a4:	c7 44 24 0c 06 69 10 	movl   $0x106906,0xc(%esp)
+  1039ab:	00 
+  1039ac:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1039b3:	00 
+  1039b4:	c7 44 24 04 0b 01 00 	movl   $0x10b,0x4(%esp)
+  1039bb:	00 
+  1039bc:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1039c3:	e8 f8 d2 ff ff       	call   100cc0 <__panic>
+
+    assert(nr_free == 0);
+  1039c8:	a1 b8 89 11 00       	mov    0x1189b8,%eax
+  1039cd:	85 c0                	test   %eax,%eax
+  1039cf:	74 24                	je     1039f5 <default_check+0x591>
+  1039d1:	c7 44 24 0c 59 69 10 	movl   $0x106959,0xc(%esp)
+  1039d8:	00 
+  1039d9:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  1039e0:	00 
+  1039e1:	c7 44 24 04 0d 01 00 	movl   $0x10d,0x4(%esp)
+  1039e8:	00 
+  1039e9:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  1039f0:	e8 cb d2 ff ff       	call   100cc0 <__panic>
+    nr_free = nr_free_store;
+  1039f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1039f8:	a3 b8 89 11 00       	mov    %eax,0x1189b8
+
+    free_list = free_list_store;
+  1039fd:	8b 45 80             	mov    -0x80(%ebp),%eax
+  103a00:	8b 55 84             	mov    -0x7c(%ebp),%edx
+  103a03:	a3 b0 89 11 00       	mov    %eax,0x1189b0
+  103a08:	89 15 b4 89 11 00    	mov    %edx,0x1189b4
+    free_pages(p0, 5);
+  103a0e:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
+  103a15:	00 
+  103a16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  103a19:	89 04 24             	mov    %eax,(%esp)
+  103a1c:	e8 e9 03 00 00       	call   103e0a <free_pages>
+
+    le = &free_list;
+  103a21:	c7 45 ec b0 89 11 00 	movl   $0x1189b0,-0x14(%ebp)
+    while ((le = list_next(le)) != &free_list) {
+  103a28:	eb 1d                	jmp    103a47 <default_check+0x5e3>
+        struct Page *p = le2page(le, page_link);
+  103a2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  103a2d:	83 e8 0c             	sub    $0xc,%eax
+  103a30:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        count --, total -= p->property;
+  103a33:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  103a37:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  103a3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  103a3d:	8b 40 08             	mov    0x8(%eax),%eax
+  103a40:	29 c2                	sub    %eax,%edx
+  103a42:	89 d0                	mov    %edx,%eax
+  103a44:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  103a47:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  103a4a:	89 45 88             	mov    %eax,-0x78(%ebp)
+ * list_next - get the next entry
+ * @listelm:    the list head
+ **/
+static inline list_entry_t *
+list_next(list_entry_t *listelm) {
+    return listelm->next;
+  103a4d:	8b 45 88             	mov    -0x78(%ebp),%eax
+  103a50:	8b 40 04             	mov    0x4(%eax),%eax
+
+    free_list = free_list_store;
+    free_pages(p0, 5);
+
+    le = &free_list;
+    while ((le = list_next(le)) != &free_list) {
+  103a53:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  103a56:	81 7d ec b0 89 11 00 	cmpl   $0x1189b0,-0x14(%ebp)
+  103a5d:	75 cb                	jne    103a2a <default_check+0x5c6>
+        struct Page *p = le2page(le, page_link);
+        count --, total -= p->property;
+    }
+    assert(count == 0);
+  103a5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  103a63:	74 24                	je     103a89 <default_check+0x625>
+  103a65:	c7 44 24 0c c6 6a 10 	movl   $0x106ac6,0xc(%esp)
+  103a6c:	00 
+  103a6d:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103a74:	00 
+  103a75:	c7 44 24 04 18 01 00 	movl   $0x118,0x4(%esp)
+  103a7c:	00 
+  103a7d:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103a84:	e8 37 d2 ff ff       	call   100cc0 <__panic>
+    assert(total == 0);
+  103a89:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  103a8d:	74 24                	je     103ab3 <default_check+0x64f>
+  103a8f:	c7 44 24 0c d1 6a 10 	movl   $0x106ad1,0xc(%esp)
+  103a96:	00 
+  103a97:	c7 44 24 08 96 67 10 	movl   $0x106796,0x8(%esp)
+  103a9e:	00 
+  103a9f:	c7 44 24 04 19 01 00 	movl   $0x119,0x4(%esp)
+  103aa6:	00 
+  103aa7:	c7 04 24 ab 67 10 00 	movl   $0x1067ab,(%esp)
+  103aae:	e8 0d d2 ff ff       	call   100cc0 <__panic>
+}
+  103ab3:	81 c4 94 00 00 00    	add    $0x94,%esp
+  103ab9:	5b                   	pop    %ebx
+  103aba:	5d                   	pop    %ebp
+  103abb:	c3                   	ret    
+
+00103abc <page2ppn>:
+
+extern struct Page *pages;
+extern size_t npage;
+
+static inline ppn_t
+page2ppn(struct Page *page) {
+  103abc:	55                   	push   %ebp
+  103abd:	89 e5                	mov    %esp,%ebp
+    return page - pages;
+  103abf:	8b 55 08             	mov    0x8(%ebp),%edx
+  103ac2:	a1 c4 89 11 00       	mov    0x1189c4,%eax
+  103ac7:	29 c2                	sub    %eax,%edx
+  103ac9:	89 d0                	mov    %edx,%eax
+  103acb:	c1 f8 02             	sar    $0x2,%eax
+  103ace:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
+}
+  103ad4:	5d                   	pop    %ebp
+  103ad5:	c3                   	ret    
+
+00103ad6 <page2pa>:
+
+static inline uintptr_t
+page2pa(struct Page *page) {
+  103ad6:	55                   	push   %ebp
+  103ad7:	89 e5                	mov    %esp,%ebp
+  103ad9:	83 ec 04             	sub    $0x4,%esp
+    return page2ppn(page) << PGSHIFT;
+  103adc:	8b 45 08             	mov    0x8(%ebp),%eax
+  103adf:	89 04 24             	mov    %eax,(%esp)
+  103ae2:	e8 d5 ff ff ff       	call   103abc <page2ppn>
+  103ae7:	c1 e0 0c             	shl    $0xc,%eax
+}
+  103aea:	c9                   	leave  
+  103aeb:	c3                   	ret    
+
+00103aec <pa2page>:
+
+static inline struct Page *
+pa2page(uintptr_t pa) {
+  103aec:	55                   	push   %ebp
+  103aed:	89 e5                	mov    %esp,%ebp
+  103aef:	83 ec 18             	sub    $0x18,%esp
+    if (PPN(pa) >= npage) {
+  103af2:	8b 45 08             	mov    0x8(%ebp),%eax
+  103af5:	c1 e8 0c             	shr    $0xc,%eax
+  103af8:	89 c2                	mov    %eax,%edx
+  103afa:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  103aff:	39 c2                	cmp    %eax,%edx
+  103b01:	72 1c                	jb     103b1f <pa2page+0x33>
+        panic("pa2page called with invalid pa");
+  103b03:	c7 44 24 08 0c 6b 10 	movl   $0x106b0c,0x8(%esp)
+  103b0a:	00 
+  103b0b:	c7 44 24 04 5a 00 00 	movl   $0x5a,0x4(%esp)
+  103b12:	00 
+  103b13:	c7 04 24 2b 6b 10 00 	movl   $0x106b2b,(%esp)
+  103b1a:	e8 a1 d1 ff ff       	call   100cc0 <__panic>
+    }
+    return &pages[PPN(pa)];
+  103b1f:	8b 0d c4 89 11 00    	mov    0x1189c4,%ecx
+  103b25:	8b 45 08             	mov    0x8(%ebp),%eax
+  103b28:	c1 e8 0c             	shr    $0xc,%eax
+  103b2b:	89 c2                	mov    %eax,%edx
+  103b2d:	89 d0                	mov    %edx,%eax
+  103b2f:	c1 e0 02             	shl    $0x2,%eax
+  103b32:	01 d0                	add    %edx,%eax
+  103b34:	c1 e0 02             	shl    $0x2,%eax
+  103b37:	01 c8                	add    %ecx,%eax
+}
+  103b39:	c9                   	leave  
+  103b3a:	c3                   	ret    
+
+00103b3b <page2kva>:
+
+static inline void *
+page2kva(struct Page *page) {
+  103b3b:	55                   	push   %ebp
+  103b3c:	89 e5                	mov    %esp,%ebp
+  103b3e:	83 ec 28             	sub    $0x28,%esp
+    return KADDR(page2pa(page));
+  103b41:	8b 45 08             	mov    0x8(%ebp),%eax
+  103b44:	89 04 24             	mov    %eax,(%esp)
+  103b47:	e8 8a ff ff ff       	call   103ad6 <page2pa>
+  103b4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  103b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  103b52:	c1 e8 0c             	shr    $0xc,%eax
+  103b55:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  103b58:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  103b5d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+  103b60:	72 23                	jb     103b85 <page2kva+0x4a>
+  103b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  103b65:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  103b69:	c7 44 24 08 3c 6b 10 	movl   $0x106b3c,0x8(%esp)
+  103b70:	00 
+  103b71:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
+  103b78:	00 
+  103b79:	c7 04 24 2b 6b 10 00 	movl   $0x106b2b,(%esp)
+  103b80:	e8 3b d1 ff ff       	call   100cc0 <__panic>
+  103b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  103b88:	2d 00 00 00 40       	sub    $0x40000000,%eax
+}
+  103b8d:	c9                   	leave  
+  103b8e:	c3                   	ret    
+
+00103b8f <pte2page>:
+kva2page(void *kva) {
+    return pa2page(PADDR(kva));
+}
+
+static inline struct Page *
+pte2page(pte_t pte) {
+  103b8f:	55                   	push   %ebp
+  103b90:	89 e5                	mov    %esp,%ebp
+  103b92:	83 ec 18             	sub    $0x18,%esp
+    if (!(pte & PTE_P)) {
+  103b95:	8b 45 08             	mov    0x8(%ebp),%eax
+  103b98:	83 e0 01             	and    $0x1,%eax
+  103b9b:	85 c0                	test   %eax,%eax
+  103b9d:	75 1c                	jne    103bbb <pte2page+0x2c>
+        panic("pte2page called with invalid pte");
+  103b9f:	c7 44 24 08 60 6b 10 	movl   $0x106b60,0x8(%esp)
+  103ba6:	00 
+  103ba7:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
+  103bae:	00 
+  103baf:	c7 04 24 2b 6b 10 00 	movl   $0x106b2b,(%esp)
+  103bb6:	e8 05 d1 ff ff       	call   100cc0 <__panic>
+    }
+    return pa2page(PTE_ADDR(pte));
+  103bbb:	8b 45 08             	mov    0x8(%ebp),%eax
+  103bbe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  103bc3:	89 04 24             	mov    %eax,(%esp)
+  103bc6:	e8 21 ff ff ff       	call   103aec <pa2page>
+}
+  103bcb:	c9                   	leave  
+  103bcc:	c3                   	ret    
+
+00103bcd <page_ref>:
+pde2page(pde_t pde) {
+    return pa2page(PDE_ADDR(pde));
+}
+
+static inline int
+page_ref(struct Page *page) {
+  103bcd:	55                   	push   %ebp
+  103bce:	89 e5                	mov    %esp,%ebp
+    return page->ref;
+  103bd0:	8b 45 08             	mov    0x8(%ebp),%eax
+  103bd3:	8b 00                	mov    (%eax),%eax
+}
+  103bd5:	5d                   	pop    %ebp
+  103bd6:	c3                   	ret    
+
+00103bd7 <set_page_ref>:
+
+static inline void
+set_page_ref(struct Page *page, int val) {
+  103bd7:	55                   	push   %ebp
+  103bd8:	89 e5                	mov    %esp,%ebp
+    page->ref = val;
+  103bda:	8b 45 08             	mov    0x8(%ebp),%eax
+  103bdd:	8b 55 0c             	mov    0xc(%ebp),%edx
+  103be0:	89 10                	mov    %edx,(%eax)
+}
+  103be2:	5d                   	pop    %ebp
+  103be3:	c3                   	ret    
+
+00103be4 <page_ref_inc>:
+
+static inline int
+page_ref_inc(struct Page *page) {
+  103be4:	55                   	push   %ebp
+  103be5:	89 e5                	mov    %esp,%ebp
+    page->ref += 1;
+  103be7:	8b 45 08             	mov    0x8(%ebp),%eax
+  103bea:	8b 00                	mov    (%eax),%eax
+  103bec:	8d 50 01             	lea    0x1(%eax),%edx
+  103bef:	8b 45 08             	mov    0x8(%ebp),%eax
+  103bf2:	89 10                	mov    %edx,(%eax)
+    return page->ref;
+  103bf4:	8b 45 08             	mov    0x8(%ebp),%eax
+  103bf7:	8b 00                	mov    (%eax),%eax
+}
+  103bf9:	5d                   	pop    %ebp
+  103bfa:	c3                   	ret    
+
+00103bfb <page_ref_dec>:
+
+static inline int
+page_ref_dec(struct Page *page) {
+  103bfb:	55                   	push   %ebp
+  103bfc:	89 e5                	mov    %esp,%ebp
+    page->ref -= 1;
+  103bfe:	8b 45 08             	mov    0x8(%ebp),%eax
+  103c01:	8b 00                	mov    (%eax),%eax
+  103c03:	8d 50 ff             	lea    -0x1(%eax),%edx
+  103c06:	8b 45 08             	mov    0x8(%ebp),%eax
+  103c09:	89 10                	mov    %edx,(%eax)
+    return page->ref;
+  103c0b:	8b 45 08             	mov    0x8(%ebp),%eax
+  103c0e:	8b 00                	mov    (%eax),%eax
+}
+  103c10:	5d                   	pop    %ebp
+  103c11:	c3                   	ret    
+
+00103c12 <__intr_save>:
+#include <x86.h>
+#include <intr.h>
+#include <mmu.h>
+
+static inline bool
+__intr_save(void) {
+  103c12:	55                   	push   %ebp
+  103c13:	89 e5                	mov    %esp,%ebp
+  103c15:	83 ec 18             	sub    $0x18,%esp
+}
+
+static inline uint32_t
+read_eflags(void) {
+    uint32_t eflags;
+    asm volatile ("pushfl; popl %0" : "=r" (eflags));
+  103c18:	9c                   	pushf  
+  103c19:	58                   	pop    %eax
+  103c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return eflags;
+  103c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    if (read_eflags() & FL_IF) {
+  103c20:	25 00 02 00 00       	and    $0x200,%eax
+  103c25:	85 c0                	test   %eax,%eax
+  103c27:	74 0c                	je     103c35 <__intr_save+0x23>
+        intr_disable();
+  103c29:	e8 75 da ff ff       	call   1016a3 <intr_disable>
+        return 1;
+  103c2e:	b8 01 00 00 00       	mov    $0x1,%eax
+  103c33:	eb 05                	jmp    103c3a <__intr_save+0x28>
+    }
+    return 0;
+  103c35:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  103c3a:	c9                   	leave  
+  103c3b:	c3                   	ret    
+
+00103c3c <__intr_restore>:
+
+static inline void
+__intr_restore(bool flag) {
+  103c3c:	55                   	push   %ebp
+  103c3d:	89 e5                	mov    %esp,%ebp
+  103c3f:	83 ec 08             	sub    $0x8,%esp
+    if (flag) {
+  103c42:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  103c46:	74 05                	je     103c4d <__intr_restore+0x11>
+        intr_enable();
+  103c48:	e8 50 da ff ff       	call   10169d <intr_enable>
+    }
+}
+  103c4d:	c9                   	leave  
+  103c4e:	c3                   	ret    
+
+00103c4f <lgdt>:
+/* *
+ * lgdt - load the global descriptor table register and reset the
+ * data/code segement registers for kernel.
+ * */
+static inline void
+lgdt(struct pseudodesc *pd) {
+  103c4f:	55                   	push   %ebp
+  103c50:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lgdt (%0)" :: "r" (pd));
+  103c52:	8b 45 08             	mov    0x8(%ebp),%eax
+  103c55:	0f 01 10             	lgdtl  (%eax)
+    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
+  103c58:	b8 23 00 00 00       	mov    $0x23,%eax
+  103c5d:	8e e8                	mov    %eax,%gs
+    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
+  103c5f:	b8 23 00 00 00       	mov    $0x23,%eax
+  103c64:	8e e0                	mov    %eax,%fs
+    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
+  103c66:	b8 10 00 00 00       	mov    $0x10,%eax
+  103c6b:	8e c0                	mov    %eax,%es
+    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
+  103c6d:	b8 10 00 00 00       	mov    $0x10,%eax
+  103c72:	8e d8                	mov    %eax,%ds
+    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+  103c74:	b8 10 00 00 00       	mov    $0x10,%eax
+  103c79:	8e d0                	mov    %eax,%ss
+    // reload cs
+    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+  103c7b:	ea 82 3c 10 00 08 00 	ljmp   $0x8,$0x103c82
+}
+  103c82:	5d                   	pop    %ebp
+  103c83:	c3                   	ret    
+
+00103c84 <load_esp0>:
+ * load_esp0 - change the ESP0 in default task state segment,
+ * so that we can use different kernel stack when we trap frame
+ * user to kernel.
+ * */
+void
+load_esp0(uintptr_t esp0) {
+  103c84:	55                   	push   %ebp
+  103c85:	89 e5                	mov    %esp,%ebp
+    ts.ts_esp0 = esp0;
+  103c87:	8b 45 08             	mov    0x8(%ebp),%eax
+  103c8a:	a3 e4 88 11 00       	mov    %eax,0x1188e4
+}
+  103c8f:	5d                   	pop    %ebp
+  103c90:	c3                   	ret    
+
+00103c91 <gdt_init>:
+
+/* gdt_init - initialize the default GDT and TSS */
+static void
+gdt_init(void) {
+  103c91:	55                   	push   %ebp
+  103c92:	89 e5                	mov    %esp,%ebp
+  103c94:	83 ec 14             	sub    $0x14,%esp
+    // set boot kernel stack and default SS0
+    load_esp0((uintptr_t)bootstacktop);
+  103c97:	b8 00 70 11 00       	mov    $0x117000,%eax
+  103c9c:	89 04 24             	mov    %eax,(%esp)
+  103c9f:	e8 e0 ff ff ff       	call   103c84 <load_esp0>
+    ts.ts_ss0 = KERNEL_DS;
+  103ca4:	66 c7 05 e8 88 11 00 	movw   $0x10,0x1188e8
+  103cab:	10 00 
+
+    // initialize the TSS filed of the gdt
+    gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
+  103cad:	66 c7 05 28 7a 11 00 	movw   $0x68,0x117a28
+  103cb4:	68 00 
+  103cb6:	b8 e0 88 11 00       	mov    $0x1188e0,%eax
+  103cbb:	66 a3 2a 7a 11 00    	mov    %ax,0x117a2a
+  103cc1:	b8 e0 88 11 00       	mov    $0x1188e0,%eax
+  103cc6:	c1 e8 10             	shr    $0x10,%eax
+  103cc9:	a2 2c 7a 11 00       	mov    %al,0x117a2c
+  103cce:	0f b6 05 2d 7a 11 00 	movzbl 0x117a2d,%eax
+  103cd5:	83 e0 f0             	and    $0xfffffff0,%eax
+  103cd8:	83 c8 09             	or     $0x9,%eax
+  103cdb:	a2 2d 7a 11 00       	mov    %al,0x117a2d
+  103ce0:	0f b6 05 2d 7a 11 00 	movzbl 0x117a2d,%eax
+  103ce7:	83 e0 ef             	and    $0xffffffef,%eax
+  103cea:	a2 2d 7a 11 00       	mov    %al,0x117a2d
+  103cef:	0f b6 05 2d 7a 11 00 	movzbl 0x117a2d,%eax
+  103cf6:	83 e0 9f             	and    $0xffffff9f,%eax
+  103cf9:	a2 2d 7a 11 00       	mov    %al,0x117a2d
+  103cfe:	0f b6 05 2d 7a 11 00 	movzbl 0x117a2d,%eax
+  103d05:	83 c8 80             	or     $0xffffff80,%eax
+  103d08:	a2 2d 7a 11 00       	mov    %al,0x117a2d
+  103d0d:	0f b6 05 2e 7a 11 00 	movzbl 0x117a2e,%eax
+  103d14:	83 e0 f0             	and    $0xfffffff0,%eax
+  103d17:	a2 2e 7a 11 00       	mov    %al,0x117a2e
+  103d1c:	0f b6 05 2e 7a 11 00 	movzbl 0x117a2e,%eax
+  103d23:	83 e0 ef             	and    $0xffffffef,%eax
+  103d26:	a2 2e 7a 11 00       	mov    %al,0x117a2e
+  103d2b:	0f b6 05 2e 7a 11 00 	movzbl 0x117a2e,%eax
+  103d32:	83 e0 df             	and    $0xffffffdf,%eax
+  103d35:	a2 2e 7a 11 00       	mov    %al,0x117a2e
+  103d3a:	0f b6 05 2e 7a 11 00 	movzbl 0x117a2e,%eax
+  103d41:	83 c8 40             	or     $0x40,%eax
+  103d44:	a2 2e 7a 11 00       	mov    %al,0x117a2e
+  103d49:	0f b6 05 2e 7a 11 00 	movzbl 0x117a2e,%eax
+  103d50:	83 e0 7f             	and    $0x7f,%eax
+  103d53:	a2 2e 7a 11 00       	mov    %al,0x117a2e
+  103d58:	b8 e0 88 11 00       	mov    $0x1188e0,%eax
+  103d5d:	c1 e8 18             	shr    $0x18,%eax
+  103d60:	a2 2f 7a 11 00       	mov    %al,0x117a2f
+
+    // reload all segment registers
+    lgdt(&gdt_pd);
+  103d65:	c7 04 24 30 7a 11 00 	movl   $0x117a30,(%esp)
+  103d6c:	e8 de fe ff ff       	call   103c4f <lgdt>
+  103d71:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%ebp)
+    asm volatile ("cli" ::: "memory");
+}
+
+static inline void
+ltr(uint16_t sel) {
+    asm volatile ("ltr %0" :: "r" (sel) : "memory");
+  103d77:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+  103d7b:	0f 00 d8             	ltr    %ax
+
+    // load the TSS
+    ltr(GD_TSS);
+}
+  103d7e:	c9                   	leave  
+  103d7f:	c3                   	ret    
+
+00103d80 <init_pmm_manager>:
+
+//init_pmm_manager - initialize a pmm_manager instance
+static void
+init_pmm_manager(void) {
+  103d80:	55                   	push   %ebp
+  103d81:	89 e5                	mov    %esp,%ebp
+  103d83:	83 ec 18             	sub    $0x18,%esp
+    pmm_manager = &default_pmm_manager;
+  103d86:	c7 05 bc 89 11 00 f0 	movl   $0x106af0,0x1189bc
+  103d8d:	6a 10 00 
+    cprintf("memory management: %s\n", pmm_manager->name);
+  103d90:	a1 bc 89 11 00       	mov    0x1189bc,%eax
+  103d95:	8b 00                	mov    (%eax),%eax
+  103d97:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103d9b:	c7 04 24 8c 6b 10 00 	movl   $0x106b8c,(%esp)
+  103da2:	e8 95 c5 ff ff       	call   10033c <cprintf>
+    pmm_manager->init();
+  103da7:	a1 bc 89 11 00       	mov    0x1189bc,%eax
+  103dac:	8b 40 04             	mov    0x4(%eax),%eax
+  103daf:	ff d0                	call   *%eax
+}
+  103db1:	c9                   	leave  
+  103db2:	c3                   	ret    
+
+00103db3 <init_memmap>:
+
+//init_memmap - call pmm->init_memmap to build Page struct for free memory  
+static void
+init_memmap(struct Page *base, size_t n) {
+  103db3:	55                   	push   %ebp
+  103db4:	89 e5                	mov    %esp,%ebp
+  103db6:	83 ec 18             	sub    $0x18,%esp
+    pmm_manager->init_memmap(base, n);
+  103db9:	a1 bc 89 11 00       	mov    0x1189bc,%eax
+  103dbe:	8b 40 08             	mov    0x8(%eax),%eax
+  103dc1:	8b 55 0c             	mov    0xc(%ebp),%edx
+  103dc4:	89 54 24 04          	mov    %edx,0x4(%esp)
+  103dc8:	8b 55 08             	mov    0x8(%ebp),%edx
+  103dcb:	89 14 24             	mov    %edx,(%esp)
+  103dce:	ff d0                	call   *%eax
+}
+  103dd0:	c9                   	leave  
+  103dd1:	c3                   	ret    
+
+00103dd2 <alloc_pages>:
+
+//alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
+struct Page *
+alloc_pages(size_t n) {
+  103dd2:	55                   	push   %ebp
+  103dd3:	89 e5                	mov    %esp,%ebp
+  103dd5:	83 ec 28             	sub    $0x28,%esp
+    struct Page *page=NULL;
+  103dd8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    bool intr_flag;
+    local_intr_save(intr_flag);
+  103ddf:	e8 2e fe ff ff       	call   103c12 <__intr_save>
+  103de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    {
+        page = pmm_manager->alloc_pages(n);
+  103de7:	a1 bc 89 11 00       	mov    0x1189bc,%eax
+  103dec:	8b 40 0c             	mov    0xc(%eax),%eax
+  103def:	8b 55 08             	mov    0x8(%ebp),%edx
+  103df2:	89 14 24             	mov    %edx,(%esp)
+  103df5:	ff d0                	call   *%eax
+  103df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    }
+    local_intr_restore(intr_flag);
+  103dfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  103dfd:	89 04 24             	mov    %eax,(%esp)
+  103e00:	e8 37 fe ff ff       	call   103c3c <__intr_restore>
+    return page;
+  103e05:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  103e08:	c9                   	leave  
+  103e09:	c3                   	ret    
+
+00103e0a <free_pages>:
+
+//free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
+void
+free_pages(struct Page *base, size_t n) {
+  103e0a:	55                   	push   %ebp
+  103e0b:	89 e5                	mov    %esp,%ebp
+  103e0d:	83 ec 28             	sub    $0x28,%esp
+    bool intr_flag;
+    local_intr_save(intr_flag);
+  103e10:	e8 fd fd ff ff       	call   103c12 <__intr_save>
+  103e15:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        pmm_manager->free_pages(base, n);
+  103e18:	a1 bc 89 11 00       	mov    0x1189bc,%eax
+  103e1d:	8b 40 10             	mov    0x10(%eax),%eax
+  103e20:	8b 55 0c             	mov    0xc(%ebp),%edx
+  103e23:	89 54 24 04          	mov    %edx,0x4(%esp)
+  103e27:	8b 55 08             	mov    0x8(%ebp),%edx
+  103e2a:	89 14 24             	mov    %edx,(%esp)
+  103e2d:	ff d0                	call   *%eax
+    }
+    local_intr_restore(intr_flag);
+  103e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  103e32:	89 04 24             	mov    %eax,(%esp)
+  103e35:	e8 02 fe ff ff       	call   103c3c <__intr_restore>
+}
+  103e3a:	c9                   	leave  
+  103e3b:	c3                   	ret    
+
+00103e3c <nr_free_pages>:
+
+//nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
+//of current free memory
+size_t
+nr_free_pages(void) {
+  103e3c:	55                   	push   %ebp
+  103e3d:	89 e5                	mov    %esp,%ebp
+  103e3f:	83 ec 28             	sub    $0x28,%esp
+    size_t ret;
+    bool intr_flag;
+    local_intr_save(intr_flag);
+  103e42:	e8 cb fd ff ff       	call   103c12 <__intr_save>
+  103e47:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    {
+        ret = pmm_manager->nr_free_pages();
+  103e4a:	a1 bc 89 11 00       	mov    0x1189bc,%eax
+  103e4f:	8b 40 14             	mov    0x14(%eax),%eax
+  103e52:	ff d0                	call   *%eax
+  103e54:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    }
+    local_intr_restore(intr_flag);
+  103e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  103e5a:	89 04 24             	mov    %eax,(%esp)
+  103e5d:	e8 da fd ff ff       	call   103c3c <__intr_restore>
+    return ret;
+  103e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  103e65:	c9                   	leave  
+  103e66:	c3                   	ret    
+
+00103e67 <page_init>:
+
+/* pmm_init - initialize the physical memory management */
+static void
+page_init(void) {
+  103e67:	55                   	push   %ebp
+  103e68:	89 e5                	mov    %esp,%ebp
+  103e6a:	57                   	push   %edi
+  103e6b:	56                   	push   %esi
+  103e6c:	53                   	push   %ebx
+  103e6d:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+  103e73:	c7 45 c4 00 80 00 c0 	movl   $0xc0008000,-0x3c(%ebp)
+    uint64_t maxpa = 0;
+  103e7a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+  103e81:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+
+    cprintf("e820map:\n");
+  103e88:	c7 04 24 a3 6b 10 00 	movl   $0x106ba3,(%esp)
+  103e8f:	e8 a8 c4 ff ff       	call   10033c <cprintf>
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+  103e94:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  103e9b:	e9 15 01 00 00       	jmp    103fb5 <page_init+0x14e>
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+  103ea0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+  103ea3:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  103ea6:	89 d0                	mov    %edx,%eax
+  103ea8:	c1 e0 02             	shl    $0x2,%eax
+  103eab:	01 d0                	add    %edx,%eax
+  103ead:	c1 e0 02             	shl    $0x2,%eax
+  103eb0:	01 c8                	add    %ecx,%eax
+  103eb2:	8b 50 08             	mov    0x8(%eax),%edx
+  103eb5:	8b 40 04             	mov    0x4(%eax),%eax
+  103eb8:	89 45 b8             	mov    %eax,-0x48(%ebp)
+  103ebb:	89 55 bc             	mov    %edx,-0x44(%ebp)
+  103ebe:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+  103ec1:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  103ec4:	89 d0                	mov    %edx,%eax
+  103ec6:	c1 e0 02             	shl    $0x2,%eax
+  103ec9:	01 d0                	add    %edx,%eax
+  103ecb:	c1 e0 02             	shl    $0x2,%eax
+  103ece:	01 c8                	add    %ecx,%eax
+  103ed0:	8b 48 0c             	mov    0xc(%eax),%ecx
+  103ed3:	8b 58 10             	mov    0x10(%eax),%ebx
+  103ed6:	8b 45 b8             	mov    -0x48(%ebp),%eax
+  103ed9:	8b 55 bc             	mov    -0x44(%ebp),%edx
+  103edc:	01 c8                	add    %ecx,%eax
+  103ede:	11 da                	adc    %ebx,%edx
+  103ee0:	89 45 b0             	mov    %eax,-0x50(%ebp)
+  103ee3:	89 55 b4             	mov    %edx,-0x4c(%ebp)
+        cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
+  103ee6:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+  103ee9:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  103eec:	89 d0                	mov    %edx,%eax
+  103eee:	c1 e0 02             	shl    $0x2,%eax
+  103ef1:	01 d0                	add    %edx,%eax
+  103ef3:	c1 e0 02             	shl    $0x2,%eax
+  103ef6:	01 c8                	add    %ecx,%eax
+  103ef8:	83 c0 14             	add    $0x14,%eax
+  103efb:	8b 00                	mov    (%eax),%eax
+  103efd:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
+  103f03:	8b 45 b0             	mov    -0x50(%ebp),%eax
+  103f06:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+  103f09:	83 c0 ff             	add    $0xffffffff,%eax
+  103f0c:	83 d2 ff             	adc    $0xffffffff,%edx
+  103f0f:	89 c6                	mov    %eax,%esi
+  103f11:	89 d7                	mov    %edx,%edi
+  103f13:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+  103f16:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  103f19:	89 d0                	mov    %edx,%eax
+  103f1b:	c1 e0 02             	shl    $0x2,%eax
+  103f1e:	01 d0                	add    %edx,%eax
+  103f20:	c1 e0 02             	shl    $0x2,%eax
+  103f23:	01 c8                	add    %ecx,%eax
+  103f25:	8b 48 0c             	mov    0xc(%eax),%ecx
+  103f28:	8b 58 10             	mov    0x10(%eax),%ebx
+  103f2b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
+  103f31:	89 44 24 1c          	mov    %eax,0x1c(%esp)
+  103f35:	89 74 24 14          	mov    %esi,0x14(%esp)
+  103f39:	89 7c 24 18          	mov    %edi,0x18(%esp)
+  103f3d:	8b 45 b8             	mov    -0x48(%ebp),%eax
+  103f40:	8b 55 bc             	mov    -0x44(%ebp),%edx
+  103f43:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  103f47:	89 54 24 10          	mov    %edx,0x10(%esp)
+  103f4b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+  103f4f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+  103f53:	c7 04 24 b0 6b 10 00 	movl   $0x106bb0,(%esp)
+  103f5a:	e8 dd c3 ff ff       	call   10033c <cprintf>
+                memmap->map[i].size, begin, end - 1, memmap->map[i].type);
+        if (memmap->map[i].type == E820_ARM) {
+  103f5f:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+  103f62:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  103f65:	89 d0                	mov    %edx,%eax
+  103f67:	c1 e0 02             	shl    $0x2,%eax
+  103f6a:	01 d0                	add    %edx,%eax
+  103f6c:	c1 e0 02             	shl    $0x2,%eax
+  103f6f:	01 c8                	add    %ecx,%eax
+  103f71:	83 c0 14             	add    $0x14,%eax
+  103f74:	8b 00                	mov    (%eax),%eax
+  103f76:	83 f8 01             	cmp    $0x1,%eax
+  103f79:	75 36                	jne    103fb1 <page_init+0x14a>
+            if (maxpa < end && begin < KMEMSIZE) {
+  103f7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  103f7e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  103f81:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
+  103f84:	77 2b                	ja     103fb1 <page_init+0x14a>
+  103f86:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
+  103f89:	72 05                	jb     103f90 <page_init+0x129>
+  103f8b:	3b 45 b0             	cmp    -0x50(%ebp),%eax
+  103f8e:	73 21                	jae    103fb1 <page_init+0x14a>
+  103f90:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+  103f94:	77 1b                	ja     103fb1 <page_init+0x14a>
+  103f96:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+  103f9a:	72 09                	jb     103fa5 <page_init+0x13e>
+  103f9c:	81 7d b8 ff ff ff 37 	cmpl   $0x37ffffff,-0x48(%ebp)
+  103fa3:	77 0c                	ja     103fb1 <page_init+0x14a>
+                maxpa = end;
+  103fa5:	8b 45 b0             	mov    -0x50(%ebp),%eax
+  103fa8:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+  103fab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  103fae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+    struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
+    uint64_t maxpa = 0;
+
+    cprintf("e820map:\n");
+    int i;
+    for (i = 0; i < memmap->nr_map; i ++) {
+  103fb1:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+  103fb5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+  103fb8:	8b 00                	mov    (%eax),%eax
+  103fba:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+  103fbd:	0f 8f dd fe ff ff    	jg     103ea0 <page_init+0x39>
+            if (maxpa < end && begin < KMEMSIZE) {
+                maxpa = end;
+            }
+        }
+    }
+    if (maxpa > KMEMSIZE) {
+  103fc3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  103fc7:	72 1d                	jb     103fe6 <page_init+0x17f>
+  103fc9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  103fcd:	77 09                	ja     103fd8 <page_init+0x171>
+  103fcf:	81 7d e0 00 00 00 38 	cmpl   $0x38000000,-0x20(%ebp)
+  103fd6:	76 0e                	jbe    103fe6 <page_init+0x17f>
+        maxpa = KMEMSIZE;
+  103fd8:	c7 45 e0 00 00 00 38 	movl   $0x38000000,-0x20(%ebp)
+  103fdf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    }
+
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+  103fe6:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  103fe9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  103fec:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  103ff0:	c1 ea 0c             	shr    $0xc,%edx
+  103ff3:	a3 c0 88 11 00       	mov    %eax,0x1188c0
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+  103ff8:	c7 45 ac 00 10 00 00 	movl   $0x1000,-0x54(%ebp)
+  103fff:	b8 c8 89 11 00       	mov    $0x1189c8,%eax
+  104004:	8d 50 ff             	lea    -0x1(%eax),%edx
+  104007:	8b 45 ac             	mov    -0x54(%ebp),%eax
+  10400a:	01 d0                	add    %edx,%eax
+  10400c:	89 45 a8             	mov    %eax,-0x58(%ebp)
+  10400f:	8b 45 a8             	mov    -0x58(%ebp),%eax
+  104012:	ba 00 00 00 00       	mov    $0x0,%edx
+  104017:	f7 75 ac             	divl   -0x54(%ebp)
+  10401a:	89 d0                	mov    %edx,%eax
+  10401c:	8b 55 a8             	mov    -0x58(%ebp),%edx
+  10401f:	29 c2                	sub    %eax,%edx
+  104021:	89 d0                	mov    %edx,%eax
+  104023:	a3 c4 89 11 00       	mov    %eax,0x1189c4
+
+    for (i = 0; i < npage; i ++) {
+  104028:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  10402f:	eb 2f                	jmp    104060 <page_init+0x1f9>
+        SetPageReserved(pages + i);
+  104031:	8b 0d c4 89 11 00    	mov    0x1189c4,%ecx
+  104037:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  10403a:	89 d0                	mov    %edx,%eax
+  10403c:	c1 e0 02             	shl    $0x2,%eax
+  10403f:	01 d0                	add    %edx,%eax
+  104041:	c1 e0 02             	shl    $0x2,%eax
+  104044:	01 c8                	add    %ecx,%eax
+  104046:	83 c0 04             	add    $0x4,%eax
+  104049:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
+  104050:	89 45 8c             	mov    %eax,-0x74(%ebp)
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ * */
+static inline void
+set_bit(int nr, volatile void *addr) {
+    asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
+  104053:	8b 45 8c             	mov    -0x74(%ebp),%eax
+  104056:	8b 55 90             	mov    -0x70(%ebp),%edx
+  104059:	0f ab 10             	bts    %edx,(%eax)
+    extern char end[];
+
+    npage = maxpa / PGSIZE;
+    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
+
+    for (i = 0; i < npage; i ++) {
+  10405c:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+  104060:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  104063:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  104068:	39 c2                	cmp    %eax,%edx
+  10406a:	72 c5                	jb     104031 <page_init+0x1ca>
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+  10406c:	8b 15 c0 88 11 00    	mov    0x1188c0,%edx
+  104072:	89 d0                	mov    %edx,%eax
+  104074:	c1 e0 02             	shl    $0x2,%eax
+  104077:	01 d0                	add    %edx,%eax
+  104079:	c1 e0 02             	shl    $0x2,%eax
+  10407c:	89 c2                	mov    %eax,%edx
+  10407e:	a1 c4 89 11 00       	mov    0x1189c4,%eax
+  104083:	01 d0                	add    %edx,%eax
+  104085:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+  104088:	81 7d a4 ff ff ff bf 	cmpl   $0xbfffffff,-0x5c(%ebp)
+  10408f:	77 23                	ja     1040b4 <page_init+0x24d>
+  104091:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+  104094:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  104098:	c7 44 24 08 e0 6b 10 	movl   $0x106be0,0x8(%esp)
+  10409f:	00 
+  1040a0:	c7 44 24 04 db 00 00 	movl   $0xdb,0x4(%esp)
+  1040a7:	00 
+  1040a8:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1040af:	e8 0c cc ff ff       	call   100cc0 <__panic>
+  1040b4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+  1040b7:	05 00 00 00 40       	add    $0x40000000,%eax
+  1040bc:	89 45 a0             	mov    %eax,-0x60(%ebp)
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+  1040bf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  1040c6:	e9 74 01 00 00       	jmp    10423f <page_init+0x3d8>
+        uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
+  1040cb:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+  1040ce:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  1040d1:	89 d0                	mov    %edx,%eax
+  1040d3:	c1 e0 02             	shl    $0x2,%eax
+  1040d6:	01 d0                	add    %edx,%eax
+  1040d8:	c1 e0 02             	shl    $0x2,%eax
+  1040db:	01 c8                	add    %ecx,%eax
+  1040dd:	8b 50 08             	mov    0x8(%eax),%edx
+  1040e0:	8b 40 04             	mov    0x4(%eax),%eax
+  1040e3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  1040e6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  1040e9:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+  1040ec:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  1040ef:	89 d0                	mov    %edx,%eax
+  1040f1:	c1 e0 02             	shl    $0x2,%eax
+  1040f4:	01 d0                	add    %edx,%eax
+  1040f6:	c1 e0 02             	shl    $0x2,%eax
+  1040f9:	01 c8                	add    %ecx,%eax
+  1040fb:	8b 48 0c             	mov    0xc(%eax),%ecx
+  1040fe:	8b 58 10             	mov    0x10(%eax),%ebx
+  104101:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  104104:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  104107:	01 c8                	add    %ecx,%eax
+  104109:	11 da                	adc    %ebx,%edx
+  10410b:	89 45 c8             	mov    %eax,-0x38(%ebp)
+  10410e:	89 55 cc             	mov    %edx,-0x34(%ebp)
+        if (memmap->map[i].type == E820_ARM) {
+  104111:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+  104114:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  104117:	89 d0                	mov    %edx,%eax
+  104119:	c1 e0 02             	shl    $0x2,%eax
+  10411c:	01 d0                	add    %edx,%eax
+  10411e:	c1 e0 02             	shl    $0x2,%eax
+  104121:	01 c8                	add    %ecx,%eax
+  104123:	83 c0 14             	add    $0x14,%eax
+  104126:	8b 00                	mov    (%eax),%eax
+  104128:	83 f8 01             	cmp    $0x1,%eax
+  10412b:	0f 85 0a 01 00 00    	jne    10423b <page_init+0x3d4>
+            if (begin < freemem) {
+  104131:	8b 45 a0             	mov    -0x60(%ebp),%eax
+  104134:	ba 00 00 00 00       	mov    $0x0,%edx
+  104139:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  10413c:	72 17                	jb     104155 <page_init+0x2ee>
+  10413e:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  104141:	77 05                	ja     104148 <page_init+0x2e1>
+  104143:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  104146:	76 0d                	jbe    104155 <page_init+0x2ee>
+                begin = freemem;
+  104148:	8b 45 a0             	mov    -0x60(%ebp),%eax
+  10414b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  10414e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+            }
+            if (end > KMEMSIZE) {
+  104155:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+  104159:	72 1d                	jb     104178 <page_init+0x311>
+  10415b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+  10415f:	77 09                	ja     10416a <page_init+0x303>
+  104161:	81 7d c8 00 00 00 38 	cmpl   $0x38000000,-0x38(%ebp)
+  104168:	76 0e                	jbe    104178 <page_init+0x311>
+                end = KMEMSIZE;
+  10416a:	c7 45 c8 00 00 00 38 	movl   $0x38000000,-0x38(%ebp)
+  104171:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
+            }
+            if (begin < end) {
+  104178:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  10417b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  10417e:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+  104181:	0f 87 b4 00 00 00    	ja     10423b <page_init+0x3d4>
+  104187:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+  10418a:	72 09                	jb     104195 <page_init+0x32e>
+  10418c:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+  10418f:	0f 83 a6 00 00 00    	jae    10423b <page_init+0x3d4>
+                begin = ROUNDUP(begin, PGSIZE);
+  104195:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
+  10419c:	8b 55 d0             	mov    -0x30(%ebp),%edx
+  10419f:	8b 45 9c             	mov    -0x64(%ebp),%eax
+  1041a2:	01 d0                	add    %edx,%eax
+  1041a4:	83 e8 01             	sub    $0x1,%eax
+  1041a7:	89 45 98             	mov    %eax,-0x68(%ebp)
+  1041aa:	8b 45 98             	mov    -0x68(%ebp),%eax
+  1041ad:	ba 00 00 00 00       	mov    $0x0,%edx
+  1041b2:	f7 75 9c             	divl   -0x64(%ebp)
+  1041b5:	89 d0                	mov    %edx,%eax
+  1041b7:	8b 55 98             	mov    -0x68(%ebp),%edx
+  1041ba:	29 c2                	sub    %eax,%edx
+  1041bc:	89 d0                	mov    %edx,%eax
+  1041be:	ba 00 00 00 00       	mov    $0x0,%edx
+  1041c3:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  1041c6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+                end = ROUNDDOWN(end, PGSIZE);
+  1041c9:	8b 45 c8             	mov    -0x38(%ebp),%eax
+  1041cc:	89 45 94             	mov    %eax,-0x6c(%ebp)
+  1041cf:	8b 45 94             	mov    -0x6c(%ebp),%eax
+  1041d2:	ba 00 00 00 00       	mov    $0x0,%edx
+  1041d7:	89 c7                	mov    %eax,%edi
+  1041d9:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
+  1041df:	89 7d 80             	mov    %edi,-0x80(%ebp)
+  1041e2:	89 d0                	mov    %edx,%eax
+  1041e4:	83 e0 00             	and    $0x0,%eax
+  1041e7:	89 45 84             	mov    %eax,-0x7c(%ebp)
+  1041ea:	8b 45 80             	mov    -0x80(%ebp),%eax
+  1041ed:	8b 55 84             	mov    -0x7c(%ebp),%edx
+  1041f0:	89 45 c8             	mov    %eax,-0x38(%ebp)
+  1041f3:	89 55 cc             	mov    %edx,-0x34(%ebp)
+                if (begin < end) {
+  1041f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  1041f9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  1041fc:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+  1041ff:	77 3a                	ja     10423b <page_init+0x3d4>
+  104201:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+  104204:	72 05                	jb     10420b <page_init+0x3a4>
+  104206:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+  104209:	73 30                	jae    10423b <page_init+0x3d4>
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+  10420b:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+  10420e:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
+  104211:	8b 45 c8             	mov    -0x38(%ebp),%eax
+  104214:	8b 55 cc             	mov    -0x34(%ebp),%edx
+  104217:	29 c8                	sub    %ecx,%eax
+  104219:	19 da                	sbb    %ebx,%edx
+  10421b:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+  10421f:	c1 ea 0c             	shr    $0xc,%edx
+  104222:	89 c3                	mov    %eax,%ebx
+  104224:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  104227:	89 04 24             	mov    %eax,(%esp)
+  10422a:	e8 bd f8 ff ff       	call   103aec <pa2page>
+  10422f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+  104233:	89 04 24             	mov    %eax,(%esp)
+  104236:	e8 78 fb ff ff       	call   103db3 <init_memmap>
+        SetPageReserved(pages + i);
+    }
+
+    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
+
+    for (i = 0; i < memmap->nr_map; i ++) {
+  10423b:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+  10423f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+  104242:	8b 00                	mov    (%eax),%eax
+  104244:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+  104247:	0f 8f 7e fe ff ff    	jg     1040cb <page_init+0x264>
+                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);
+                }
+            }
+        }
+    }
+}
+  10424d:	81 c4 9c 00 00 00    	add    $0x9c,%esp
+  104253:	5b                   	pop    %ebx
+  104254:	5e                   	pop    %esi
+  104255:	5f                   	pop    %edi
+  104256:	5d                   	pop    %ebp
+  104257:	c3                   	ret    
+
+00104258 <enable_paging>:
+
+static void
+enable_paging(void) {
+  104258:	55                   	push   %ebp
+  104259:	89 e5                	mov    %esp,%ebp
+  10425b:	83 ec 10             	sub    $0x10,%esp
+    lcr3(boot_cr3);
+  10425e:	a1 c0 89 11 00       	mov    0x1189c0,%eax
+  104263:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
+}
+
+static inline void
+lcr3(uintptr_t cr3) {
+    asm volatile ("mov %0, %%cr3" :: "r" (cr3) : "memory");
+  104266:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  104269:	0f 22 d8             	mov    %eax,%cr3
+}
+
+static inline uintptr_t
+rcr0(void) {
+    uintptr_t cr0;
+    asm volatile ("mov %%cr0, %0" : "=r" (cr0) :: "memory");
+  10426c:	0f 20 c0             	mov    %cr0,%eax
+  10426f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    return cr0;
+  104272:	8b 45 f4             	mov    -0xc(%ebp),%eax
+
+    // turn on paging
+    uint32_t cr0 = rcr0();
+  104275:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP;
+  104278:	81 4d fc 2f 00 05 80 	orl    $0x8005002f,-0x4(%ebp)
+    cr0 &= ~(CR0_TS | CR0_EM);
+  10427f:	83 65 fc f3          	andl   $0xfffffff3,-0x4(%ebp)
+  104283:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  104286:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    asm volatile ("pushl %0; popfl" :: "r" (eflags));
+}
+
+static inline void
+lcr0(uintptr_t cr0) {
+    asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
+  104289:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10428c:	0f 22 c0             	mov    %eax,%cr0
+    lcr0(cr0);
+}
+  10428f:	c9                   	leave  
+  104290:	c3                   	ret    
+
+00104291 <boot_map_segment>:
+//  la:   linear address of this memory need to map (after x86 segment map)
+//  size: memory size
+//  pa:   physical address of this memory
+//  perm: permission of this memory  
+static void
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+  104291:	55                   	push   %ebp
+  104292:	89 e5                	mov    %esp,%ebp
+  104294:	83 ec 38             	sub    $0x38,%esp
+    assert(PGOFF(la) == PGOFF(pa));
+  104297:	8b 45 14             	mov    0x14(%ebp),%eax
+  10429a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  10429d:	31 d0                	xor    %edx,%eax
+  10429f:	25 ff 0f 00 00       	and    $0xfff,%eax
+  1042a4:	85 c0                	test   %eax,%eax
+  1042a6:	74 24                	je     1042cc <boot_map_segment+0x3b>
+  1042a8:	c7 44 24 0c 12 6c 10 	movl   $0x106c12,0xc(%esp)
+  1042af:	00 
+  1042b0:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  1042b7:	00 
+  1042b8:	c7 44 24 04 04 01 00 	movl   $0x104,0x4(%esp)
+  1042bf:	00 
+  1042c0:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1042c7:	e8 f4 c9 ff ff       	call   100cc0 <__panic>
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+  1042cc:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
+  1042d3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1042d6:	25 ff 0f 00 00       	and    $0xfff,%eax
+  1042db:	89 c2                	mov    %eax,%edx
+  1042dd:	8b 45 10             	mov    0x10(%ebp),%eax
+  1042e0:	01 c2                	add    %eax,%edx
+  1042e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1042e5:	01 d0                	add    %edx,%eax
+  1042e7:	83 e8 01             	sub    $0x1,%eax
+  1042ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  1042ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1042f0:	ba 00 00 00 00       	mov    $0x0,%edx
+  1042f5:	f7 75 f0             	divl   -0x10(%ebp)
+  1042f8:	89 d0                	mov    %edx,%eax
+  1042fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  1042fd:	29 c2                	sub    %eax,%edx
+  1042ff:	89 d0                	mov    %edx,%eax
+  104301:	c1 e8 0c             	shr    $0xc,%eax
+  104304:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    la = ROUNDDOWN(la, PGSIZE);
+  104307:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10430a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  10430d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  104310:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  104315:	89 45 0c             	mov    %eax,0xc(%ebp)
+    pa = ROUNDDOWN(pa, PGSIZE);
+  104318:	8b 45 14             	mov    0x14(%ebp),%eax
+  10431b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  10431e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  104321:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  104326:	89 45 14             	mov    %eax,0x14(%ebp)
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+  104329:	eb 6b                	jmp    104396 <boot_map_segment+0x105>
+        pte_t *ptep = get_pte(pgdir, la, 1);
+  10432b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+  104332:	00 
+  104333:	8b 45 0c             	mov    0xc(%ebp),%eax
+  104336:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10433a:	8b 45 08             	mov    0x8(%ebp),%eax
+  10433d:	89 04 24             	mov    %eax,(%esp)
+  104340:	e8 cc 01 00 00       	call   104511 <get_pte>
+  104345:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        assert(ptep != NULL);
+  104348:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  10434c:	75 24                	jne    104372 <boot_map_segment+0xe1>
+  10434e:	c7 44 24 0c 3e 6c 10 	movl   $0x106c3e,0xc(%esp)
+  104355:	00 
+  104356:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  10435d:	00 
+  10435e:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
+  104365:	00 
+  104366:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  10436d:	e8 4e c9 ff ff       	call   100cc0 <__panic>
+        *ptep = pa | PTE_P | perm;
+  104372:	8b 45 18             	mov    0x18(%ebp),%eax
+  104375:	8b 55 14             	mov    0x14(%ebp),%edx
+  104378:	09 d0                	or     %edx,%eax
+  10437a:	83 c8 01             	or     $0x1,%eax
+  10437d:	89 c2                	mov    %eax,%edx
+  10437f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  104382:	89 10                	mov    %edx,(%eax)
+boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
+    assert(PGOFF(la) == PGOFF(pa));
+    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
+    la = ROUNDDOWN(la, PGSIZE);
+    pa = ROUNDDOWN(pa, PGSIZE);
+    for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
+  104384:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  104388:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
+  10438f:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
+  104396:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  10439a:	75 8f                	jne    10432b <boot_map_segment+0x9a>
+        pte_t *ptep = get_pte(pgdir, la, 1);
+        assert(ptep != NULL);
+        *ptep = pa | PTE_P | perm;
+    }
+}
+  10439c:	c9                   	leave  
+  10439d:	c3                   	ret    
+
+0010439e <boot_alloc_page>:
+
+//boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
+// return value: the kernel virtual address of this allocated page
+//note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
+static void *
+boot_alloc_page(void) {
+  10439e:	55                   	push   %ebp
+  10439f:	89 e5                	mov    %esp,%ebp
+  1043a1:	83 ec 28             	sub    $0x28,%esp
+    struct Page *p = alloc_page();
+  1043a4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1043ab:	e8 22 fa ff ff       	call   103dd2 <alloc_pages>
+  1043b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (p == NULL) {
+  1043b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  1043b7:	75 1c                	jne    1043d5 <boot_alloc_page+0x37>
+        panic("boot_alloc_page failed.\n");
+  1043b9:	c7 44 24 08 4b 6c 10 	movl   $0x106c4b,0x8(%esp)
+  1043c0:	00 
+  1043c1:	c7 44 24 04 16 01 00 	movl   $0x116,0x4(%esp)
+  1043c8:	00 
+  1043c9:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1043d0:	e8 eb c8 ff ff       	call   100cc0 <__panic>
+    }
+    return page2kva(p);
+  1043d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1043d8:	89 04 24             	mov    %eax,(%esp)
+  1043db:	e8 5b f7 ff ff       	call   103b3b <page2kva>
+}
+  1043e0:	c9                   	leave  
+  1043e1:	c3                   	ret    
+
+001043e2 <pmm_init>:
+
+//pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
+//         - check the correctness of pmm & paging mechanism, print PDT&PT
+void
+pmm_init(void) {
+  1043e2:	55                   	push   %ebp
+  1043e3:	89 e5                	mov    %esp,%ebp
+  1043e5:	83 ec 38             	sub    $0x38,%esp
+    //We need to alloc/free the physical memory (granularity is 4KB or other size). 
+    //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
+    //First we should init a physical memory manager(pmm) based on the framework.
+    //Then pmm can alloc/free the physical memory. 
+    //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
+    init_pmm_manager();
+  1043e8:	e8 93 f9 ff ff       	call   103d80 <init_pmm_manager>
+
+    // detect physical memory space, reserve already used memory,
+    // then use pmm->init_memmap to create free page list
+    page_init();
+  1043ed:	e8 75 fa ff ff       	call   103e67 <page_init>
+
+    //use pmm->check to verify the correctness of the alloc/free function in a pmm
+    check_alloc_page();
+  1043f2:	e8 66 04 00 00       	call   10485d <check_alloc_page>
+
+    // create boot_pgdir, an initial page directory(Page Directory Table, PDT)
+    boot_pgdir = boot_alloc_page();
+  1043f7:	e8 a2 ff ff ff       	call   10439e <boot_alloc_page>
+  1043fc:	a3 c4 88 11 00       	mov    %eax,0x1188c4
+    memset(boot_pgdir, 0, PGSIZE);
+  104401:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104406:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+  10440d:	00 
+  10440e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  104415:	00 
+  104416:	89 04 24             	mov    %eax,(%esp)
+  104419:	e8 a8 1a 00 00       	call   105ec6 <memset>
+    boot_cr3 = PADDR(boot_pgdir);
+  10441e:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104423:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  104426:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+  10442d:	77 23                	ja     104452 <pmm_init+0x70>
+  10442f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104432:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  104436:	c7 44 24 08 e0 6b 10 	movl   $0x106be0,0x8(%esp)
+  10443d:	00 
+  10443e:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
+  104445:	00 
+  104446:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  10444d:	e8 6e c8 ff ff       	call   100cc0 <__panic>
+  104452:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104455:	05 00 00 00 40       	add    $0x40000000,%eax
+  10445a:	a3 c0 89 11 00       	mov    %eax,0x1189c0
+
+    check_pgdir();
+  10445f:	e8 17 04 00 00       	call   10487b <check_pgdir>
+
+    static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
+
+    // recursively insert boot_pgdir in itself
+    // to form a virtual page table at virtual address VPT
+    boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
+  104464:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104469:	8d 90 ac 0f 00 00    	lea    0xfac(%eax),%edx
+  10446f:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104474:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  104477:	81 7d f0 ff ff ff bf 	cmpl   $0xbfffffff,-0x10(%ebp)
+  10447e:	77 23                	ja     1044a3 <pmm_init+0xc1>
+  104480:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104483:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  104487:	c7 44 24 08 e0 6b 10 	movl   $0x106be0,0x8(%esp)
+  10448e:	00 
+  10448f:	c7 44 24 04 38 01 00 	movl   $0x138,0x4(%esp)
+  104496:	00 
+  104497:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  10449e:	e8 1d c8 ff ff       	call   100cc0 <__panic>
+  1044a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1044a6:	05 00 00 00 40       	add    $0x40000000,%eax
+  1044ab:	83 c8 03             	or     $0x3,%eax
+  1044ae:	89 02                	mov    %eax,(%edx)
+
+    // map all physical memory to linear memory with base linear addr KERNBASE
+    //linear_addr KERNBASE~KERNBASE+KMEMSIZE = phy_addr 0~KMEMSIZE
+    //But shouldn't use this map until enable_paging() & gdt_init() finished.
+    boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
+  1044b0:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  1044b5:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
+  1044bc:	00 
+  1044bd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  1044c4:	00 
+  1044c5:	c7 44 24 08 00 00 00 	movl   $0x38000000,0x8(%esp)
+  1044cc:	38 
+  1044cd:	c7 44 24 04 00 00 00 	movl   $0xc0000000,0x4(%esp)
+  1044d4:	c0 
+  1044d5:	89 04 24             	mov    %eax,(%esp)
+  1044d8:	e8 b4 fd ff ff       	call   104291 <boot_map_segment>
+
+    //temporary map: 
+    //virtual_addr 3G~3G+4M = linear_addr 0~4M = linear_addr 3G~3G+4M = phy_addr 0~4M     
+    boot_pgdir[0] = boot_pgdir[PDX(KERNBASE)];
+  1044dd:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  1044e2:	8b 15 c4 88 11 00    	mov    0x1188c4,%edx
+  1044e8:	8b 92 00 0c 00 00    	mov    0xc00(%edx),%edx
+  1044ee:	89 10                	mov    %edx,(%eax)
+
+    enable_paging();
+  1044f0:	e8 63 fd ff ff       	call   104258 <enable_paging>
+
+    //reload gdt(third time,the last time) to map all physical memory
+    //virtual_addr 0~4G=liear_addr 0~4G
+    //then set kernel stack(ss:esp) in TSS, setup TSS in gdt, load TSS
+    gdt_init();
+  1044f5:	e8 97 f7 ff ff       	call   103c91 <gdt_init>
+
+    //disable the map of virtual_addr 0~4M
+    boot_pgdir[0] = 0;
+  1044fa:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  1044ff:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    //now the basic virtual memory map(see memalyout.h) is established.
+    //check the correctness of the basic virtual memory map.
+    check_boot_pgdir();
+  104505:	e8 0c 0a 00 00       	call   104f16 <check_boot_pgdir>
+
+    print_pgdir();
+  10450a:	e8 99 0e 00 00       	call   1053a8 <print_pgdir>
+
+}
+  10450f:	c9                   	leave  
+  104510:	c3                   	ret    
+
+00104511 <get_pte>:
+//  pgdir:  the kernel virtual base address of PDT
+//  la:     the linear address need to map
+//  create: a logical value to decide if alloc a page for PT
+// return vaule: the kernel virtual address of this pte
+pte_t *
+get_pte(pde_t *pgdir, uintptr_t la, bool create) {
+  104511:	55                   	push   %ebp
+  104512:	89 e5                	mov    %esp,%ebp
+  104514:	83 ec 38             	sub    $0x38,%esp
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
+     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+     */
+
+    pde_t *pdep = &pgdir[PDX(la)];   // (1) find page directory entry
+  104517:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10451a:	c1 e8 16             	shr    $0x16,%eax
+  10451d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  104524:	8b 45 08             	mov    0x8(%ebp),%eax
+  104527:	01 d0                	add    %edx,%eax
+  104529:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (!(*pdep & PTE_P)) {              // (2) check if entry is not present
+  10452c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10452f:	8b 00                	mov    (%eax),%eax
+  104531:	83 e0 01             	and    $0x1,%eax
+  104534:	85 c0                	test   %eax,%eax
+  104536:	0f 85 af 00 00 00    	jne    1045eb <get_pte+0xda>
+	struct Page* page;                    // (3) check if creating is needed, then alloc page for page table
+                          // CAUTION: this page is used for page table, not for common data page
+	if (!create || (page = alloc_page()) == NULL) {
+  10453c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  104540:	74 15                	je     104557 <get_pte+0x46>
+  104542:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  104549:	e8 84 f8 ff ff       	call   103dd2 <alloc_pages>
+  10454e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  104551:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  104555:	75 0a                	jne    104561 <get_pte+0x50>
+            return NULL;
+  104557:	b8 00 00 00 00       	mov    $0x0,%eax
+  10455c:	e9 e6 00 00 00       	jmp    104647 <get_pte+0x136>
+        }                          
+	set_page_ref(page, 1);		  // (4) set page reference
+  104561:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  104568:	00 
+  104569:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10456c:	89 04 24             	mov    %eax,(%esp)
+  10456f:	e8 63 f6 ff ff       	call   103bd7 <set_page_ref>
+        uintptr_t pa = page2pa(page); // (5) get linear address of page
+  104574:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104577:	89 04 24             	mov    %eax,(%esp)
+  10457a:	e8 57 f5 ff ff       	call   103ad6 <page2pa>
+  10457f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        memset(KADDR(pa),0,PGSIZE);                  // (6) clear page content using memset
+  104582:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  104585:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  104588:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  10458b:	c1 e8 0c             	shr    $0xc,%eax
+  10458e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  104591:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  104596:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+  104599:	72 23                	jb     1045be <get_pte+0xad>
+  10459b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  10459e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  1045a2:	c7 44 24 08 3c 6b 10 	movl   $0x106b3c,0x8(%esp)
+  1045a9:	00 
+  1045aa:	c7 44 24 04 7d 01 00 	movl   $0x17d,0x4(%esp)
+  1045b1:	00 
+  1045b2:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1045b9:	e8 02 c7 ff ff       	call   100cc0 <__panic>
+  1045be:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  1045c1:	2d 00 00 00 40       	sub    $0x40000000,%eax
+  1045c6:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+  1045cd:	00 
+  1045ce:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  1045d5:	00 
+  1045d6:	89 04 24             	mov    %eax,(%esp)
+  1045d9:	e8 e8 18 00 00       	call   105ec6 <memset>
+        *pdep = pa | PTE_U | PTE_W | PTE_P;                // (7) set page directory entry's permission
+  1045de:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1045e1:	83 c8 07             	or     $0x7,%eax
+  1045e4:	89 c2                	mov    %eax,%edx
+  1045e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1045e9:	89 10                	mov    %edx,(%eax)
+    }
+    return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];          // (8) return page table entry
+  1045eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1045ee:	8b 00                	mov    (%eax),%eax
+  1045f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  1045f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  1045f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1045fb:	c1 e8 0c             	shr    $0xc,%eax
+  1045fe:	89 45 dc             	mov    %eax,-0x24(%ebp)
+  104601:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  104606:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+  104609:	72 23                	jb     10462e <get_pte+0x11d>
+  10460b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  10460e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  104612:	c7 44 24 08 3c 6b 10 	movl   $0x106b3c,0x8(%esp)
+  104619:	00 
+  10461a:	c7 44 24 04 80 01 00 	movl   $0x180,0x4(%esp)
+  104621:	00 
+  104622:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104629:	e8 92 c6 ff ff       	call   100cc0 <__panic>
+  10462e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  104631:	2d 00 00 00 40       	sub    $0x40000000,%eax
+  104636:	8b 55 0c             	mov    0xc(%ebp),%edx
+  104639:	c1 ea 0c             	shr    $0xc,%edx
+  10463c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
+  104642:	c1 e2 02             	shl    $0x2,%edx
+  104645:	01 d0                	add    %edx,%eax
+
+}
+  104647:	c9                   	leave  
+  104648:	c3                   	ret    
+
+00104649 <get_page>:
+
+//get_page - get related Page struct for linear address la using PDT pgdir
+struct Page *
+get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
+  104649:	55                   	push   %ebp
+  10464a:	89 e5                	mov    %esp,%ebp
+  10464c:	83 ec 28             	sub    $0x28,%esp
+    pte_t *ptep = get_pte(pgdir, la, 0);
+  10464f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  104656:	00 
+  104657:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10465a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10465e:	8b 45 08             	mov    0x8(%ebp),%eax
+  104661:	89 04 24             	mov    %eax,(%esp)
+  104664:	e8 a8 fe ff ff       	call   104511 <get_pte>
+  104669:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep_store != NULL) {
+  10466c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  104670:	74 08                	je     10467a <get_page+0x31>
+        *ptep_store = ptep;
+  104672:	8b 45 10             	mov    0x10(%ebp),%eax
+  104675:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  104678:	89 10                	mov    %edx,(%eax)
+    }
+    if (ptep != NULL && *ptep & PTE_P) {
+  10467a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  10467e:	74 1b                	je     10469b <get_page+0x52>
+  104680:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104683:	8b 00                	mov    (%eax),%eax
+  104685:	83 e0 01             	and    $0x1,%eax
+  104688:	85 c0                	test   %eax,%eax
+  10468a:	74 0f                	je     10469b <get_page+0x52>
+        return pa2page(*ptep);
+  10468c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10468f:	8b 00                	mov    (%eax),%eax
+  104691:	89 04 24             	mov    %eax,(%esp)
+  104694:	e8 53 f4 ff ff       	call   103aec <pa2page>
+  104699:	eb 05                	jmp    1046a0 <get_page+0x57>
+    }
+    return NULL;
+  10469b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  1046a0:	c9                   	leave  
+  1046a1:	c3                   	ret    
+
+001046a2 <page_remove_pte>:
+
+//page_remove_pte - free an Page sturct which is related linear address la
+//                - and clean(invalidate) pte which is related linear address la
+//note: PT is changed, so the TLB need to be invalidate 
+static inline void
+page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
+  1046a2:	55                   	push   %ebp
+  1046a3:	89 e5                	mov    %esp,%ebp
+  1046a5:	83 ec 28             	sub    $0x28,%esp
+     *                        edited are the ones currently in use by the processor.
+     * DEFINEs:
+     *   PTE_P           0x001                   // page table/directory entry flags bit : Present
+     */
+
+    if (*ptep & PTE_P) {                      //(1) check if this page table entry is present
+  1046a8:	8b 45 10             	mov    0x10(%ebp),%eax
+  1046ab:	8b 00                	mov    (%eax),%eax
+  1046ad:	83 e0 01             	and    $0x1,%eax
+  1046b0:	85 c0                	test   %eax,%eax
+  1046b2:	74 4d                	je     104701 <page_remove_pte+0x5f>
+        struct Page *page = pte2page(*ptep); //(2) find corresponding page to pte
+  1046b4:	8b 45 10             	mov    0x10(%ebp),%eax
+  1046b7:	8b 00                	mov    (%eax),%eax
+  1046b9:	89 04 24             	mov    %eax,(%esp)
+  1046bc:	e8 ce f4 ff ff       	call   103b8f <pte2page>
+  1046c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        if (page_ref_dec(page) == 0) {
+  1046c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1046c7:	89 04 24             	mov    %eax,(%esp)
+  1046ca:	e8 2c f5 ff ff       	call   103bfb <page_ref_dec>
+  1046cf:	85 c0                	test   %eax,%eax
+  1046d1:	75 13                	jne    1046e6 <page_remove_pte+0x44>
+            free_page(page);
+  1046d3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  1046da:	00 
+  1046db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1046de:	89 04 24             	mov    %eax,(%esp)
+  1046e1:	e8 24 f7 ff ff       	call   103e0a <free_pages>
+        }
+        *ptep = 0;
+  1046e6:	8b 45 10             	mov    0x10(%ebp),%eax
+  1046e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+        tlb_invalidate(pgdir, la);
+  1046ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1046f2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1046f6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1046f9:	89 04 24             	mov    %eax,(%esp)
+  1046fc:	e8 ff 00 00 00       	call   104800 <tlb_invalidate>
+                                  //(4) and free this page when page reference reachs 0
+                                  //(5) clear second page table entry
+                                  //(6) flush tlb
+    }
+
+}
+  104701:	c9                   	leave  
+  104702:	c3                   	ret    
+
+00104703 <page_remove>:
+
+//page_remove - free an Page which is related linear address la and has an validated pte
+void
+page_remove(pde_t *pgdir, uintptr_t la) {
+  104703:	55                   	push   %ebp
+  104704:	89 e5                	mov    %esp,%ebp
+  104706:	83 ec 28             	sub    $0x28,%esp
+    pte_t *ptep = get_pte(pgdir, la, 0);
+  104709:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  104710:	00 
+  104711:	8b 45 0c             	mov    0xc(%ebp),%eax
+  104714:	89 44 24 04          	mov    %eax,0x4(%esp)
+  104718:	8b 45 08             	mov    0x8(%ebp),%eax
+  10471b:	89 04 24             	mov    %eax,(%esp)
+  10471e:	e8 ee fd ff ff       	call   104511 <get_pte>
+  104723:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep != NULL) {
+  104726:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  10472a:	74 19                	je     104745 <page_remove+0x42>
+        page_remove_pte(pgdir, la, ptep);
+  10472c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10472f:	89 44 24 08          	mov    %eax,0x8(%esp)
+  104733:	8b 45 0c             	mov    0xc(%ebp),%eax
+  104736:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10473a:	8b 45 08             	mov    0x8(%ebp),%eax
+  10473d:	89 04 24             	mov    %eax,(%esp)
+  104740:	e8 5d ff ff ff       	call   1046a2 <page_remove_pte>
+    }
+}
+  104745:	c9                   	leave  
+  104746:	c3                   	ret    
+
+00104747 <page_insert>:
+//  la:    the linear address need to map
+//  perm:  the permission of this Page which is setted in related pte
+// return value: always 0
+//note: PT is changed, so the TLB need to be invalidate 
+int
+page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
+  104747:	55                   	push   %ebp
+  104748:	89 e5                	mov    %esp,%ebp
+  10474a:	83 ec 28             	sub    $0x28,%esp
+    pte_t *ptep = get_pte(pgdir, la, 1);
+  10474d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+  104754:	00 
+  104755:	8b 45 10             	mov    0x10(%ebp),%eax
+  104758:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10475c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10475f:	89 04 24             	mov    %eax,(%esp)
+  104762:	e8 aa fd ff ff       	call   104511 <get_pte>
+  104767:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (ptep == NULL) {
+  10476a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  10476e:	75 0a                	jne    10477a <page_insert+0x33>
+        return -E_NO_MEM;
+  104770:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+  104775:	e9 84 00 00 00       	jmp    1047fe <page_insert+0xb7>
+    }
+    page_ref_inc(page);
+  10477a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10477d:	89 04 24             	mov    %eax,(%esp)
+  104780:	e8 5f f4 ff ff       	call   103be4 <page_ref_inc>
+    if (*ptep & PTE_P) {
+  104785:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104788:	8b 00                	mov    (%eax),%eax
+  10478a:	83 e0 01             	and    $0x1,%eax
+  10478d:	85 c0                	test   %eax,%eax
+  10478f:	74 3e                	je     1047cf <page_insert+0x88>
+        struct Page *p = pte2page(*ptep);
+  104791:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104794:	8b 00                	mov    (%eax),%eax
+  104796:	89 04 24             	mov    %eax,(%esp)
+  104799:	e8 f1 f3 ff ff       	call   103b8f <pte2page>
+  10479e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (p == page) {
+  1047a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1047a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  1047a7:	75 0d                	jne    1047b6 <page_insert+0x6f>
+            page_ref_dec(page);
+  1047a9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1047ac:	89 04 24             	mov    %eax,(%esp)
+  1047af:	e8 47 f4 ff ff       	call   103bfb <page_ref_dec>
+  1047b4:	eb 19                	jmp    1047cf <page_insert+0x88>
+        }
+        else {
+            page_remove_pte(pgdir, la, ptep);
+  1047b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1047b9:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1047bd:	8b 45 10             	mov    0x10(%ebp),%eax
+  1047c0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1047c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1047c7:	89 04 24             	mov    %eax,(%esp)
+  1047ca:	e8 d3 fe ff ff       	call   1046a2 <page_remove_pte>
+        }
+    }
+    *ptep = page2pa(page) | PTE_P | perm;
+  1047cf:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1047d2:	89 04 24             	mov    %eax,(%esp)
+  1047d5:	e8 fc f2 ff ff       	call   103ad6 <page2pa>
+  1047da:	0b 45 14             	or     0x14(%ebp),%eax
+  1047dd:	83 c8 01             	or     $0x1,%eax
+  1047e0:	89 c2                	mov    %eax,%edx
+  1047e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1047e5:	89 10                	mov    %edx,(%eax)
+    tlb_invalidate(pgdir, la);
+  1047e7:	8b 45 10             	mov    0x10(%ebp),%eax
+  1047ea:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1047ee:	8b 45 08             	mov    0x8(%ebp),%eax
+  1047f1:	89 04 24             	mov    %eax,(%esp)
+  1047f4:	e8 07 00 00 00       	call   104800 <tlb_invalidate>
+    return 0;
+  1047f9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  1047fe:	c9                   	leave  
+  1047ff:	c3                   	ret    
+
+00104800 <tlb_invalidate>:
+
+// invalidate a TLB entry, but only if the page tables being
+// edited are the ones currently in use by the processor.
+void
+tlb_invalidate(pde_t *pgdir, uintptr_t la) {
+  104800:	55                   	push   %ebp
+  104801:	89 e5                	mov    %esp,%ebp
+  104803:	83 ec 28             	sub    $0x28,%esp
+}
+
+static inline uintptr_t
+rcr3(void) {
+    uintptr_t cr3;
+    asm volatile ("mov %%cr3, %0" : "=r" (cr3) :: "memory");
+  104806:	0f 20 d8             	mov    %cr3,%eax
+  104809:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    return cr3;
+  10480c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    if (rcr3() == PADDR(pgdir)) {
+  10480f:	89 c2                	mov    %eax,%edx
+  104811:	8b 45 08             	mov    0x8(%ebp),%eax
+  104814:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  104817:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+  10481e:	77 23                	ja     104843 <tlb_invalidate+0x43>
+  104820:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104823:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  104827:	c7 44 24 08 e0 6b 10 	movl   $0x106be0,0x8(%esp)
+  10482e:	00 
+  10482f:	c7 44 24 04 e0 01 00 	movl   $0x1e0,0x4(%esp)
+  104836:	00 
+  104837:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  10483e:	e8 7d c4 ff ff       	call   100cc0 <__panic>
+  104843:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104846:	05 00 00 00 40       	add    $0x40000000,%eax
+  10484b:	39 c2                	cmp    %eax,%edx
+  10484d:	75 0c                	jne    10485b <tlb_invalidate+0x5b>
+        invlpg((void *)la);
+  10484f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  104852:	89 45 ec             	mov    %eax,-0x14(%ebp)
+}
+
+static inline void
+invlpg(void *addr) {
+    asm volatile ("invlpg (%0)" :: "r" (addr) : "memory");
+  104855:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  104858:	0f 01 38             	invlpg (%eax)
+    }
+}
+  10485b:	c9                   	leave  
+  10485c:	c3                   	ret    
+
+0010485d <check_alloc_page>:
+
+static void
+check_alloc_page(void) {
+  10485d:	55                   	push   %ebp
+  10485e:	89 e5                	mov    %esp,%ebp
+  104860:	83 ec 18             	sub    $0x18,%esp
+    pmm_manager->check();
+  104863:	a1 bc 89 11 00       	mov    0x1189bc,%eax
+  104868:	8b 40 18             	mov    0x18(%eax),%eax
+  10486b:	ff d0                	call   *%eax
+    cprintf("check_alloc_page() succeeded!\n");
+  10486d:	c7 04 24 64 6c 10 00 	movl   $0x106c64,(%esp)
+  104874:	e8 c3 ba ff ff       	call   10033c <cprintf>
+}
+  104879:	c9                   	leave  
+  10487a:	c3                   	ret    
+
+0010487b <check_pgdir>:
+
+static void
+check_pgdir(void) {
+  10487b:	55                   	push   %ebp
+  10487c:	89 e5                	mov    %esp,%ebp
+  10487e:	83 ec 38             	sub    $0x38,%esp
+    assert(npage <= KMEMSIZE / PGSIZE);
+  104881:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  104886:	3d 00 80 03 00       	cmp    $0x38000,%eax
+  10488b:	76 24                	jbe    1048b1 <check_pgdir+0x36>
+  10488d:	c7 44 24 0c 83 6c 10 	movl   $0x106c83,0xc(%esp)
+  104894:	00 
+  104895:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  10489c:	00 
+  10489d:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
+  1048a4:	00 
+  1048a5:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1048ac:	e8 0f c4 ff ff       	call   100cc0 <__panic>
+    assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
+  1048b1:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  1048b6:	85 c0                	test   %eax,%eax
+  1048b8:	74 0e                	je     1048c8 <check_pgdir+0x4d>
+  1048ba:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  1048bf:	25 ff 0f 00 00       	and    $0xfff,%eax
+  1048c4:	85 c0                	test   %eax,%eax
+  1048c6:	74 24                	je     1048ec <check_pgdir+0x71>
+  1048c8:	c7 44 24 0c a0 6c 10 	movl   $0x106ca0,0xc(%esp)
+  1048cf:	00 
+  1048d0:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  1048d7:	00 
+  1048d8:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
+  1048df:	00 
+  1048e0:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1048e7:	e8 d4 c3 ff ff       	call   100cc0 <__panic>
+    assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
+  1048ec:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  1048f1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  1048f8:	00 
+  1048f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  104900:	00 
+  104901:	89 04 24             	mov    %eax,(%esp)
+  104904:	e8 40 fd ff ff       	call   104649 <get_page>
+  104909:	85 c0                	test   %eax,%eax
+  10490b:	74 24                	je     104931 <check_pgdir+0xb6>
+  10490d:	c7 44 24 0c d8 6c 10 	movl   $0x106cd8,0xc(%esp)
+  104914:	00 
+  104915:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  10491c:	00 
+  10491d:	c7 44 24 04 ef 01 00 	movl   $0x1ef,0x4(%esp)
+  104924:	00 
+  104925:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  10492c:	e8 8f c3 ff ff       	call   100cc0 <__panic>
+
+    struct Page *p1, *p2;
+    p1 = alloc_page();
+  104931:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  104938:	e8 95 f4 ff ff       	call   103dd2 <alloc_pages>
+  10493d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
+  104940:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104945:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  10494c:	00 
+  10494d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  104954:	00 
+  104955:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  104958:	89 54 24 04          	mov    %edx,0x4(%esp)
+  10495c:	89 04 24             	mov    %eax,(%esp)
+  10495f:	e8 e3 fd ff ff       	call   104747 <page_insert>
+  104964:	85 c0                	test   %eax,%eax
+  104966:	74 24                	je     10498c <check_pgdir+0x111>
+  104968:	c7 44 24 0c 00 6d 10 	movl   $0x106d00,0xc(%esp)
+  10496f:	00 
+  104970:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104977:	00 
+  104978:	c7 44 24 04 f3 01 00 	movl   $0x1f3,0x4(%esp)
+  10497f:	00 
+  104980:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104987:	e8 34 c3 ff ff       	call   100cc0 <__panic>
+
+    pte_t *ptep;
+    assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
+  10498c:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104991:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  104998:	00 
+  104999:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  1049a0:	00 
+  1049a1:	89 04 24             	mov    %eax,(%esp)
+  1049a4:	e8 68 fb ff ff       	call   104511 <get_pte>
+  1049a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  1049ac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  1049b0:	75 24                	jne    1049d6 <check_pgdir+0x15b>
+  1049b2:	c7 44 24 0c 2c 6d 10 	movl   $0x106d2c,0xc(%esp)
+  1049b9:	00 
+  1049ba:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  1049c1:	00 
+  1049c2:	c7 44 24 04 f6 01 00 	movl   $0x1f6,0x4(%esp)
+  1049c9:	00 
+  1049ca:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1049d1:	e8 ea c2 ff ff       	call   100cc0 <__panic>
+    assert(pa2page(*ptep) == p1);
+  1049d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1049d9:	8b 00                	mov    (%eax),%eax
+  1049db:	89 04 24             	mov    %eax,(%esp)
+  1049de:	e8 09 f1 ff ff       	call   103aec <pa2page>
+  1049e3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  1049e6:	74 24                	je     104a0c <check_pgdir+0x191>
+  1049e8:	c7 44 24 0c 59 6d 10 	movl   $0x106d59,0xc(%esp)
+  1049ef:	00 
+  1049f0:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  1049f7:	00 
+  1049f8:	c7 44 24 04 f7 01 00 	movl   $0x1f7,0x4(%esp)
+  1049ff:	00 
+  104a00:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104a07:	e8 b4 c2 ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p1) == 1);
+  104a0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104a0f:	89 04 24             	mov    %eax,(%esp)
+  104a12:	e8 b6 f1 ff ff       	call   103bcd <page_ref>
+  104a17:	83 f8 01             	cmp    $0x1,%eax
+  104a1a:	74 24                	je     104a40 <check_pgdir+0x1c5>
+  104a1c:	c7 44 24 0c 6e 6d 10 	movl   $0x106d6e,0xc(%esp)
+  104a23:	00 
+  104a24:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104a2b:	00 
+  104a2c:	c7 44 24 04 f8 01 00 	movl   $0x1f8,0x4(%esp)
+  104a33:	00 
+  104a34:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104a3b:	e8 80 c2 ff ff       	call   100cc0 <__panic>
+
+    ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
+  104a40:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104a45:	8b 00                	mov    (%eax),%eax
+  104a47:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  104a4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  104a4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  104a52:	c1 e8 0c             	shr    $0xc,%eax
+  104a55:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  104a58:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  104a5d:	39 45 e8             	cmp    %eax,-0x18(%ebp)
+  104a60:	72 23                	jb     104a85 <check_pgdir+0x20a>
+  104a62:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  104a65:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  104a69:	c7 44 24 08 3c 6b 10 	movl   $0x106b3c,0x8(%esp)
+  104a70:	00 
+  104a71:	c7 44 24 04 fa 01 00 	movl   $0x1fa,0x4(%esp)
+  104a78:	00 
+  104a79:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104a80:	e8 3b c2 ff ff       	call   100cc0 <__panic>
+  104a85:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  104a88:	2d 00 00 00 40       	sub    $0x40000000,%eax
+  104a8d:	83 c0 04             	add    $0x4,%eax
+  104a90:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
+  104a93:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104a98:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  104a9f:	00 
+  104aa0:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+  104aa7:	00 
+  104aa8:	89 04 24             	mov    %eax,(%esp)
+  104aab:	e8 61 fa ff ff       	call   104511 <get_pte>
+  104ab0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+  104ab3:	74 24                	je     104ad9 <check_pgdir+0x25e>
+  104ab5:	c7 44 24 0c 80 6d 10 	movl   $0x106d80,0xc(%esp)
+  104abc:	00 
+  104abd:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104ac4:	00 
+  104ac5:	c7 44 24 04 fb 01 00 	movl   $0x1fb,0x4(%esp)
+  104acc:	00 
+  104acd:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104ad4:	e8 e7 c1 ff ff       	call   100cc0 <__panic>
+
+    p2 = alloc_page();
+  104ad9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  104ae0:	e8 ed f2 ff ff       	call   103dd2 <alloc_pages>
+  104ae5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
+  104ae8:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104aed:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
+  104af4:	00 
+  104af5:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+  104afc:	00 
+  104afd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  104b00:	89 54 24 04          	mov    %edx,0x4(%esp)
+  104b04:	89 04 24             	mov    %eax,(%esp)
+  104b07:	e8 3b fc ff ff       	call   104747 <page_insert>
+  104b0c:	85 c0                	test   %eax,%eax
+  104b0e:	74 24                	je     104b34 <check_pgdir+0x2b9>
+  104b10:	c7 44 24 0c a8 6d 10 	movl   $0x106da8,0xc(%esp)
+  104b17:	00 
+  104b18:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104b1f:	00 
+  104b20:	c7 44 24 04 fe 01 00 	movl   $0x1fe,0x4(%esp)
+  104b27:	00 
+  104b28:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104b2f:	e8 8c c1 ff ff       	call   100cc0 <__panic>
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+  104b34:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104b39:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  104b40:	00 
+  104b41:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+  104b48:	00 
+  104b49:	89 04 24             	mov    %eax,(%esp)
+  104b4c:	e8 c0 f9 ff ff       	call   104511 <get_pte>
+  104b51:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  104b54:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  104b58:	75 24                	jne    104b7e <check_pgdir+0x303>
+  104b5a:	c7 44 24 0c e0 6d 10 	movl   $0x106de0,0xc(%esp)
+  104b61:	00 
+  104b62:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104b69:	00 
+  104b6a:	c7 44 24 04 ff 01 00 	movl   $0x1ff,0x4(%esp)
+  104b71:	00 
+  104b72:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104b79:	e8 42 c1 ff ff       	call   100cc0 <__panic>
+    assert(*ptep & PTE_U);
+  104b7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104b81:	8b 00                	mov    (%eax),%eax
+  104b83:	83 e0 04             	and    $0x4,%eax
+  104b86:	85 c0                	test   %eax,%eax
+  104b88:	75 24                	jne    104bae <check_pgdir+0x333>
+  104b8a:	c7 44 24 0c 10 6e 10 	movl   $0x106e10,0xc(%esp)
+  104b91:	00 
+  104b92:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104b99:	00 
+  104b9a:	c7 44 24 04 00 02 00 	movl   $0x200,0x4(%esp)
+  104ba1:	00 
+  104ba2:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104ba9:	e8 12 c1 ff ff       	call   100cc0 <__panic>
+    assert(*ptep & PTE_W);
+  104bae:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104bb1:	8b 00                	mov    (%eax),%eax
+  104bb3:	83 e0 02             	and    $0x2,%eax
+  104bb6:	85 c0                	test   %eax,%eax
+  104bb8:	75 24                	jne    104bde <check_pgdir+0x363>
+  104bba:	c7 44 24 0c 1e 6e 10 	movl   $0x106e1e,0xc(%esp)
+  104bc1:	00 
+  104bc2:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104bc9:	00 
+  104bca:	c7 44 24 04 01 02 00 	movl   $0x201,0x4(%esp)
+  104bd1:	00 
+  104bd2:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104bd9:	e8 e2 c0 ff ff       	call   100cc0 <__panic>
+    assert(boot_pgdir[0] & PTE_U);
+  104bde:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104be3:	8b 00                	mov    (%eax),%eax
+  104be5:	83 e0 04             	and    $0x4,%eax
+  104be8:	85 c0                	test   %eax,%eax
+  104bea:	75 24                	jne    104c10 <check_pgdir+0x395>
+  104bec:	c7 44 24 0c 2c 6e 10 	movl   $0x106e2c,0xc(%esp)
+  104bf3:	00 
+  104bf4:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104bfb:	00 
+  104bfc:	c7 44 24 04 02 02 00 	movl   $0x202,0x4(%esp)
+  104c03:	00 
+  104c04:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104c0b:	e8 b0 c0 ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p2) == 1);
+  104c10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  104c13:	89 04 24             	mov    %eax,(%esp)
+  104c16:	e8 b2 ef ff ff       	call   103bcd <page_ref>
+  104c1b:	83 f8 01             	cmp    $0x1,%eax
+  104c1e:	74 24                	je     104c44 <check_pgdir+0x3c9>
+  104c20:	c7 44 24 0c 42 6e 10 	movl   $0x106e42,0xc(%esp)
+  104c27:	00 
+  104c28:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104c2f:	00 
+  104c30:	c7 44 24 04 03 02 00 	movl   $0x203,0x4(%esp)
+  104c37:	00 
+  104c38:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104c3f:	e8 7c c0 ff ff       	call   100cc0 <__panic>
+
+    assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
+  104c44:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104c49:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+  104c50:	00 
+  104c51:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+  104c58:	00 
+  104c59:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  104c5c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  104c60:	89 04 24             	mov    %eax,(%esp)
+  104c63:	e8 df fa ff ff       	call   104747 <page_insert>
+  104c68:	85 c0                	test   %eax,%eax
+  104c6a:	74 24                	je     104c90 <check_pgdir+0x415>
+  104c6c:	c7 44 24 0c 54 6e 10 	movl   $0x106e54,0xc(%esp)
+  104c73:	00 
+  104c74:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104c7b:	00 
+  104c7c:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
+  104c83:	00 
+  104c84:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104c8b:	e8 30 c0 ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p1) == 2);
+  104c90:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104c93:	89 04 24             	mov    %eax,(%esp)
+  104c96:	e8 32 ef ff ff       	call   103bcd <page_ref>
+  104c9b:	83 f8 02             	cmp    $0x2,%eax
+  104c9e:	74 24                	je     104cc4 <check_pgdir+0x449>
+  104ca0:	c7 44 24 0c 80 6e 10 	movl   $0x106e80,0xc(%esp)
+  104ca7:	00 
+  104ca8:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104caf:	00 
+  104cb0:	c7 44 24 04 06 02 00 	movl   $0x206,0x4(%esp)
+  104cb7:	00 
+  104cb8:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104cbf:	e8 fc bf ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p2) == 0);
+  104cc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  104cc7:	89 04 24             	mov    %eax,(%esp)
+  104cca:	e8 fe ee ff ff       	call   103bcd <page_ref>
+  104ccf:	85 c0                	test   %eax,%eax
+  104cd1:	74 24                	je     104cf7 <check_pgdir+0x47c>
+  104cd3:	c7 44 24 0c 92 6e 10 	movl   $0x106e92,0xc(%esp)
+  104cda:	00 
+  104cdb:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104ce2:	00 
+  104ce3:	c7 44 24 04 07 02 00 	movl   $0x207,0x4(%esp)
+  104cea:	00 
+  104ceb:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104cf2:	e8 c9 bf ff ff       	call   100cc0 <__panic>
+    assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
+  104cf7:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104cfc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  104d03:	00 
+  104d04:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+  104d0b:	00 
+  104d0c:	89 04 24             	mov    %eax,(%esp)
+  104d0f:	e8 fd f7 ff ff       	call   104511 <get_pte>
+  104d14:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  104d17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  104d1b:	75 24                	jne    104d41 <check_pgdir+0x4c6>
+  104d1d:	c7 44 24 0c e0 6d 10 	movl   $0x106de0,0xc(%esp)
+  104d24:	00 
+  104d25:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104d2c:	00 
+  104d2d:	c7 44 24 04 08 02 00 	movl   $0x208,0x4(%esp)
+  104d34:	00 
+  104d35:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104d3c:	e8 7f bf ff ff       	call   100cc0 <__panic>
+    assert(pa2page(*ptep) == p1);
+  104d41:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104d44:	8b 00                	mov    (%eax),%eax
+  104d46:	89 04 24             	mov    %eax,(%esp)
+  104d49:	e8 9e ed ff ff       	call   103aec <pa2page>
+  104d4e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  104d51:	74 24                	je     104d77 <check_pgdir+0x4fc>
+  104d53:	c7 44 24 0c 59 6d 10 	movl   $0x106d59,0xc(%esp)
+  104d5a:	00 
+  104d5b:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104d62:	00 
+  104d63:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
+  104d6a:	00 
+  104d6b:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104d72:	e8 49 bf ff ff       	call   100cc0 <__panic>
+    assert((*ptep & PTE_U) == 0);
+  104d77:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104d7a:	8b 00                	mov    (%eax),%eax
+  104d7c:	83 e0 04             	and    $0x4,%eax
+  104d7f:	85 c0                	test   %eax,%eax
+  104d81:	74 24                	je     104da7 <check_pgdir+0x52c>
+  104d83:	c7 44 24 0c a4 6e 10 	movl   $0x106ea4,0xc(%esp)
+  104d8a:	00 
+  104d8b:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104d92:	00 
+  104d93:	c7 44 24 04 0a 02 00 	movl   $0x20a,0x4(%esp)
+  104d9a:	00 
+  104d9b:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104da2:	e8 19 bf ff ff       	call   100cc0 <__panic>
+
+    page_remove(boot_pgdir, 0x0);
+  104da7:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104dac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  104db3:	00 
+  104db4:	89 04 24             	mov    %eax,(%esp)
+  104db7:	e8 47 f9 ff ff       	call   104703 <page_remove>
+    assert(page_ref(p1) == 1);
+  104dbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104dbf:	89 04 24             	mov    %eax,(%esp)
+  104dc2:	e8 06 ee ff ff       	call   103bcd <page_ref>
+  104dc7:	83 f8 01             	cmp    $0x1,%eax
+  104dca:	74 24                	je     104df0 <check_pgdir+0x575>
+  104dcc:	c7 44 24 0c 6e 6d 10 	movl   $0x106d6e,0xc(%esp)
+  104dd3:	00 
+  104dd4:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104ddb:	00 
+  104ddc:	c7 44 24 04 0d 02 00 	movl   $0x20d,0x4(%esp)
+  104de3:	00 
+  104de4:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104deb:	e8 d0 be ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p2) == 0);
+  104df0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  104df3:	89 04 24             	mov    %eax,(%esp)
+  104df6:	e8 d2 ed ff ff       	call   103bcd <page_ref>
+  104dfb:	85 c0                	test   %eax,%eax
+  104dfd:	74 24                	je     104e23 <check_pgdir+0x5a8>
+  104dff:	c7 44 24 0c 92 6e 10 	movl   $0x106e92,0xc(%esp)
+  104e06:	00 
+  104e07:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104e0e:	00 
+  104e0f:	c7 44 24 04 0e 02 00 	movl   $0x20e,0x4(%esp)
+  104e16:	00 
+  104e17:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104e1e:	e8 9d be ff ff       	call   100cc0 <__panic>
+
+    page_remove(boot_pgdir, PGSIZE);
+  104e23:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104e28:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+  104e2f:	00 
+  104e30:	89 04 24             	mov    %eax,(%esp)
+  104e33:	e8 cb f8 ff ff       	call   104703 <page_remove>
+    assert(page_ref(p1) == 0);
+  104e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104e3b:	89 04 24             	mov    %eax,(%esp)
+  104e3e:	e8 8a ed ff ff       	call   103bcd <page_ref>
+  104e43:	85 c0                	test   %eax,%eax
+  104e45:	74 24                	je     104e6b <check_pgdir+0x5f0>
+  104e47:	c7 44 24 0c b9 6e 10 	movl   $0x106eb9,0xc(%esp)
+  104e4e:	00 
+  104e4f:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104e56:	00 
+  104e57:	c7 44 24 04 11 02 00 	movl   $0x211,0x4(%esp)
+  104e5e:	00 
+  104e5f:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104e66:	e8 55 be ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p2) == 0);
+  104e6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  104e6e:	89 04 24             	mov    %eax,(%esp)
+  104e71:	e8 57 ed ff ff       	call   103bcd <page_ref>
+  104e76:	85 c0                	test   %eax,%eax
+  104e78:	74 24                	je     104e9e <check_pgdir+0x623>
+  104e7a:	c7 44 24 0c 92 6e 10 	movl   $0x106e92,0xc(%esp)
+  104e81:	00 
+  104e82:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104e89:	00 
+  104e8a:	c7 44 24 04 12 02 00 	movl   $0x212,0x4(%esp)
+  104e91:	00 
+  104e92:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104e99:	e8 22 be ff ff       	call   100cc0 <__panic>
+
+    assert(page_ref(pa2page(boot_pgdir[0])) == 1);
+  104e9e:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104ea3:	8b 00                	mov    (%eax),%eax
+  104ea5:	89 04 24             	mov    %eax,(%esp)
+  104ea8:	e8 3f ec ff ff       	call   103aec <pa2page>
+  104ead:	89 04 24             	mov    %eax,(%esp)
+  104eb0:	e8 18 ed ff ff       	call   103bcd <page_ref>
+  104eb5:	83 f8 01             	cmp    $0x1,%eax
+  104eb8:	74 24                	je     104ede <check_pgdir+0x663>
+  104eba:	c7 44 24 0c cc 6e 10 	movl   $0x106ecc,0xc(%esp)
+  104ec1:	00 
+  104ec2:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104ec9:	00 
+  104eca:	c7 44 24 04 14 02 00 	movl   $0x214,0x4(%esp)
+  104ed1:	00 
+  104ed2:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104ed9:	e8 e2 bd ff ff       	call   100cc0 <__panic>
+    free_page(pa2page(boot_pgdir[0]));
+  104ede:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104ee3:	8b 00                	mov    (%eax),%eax
+  104ee5:	89 04 24             	mov    %eax,(%esp)
+  104ee8:	e8 ff eb ff ff       	call   103aec <pa2page>
+  104eed:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  104ef4:	00 
+  104ef5:	89 04 24             	mov    %eax,(%esp)
+  104ef8:	e8 0d ef ff ff       	call   103e0a <free_pages>
+    boot_pgdir[0] = 0;
+  104efd:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104f02:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    cprintf("check_pgdir() succeeded!\n");
+  104f08:	c7 04 24 f2 6e 10 00 	movl   $0x106ef2,(%esp)
+  104f0f:	e8 28 b4 ff ff       	call   10033c <cprintf>
+}
+  104f14:	c9                   	leave  
+  104f15:	c3                   	ret    
+
+00104f16 <check_boot_pgdir>:
+
+static void
+check_boot_pgdir(void) {
+  104f16:	55                   	push   %ebp
+  104f17:	89 e5                	mov    %esp,%ebp
+  104f19:	83 ec 38             	sub    $0x38,%esp
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+  104f1c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  104f23:	e9 ca 00 00 00       	jmp    104ff2 <check_boot_pgdir+0xdc>
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+  104f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104f2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  104f2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104f31:	c1 e8 0c             	shr    $0xc,%eax
+  104f34:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  104f37:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  104f3c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+  104f3f:	72 23                	jb     104f64 <check_boot_pgdir+0x4e>
+  104f41:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104f44:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  104f48:	c7 44 24 08 3c 6b 10 	movl   $0x106b3c,0x8(%esp)
+  104f4f:	00 
+  104f50:	c7 44 24 04 20 02 00 	movl   $0x220,0x4(%esp)
+  104f57:	00 
+  104f58:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104f5f:	e8 5c bd ff ff       	call   100cc0 <__panic>
+  104f64:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  104f67:	2d 00 00 00 40       	sub    $0x40000000,%eax
+  104f6c:	89 c2                	mov    %eax,%edx
+  104f6e:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  104f73:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  104f7a:	00 
+  104f7b:	89 54 24 04          	mov    %edx,0x4(%esp)
+  104f7f:	89 04 24             	mov    %eax,(%esp)
+  104f82:	e8 8a f5 ff ff       	call   104511 <get_pte>
+  104f87:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  104f8a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  104f8e:	75 24                	jne    104fb4 <check_boot_pgdir+0x9e>
+  104f90:	c7 44 24 0c 0c 6f 10 	movl   $0x106f0c,0xc(%esp)
+  104f97:	00 
+  104f98:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104f9f:	00 
+  104fa0:	c7 44 24 04 20 02 00 	movl   $0x220,0x4(%esp)
+  104fa7:	00 
+  104fa8:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104faf:	e8 0c bd ff ff       	call   100cc0 <__panic>
+        assert(PTE_ADDR(*ptep) == i);
+  104fb4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  104fb7:	8b 00                	mov    (%eax),%eax
+  104fb9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  104fbe:	89 c2                	mov    %eax,%edx
+  104fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  104fc3:	39 c2                	cmp    %eax,%edx
+  104fc5:	74 24                	je     104feb <check_boot_pgdir+0xd5>
+  104fc7:	c7 44 24 0c 49 6f 10 	movl   $0x106f49,0xc(%esp)
+  104fce:	00 
+  104fcf:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  104fd6:	00 
+  104fd7:	c7 44 24 04 21 02 00 	movl   $0x221,0x4(%esp)
+  104fde:	00 
+  104fdf:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  104fe6:	e8 d5 bc ff ff       	call   100cc0 <__panic>
+
+static void
+check_boot_pgdir(void) {
+    pte_t *ptep;
+    int i;
+    for (i = 0; i < npage; i += PGSIZE) {
+  104feb:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+  104ff2:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  104ff5:	a1 c0 88 11 00       	mov    0x1188c0,%eax
+  104ffa:	39 c2                	cmp    %eax,%edx
+  104ffc:	0f 82 26 ff ff ff    	jb     104f28 <check_boot_pgdir+0x12>
+        assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
+        assert(PTE_ADDR(*ptep) == i);
+    }
+
+    assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
+  105002:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  105007:	05 ac 0f 00 00       	add    $0xfac,%eax
+  10500c:	8b 00                	mov    (%eax),%eax
+  10500e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  105013:	89 c2                	mov    %eax,%edx
+  105015:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  10501a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  10501d:	81 7d e4 ff ff ff bf 	cmpl   $0xbfffffff,-0x1c(%ebp)
+  105024:	77 23                	ja     105049 <check_boot_pgdir+0x133>
+  105026:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  105029:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  10502d:	c7 44 24 08 e0 6b 10 	movl   $0x106be0,0x8(%esp)
+  105034:	00 
+  105035:	c7 44 24 04 24 02 00 	movl   $0x224,0x4(%esp)
+  10503c:	00 
+  10503d:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  105044:	e8 77 bc ff ff       	call   100cc0 <__panic>
+  105049:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10504c:	05 00 00 00 40       	add    $0x40000000,%eax
+  105051:	39 c2                	cmp    %eax,%edx
+  105053:	74 24                	je     105079 <check_boot_pgdir+0x163>
+  105055:	c7 44 24 0c 60 6f 10 	movl   $0x106f60,0xc(%esp)
+  10505c:	00 
+  10505d:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  105064:	00 
+  105065:	c7 44 24 04 24 02 00 	movl   $0x224,0x4(%esp)
+  10506c:	00 
+  10506d:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  105074:	e8 47 bc ff ff       	call   100cc0 <__panic>
+
+    assert(boot_pgdir[0] == 0);
+  105079:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  10507e:	8b 00                	mov    (%eax),%eax
+  105080:	85 c0                	test   %eax,%eax
+  105082:	74 24                	je     1050a8 <check_boot_pgdir+0x192>
+  105084:	c7 44 24 0c 94 6f 10 	movl   $0x106f94,0xc(%esp)
+  10508b:	00 
+  10508c:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  105093:	00 
+  105094:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
+  10509b:	00 
+  10509c:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1050a3:	e8 18 bc ff ff       	call   100cc0 <__panic>
+
+    struct Page *p;
+    p = alloc_page();
+  1050a8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1050af:	e8 1e ed ff ff       	call   103dd2 <alloc_pages>
+  1050b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
+  1050b7:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  1050bc:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+  1050c3:	00 
+  1050c4:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
+  1050cb:	00 
+  1050cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  1050cf:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1050d3:	89 04 24             	mov    %eax,(%esp)
+  1050d6:	e8 6c f6 ff ff       	call   104747 <page_insert>
+  1050db:	85 c0                	test   %eax,%eax
+  1050dd:	74 24                	je     105103 <check_boot_pgdir+0x1ed>
+  1050df:	c7 44 24 0c a8 6f 10 	movl   $0x106fa8,0xc(%esp)
+  1050e6:	00 
+  1050e7:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  1050ee:	00 
+  1050ef:	c7 44 24 04 2a 02 00 	movl   $0x22a,0x4(%esp)
+  1050f6:	00 
+  1050f7:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1050fe:	e8 bd bb ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p) == 1);
+  105103:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105106:	89 04 24             	mov    %eax,(%esp)
+  105109:	e8 bf ea ff ff       	call   103bcd <page_ref>
+  10510e:	83 f8 01             	cmp    $0x1,%eax
+  105111:	74 24                	je     105137 <check_boot_pgdir+0x221>
+  105113:	c7 44 24 0c d6 6f 10 	movl   $0x106fd6,0xc(%esp)
+  10511a:	00 
+  10511b:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  105122:	00 
+  105123:	c7 44 24 04 2b 02 00 	movl   $0x22b,0x4(%esp)
+  10512a:	00 
+  10512b:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  105132:	e8 89 bb ff ff       	call   100cc0 <__panic>
+    assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
+  105137:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  10513c:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+  105143:	00 
+  105144:	c7 44 24 08 00 11 00 	movl   $0x1100,0x8(%esp)
+  10514b:	00 
+  10514c:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  10514f:	89 54 24 04          	mov    %edx,0x4(%esp)
+  105153:	89 04 24             	mov    %eax,(%esp)
+  105156:	e8 ec f5 ff ff       	call   104747 <page_insert>
+  10515b:	85 c0                	test   %eax,%eax
+  10515d:	74 24                	je     105183 <check_boot_pgdir+0x26d>
+  10515f:	c7 44 24 0c e8 6f 10 	movl   $0x106fe8,0xc(%esp)
+  105166:	00 
+  105167:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  10516e:	00 
+  10516f:	c7 44 24 04 2c 02 00 	movl   $0x22c,0x4(%esp)
+  105176:	00 
+  105177:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  10517e:	e8 3d bb ff ff       	call   100cc0 <__panic>
+    assert(page_ref(p) == 2);
+  105183:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105186:	89 04 24             	mov    %eax,(%esp)
+  105189:	e8 3f ea ff ff       	call   103bcd <page_ref>
+  10518e:	83 f8 02             	cmp    $0x2,%eax
+  105191:	74 24                	je     1051b7 <check_boot_pgdir+0x2a1>
+  105193:	c7 44 24 0c 1f 70 10 	movl   $0x10701f,0xc(%esp)
+  10519a:	00 
+  10519b:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  1051a2:	00 
+  1051a3:	c7 44 24 04 2d 02 00 	movl   $0x22d,0x4(%esp)
+  1051aa:	00 
+  1051ab:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  1051b2:	e8 09 bb ff ff       	call   100cc0 <__panic>
+
+    const char *str = "ucore: Hello world!!";
+  1051b7:	c7 45 dc 30 70 10 00 	movl   $0x107030,-0x24(%ebp)
+    strcpy((void *)0x100, str);
+  1051be:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  1051c1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1051c5:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+  1051cc:	e8 1e 0a 00 00       	call   105bef <strcpy>
+    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
+  1051d1:	c7 44 24 04 00 11 00 	movl   $0x1100,0x4(%esp)
+  1051d8:	00 
+  1051d9:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+  1051e0:	e8 83 0a 00 00       	call   105c68 <strcmp>
+  1051e5:	85 c0                	test   %eax,%eax
+  1051e7:	74 24                	je     10520d <check_boot_pgdir+0x2f7>
+  1051e9:	c7 44 24 0c 48 70 10 	movl   $0x107048,0xc(%esp)
+  1051f0:	00 
+  1051f1:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  1051f8:	00 
+  1051f9:	c7 44 24 04 31 02 00 	movl   $0x231,0x4(%esp)
+  105200:	00 
+  105201:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  105208:	e8 b3 ba ff ff       	call   100cc0 <__panic>
+
+    *(char *)(page2kva(p) + 0x100) = '\0';
+  10520d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105210:	89 04 24             	mov    %eax,(%esp)
+  105213:	e8 23 e9 ff ff       	call   103b3b <page2kva>
+  105218:	05 00 01 00 00       	add    $0x100,%eax
+  10521d:	c6 00 00             	movb   $0x0,(%eax)
+    assert(strlen((const char *)0x100) == 0);
+  105220:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+  105227:	e8 6b 09 00 00       	call   105b97 <strlen>
+  10522c:	85 c0                	test   %eax,%eax
+  10522e:	74 24                	je     105254 <check_boot_pgdir+0x33e>
+  105230:	c7 44 24 0c 80 70 10 	movl   $0x107080,0xc(%esp)
+  105237:	00 
+  105238:	c7 44 24 08 29 6c 10 	movl   $0x106c29,0x8(%esp)
+  10523f:	00 
+  105240:	c7 44 24 04 34 02 00 	movl   $0x234,0x4(%esp)
+  105247:	00 
+  105248:	c7 04 24 04 6c 10 00 	movl   $0x106c04,(%esp)
+  10524f:	e8 6c ba ff ff       	call   100cc0 <__panic>
+
+    free_page(p);
+  105254:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  10525b:	00 
+  10525c:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  10525f:	89 04 24             	mov    %eax,(%esp)
+  105262:	e8 a3 eb ff ff       	call   103e0a <free_pages>
+    free_page(pa2page(PDE_ADDR(boot_pgdir[0])));
+  105267:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  10526c:	8b 00                	mov    (%eax),%eax
+  10526e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+  105273:	89 04 24             	mov    %eax,(%esp)
+  105276:	e8 71 e8 ff ff       	call   103aec <pa2page>
+  10527b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+  105282:	00 
+  105283:	89 04 24             	mov    %eax,(%esp)
+  105286:	e8 7f eb ff ff       	call   103e0a <free_pages>
+    boot_pgdir[0] = 0;
+  10528b:	a1 c4 88 11 00       	mov    0x1188c4,%eax
+  105290:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+    cprintf("check_boot_pgdir() succeeded!\n");
+  105296:	c7 04 24 a4 70 10 00 	movl   $0x1070a4,(%esp)
+  10529d:	e8 9a b0 ff ff       	call   10033c <cprintf>
+}
+  1052a2:	c9                   	leave  
+  1052a3:	c3                   	ret    
+
+001052a4 <perm2str>:
+
+//perm2str - use string 'u,r,w,-' to present the permission
+static const char *
+perm2str(int perm) {
+  1052a4:	55                   	push   %ebp
+  1052a5:	89 e5                	mov    %esp,%ebp
+    static char str[4];
+    str[0] = (perm & PTE_U) ? 'u' : '-';
+  1052a7:	8b 45 08             	mov    0x8(%ebp),%eax
+  1052aa:	83 e0 04             	and    $0x4,%eax
+  1052ad:	85 c0                	test   %eax,%eax
+  1052af:	74 07                	je     1052b8 <perm2str+0x14>
+  1052b1:	b8 75 00 00 00       	mov    $0x75,%eax
+  1052b6:	eb 05                	jmp    1052bd <perm2str+0x19>
+  1052b8:	b8 2d 00 00 00       	mov    $0x2d,%eax
+  1052bd:	a2 48 89 11 00       	mov    %al,0x118948
+    str[1] = 'r';
+  1052c2:	c6 05 49 89 11 00 72 	movb   $0x72,0x118949
+    str[2] = (perm & PTE_W) ? 'w' : '-';
+  1052c9:	8b 45 08             	mov    0x8(%ebp),%eax
+  1052cc:	83 e0 02             	and    $0x2,%eax
+  1052cf:	85 c0                	test   %eax,%eax
+  1052d1:	74 07                	je     1052da <perm2str+0x36>
+  1052d3:	b8 77 00 00 00       	mov    $0x77,%eax
+  1052d8:	eb 05                	jmp    1052df <perm2str+0x3b>
+  1052da:	b8 2d 00 00 00       	mov    $0x2d,%eax
+  1052df:	a2 4a 89 11 00       	mov    %al,0x11894a
+    str[3] = '\0';
+  1052e4:	c6 05 4b 89 11 00 00 	movb   $0x0,0x11894b
+    return str;
+  1052eb:	b8 48 89 11 00       	mov    $0x118948,%eax
+}
+  1052f0:	5d                   	pop    %ebp
+  1052f1:	c3                   	ret    
+
+001052f2 <get_pgtable_items>:
+//  table:       the beginning addr of table
+//  left_store:  the pointer of the high side of table's next range
+//  right_store: the pointer of the low side of table's next range
+// return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+  1052f2:	55                   	push   %ebp
+  1052f3:	89 e5                	mov    %esp,%ebp
+  1052f5:	83 ec 10             	sub    $0x10,%esp
+    if (start >= right) {
+  1052f8:	8b 45 10             	mov    0x10(%ebp),%eax
+  1052fb:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  1052fe:	72 0a                	jb     10530a <get_pgtable_items+0x18>
+        return 0;
+  105300:	b8 00 00 00 00       	mov    $0x0,%eax
+  105305:	e9 9c 00 00 00       	jmp    1053a6 <get_pgtable_items+0xb4>
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+  10530a:	eb 04                	jmp    105310 <get_pgtable_items+0x1e>
+        start ++;
+  10530c:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+static int
+get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
+    if (start >= right) {
+        return 0;
+    }
+    while (start < right && !(table[start] & PTE_P)) {
+  105310:	8b 45 10             	mov    0x10(%ebp),%eax
+  105313:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  105316:	73 18                	jae    105330 <get_pgtable_items+0x3e>
+  105318:	8b 45 10             	mov    0x10(%ebp),%eax
+  10531b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  105322:	8b 45 14             	mov    0x14(%ebp),%eax
+  105325:	01 d0                	add    %edx,%eax
+  105327:	8b 00                	mov    (%eax),%eax
+  105329:	83 e0 01             	and    $0x1,%eax
+  10532c:	85 c0                	test   %eax,%eax
+  10532e:	74 dc                	je     10530c <get_pgtable_items+0x1a>
+        start ++;
+    }
+    if (start < right) {
+  105330:	8b 45 10             	mov    0x10(%ebp),%eax
+  105333:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  105336:	73 69                	jae    1053a1 <get_pgtable_items+0xaf>
+        if (left_store != NULL) {
+  105338:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
+  10533c:	74 08                	je     105346 <get_pgtable_items+0x54>
+            *left_store = start;
+  10533e:	8b 45 18             	mov    0x18(%ebp),%eax
+  105341:	8b 55 10             	mov    0x10(%ebp),%edx
+  105344:	89 10                	mov    %edx,(%eax)
+        }
+        int perm = (table[start ++] & PTE_USER);
+  105346:	8b 45 10             	mov    0x10(%ebp),%eax
+  105349:	8d 50 01             	lea    0x1(%eax),%edx
+  10534c:	89 55 10             	mov    %edx,0x10(%ebp)
+  10534f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  105356:	8b 45 14             	mov    0x14(%ebp),%eax
+  105359:	01 d0                	add    %edx,%eax
+  10535b:	8b 00                	mov    (%eax),%eax
+  10535d:	83 e0 07             	and    $0x7,%eax
+  105360:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        while (start < right && (table[start] & PTE_USER) == perm) {
+  105363:	eb 04                	jmp    105369 <get_pgtable_items+0x77>
+            start ++;
+  105365:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+    if (start < right) {
+        if (left_store != NULL) {
+            *left_store = start;
+        }
+        int perm = (table[start ++] & PTE_USER);
+        while (start < right && (table[start] & PTE_USER) == perm) {
+  105369:	8b 45 10             	mov    0x10(%ebp),%eax
+  10536c:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  10536f:	73 1d                	jae    10538e <get_pgtable_items+0x9c>
+  105371:	8b 45 10             	mov    0x10(%ebp),%eax
+  105374:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  10537b:	8b 45 14             	mov    0x14(%ebp),%eax
+  10537e:	01 d0                	add    %edx,%eax
+  105380:	8b 00                	mov    (%eax),%eax
+  105382:	83 e0 07             	and    $0x7,%eax
+  105385:	89 c2                	mov    %eax,%edx
+  105387:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10538a:	39 c2                	cmp    %eax,%edx
+  10538c:	74 d7                	je     105365 <get_pgtable_items+0x73>
+            start ++;
+        }
+        if (right_store != NULL) {
+  10538e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  105392:	74 08                	je     10539c <get_pgtable_items+0xaa>
+            *right_store = start;
+  105394:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  105397:	8b 55 10             	mov    0x10(%ebp),%edx
+  10539a:	89 10                	mov    %edx,(%eax)
+        }
+        return perm;
+  10539c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10539f:	eb 05                	jmp    1053a6 <get_pgtable_items+0xb4>
+    }
+    return 0;
+  1053a1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  1053a6:	c9                   	leave  
+  1053a7:	c3                   	ret    
+
+001053a8 <print_pgdir>:
+
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+  1053a8:	55                   	push   %ebp
+  1053a9:	89 e5                	mov    %esp,%ebp
+  1053ab:	57                   	push   %edi
+  1053ac:	56                   	push   %esi
+  1053ad:	53                   	push   %ebx
+  1053ae:	83 ec 4c             	sub    $0x4c,%esp
+    cprintf("-------------------- BEGIN --------------------\n");
+  1053b1:	c7 04 24 c4 70 10 00 	movl   $0x1070c4,(%esp)
+  1053b8:	e8 7f af ff ff       	call   10033c <cprintf>
+    size_t left, right = 0, perm;
+  1053bd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+  1053c4:	e9 fa 00 00 00       	jmp    1054c3 <print_pgdir+0x11b>
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+  1053c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1053cc:	89 04 24             	mov    %eax,(%esp)
+  1053cf:	e8 d0 fe ff ff       	call   1052a4 <perm2str>
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+  1053d4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  1053d7:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  1053da:	29 d1                	sub    %edx,%ecx
+  1053dc:	89 ca                	mov    %ecx,%edx
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+  1053de:	89 d6                	mov    %edx,%esi
+  1053e0:	c1 e6 16             	shl    $0x16,%esi
+  1053e3:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  1053e6:	89 d3                	mov    %edx,%ebx
+  1053e8:	c1 e3 16             	shl    $0x16,%ebx
+  1053eb:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  1053ee:	89 d1                	mov    %edx,%ecx
+  1053f0:	c1 e1 16             	shl    $0x16,%ecx
+  1053f3:	8b 7d dc             	mov    -0x24(%ebp),%edi
+  1053f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  1053f9:	29 d7                	sub    %edx,%edi
+  1053fb:	89 fa                	mov    %edi,%edx
+  1053fd:	89 44 24 14          	mov    %eax,0x14(%esp)
+  105401:	89 74 24 10          	mov    %esi,0x10(%esp)
+  105405:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  105409:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  10540d:	89 54 24 04          	mov    %edx,0x4(%esp)
+  105411:	c7 04 24 f5 70 10 00 	movl   $0x1070f5,(%esp)
+  105418:	e8 1f af ff ff       	call   10033c <cprintf>
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+  10541d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105420:	c1 e0 0a             	shl    $0xa,%eax
+  105423:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+  105426:	eb 54                	jmp    10547c <print_pgdir+0xd4>
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+  105428:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10542b:	89 04 24             	mov    %eax,(%esp)
+  10542e:	e8 71 fe ff ff       	call   1052a4 <perm2str>
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+  105433:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
+  105436:	8b 55 d8             	mov    -0x28(%ebp),%edx
+  105439:	29 d1                	sub    %edx,%ecx
+  10543b:	89 ca                	mov    %ecx,%edx
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+  10543d:	89 d6                	mov    %edx,%esi
+  10543f:	c1 e6 0c             	shl    $0xc,%esi
+  105442:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  105445:	89 d3                	mov    %edx,%ebx
+  105447:	c1 e3 0c             	shl    $0xc,%ebx
+  10544a:	8b 55 d8             	mov    -0x28(%ebp),%edx
+  10544d:	c1 e2 0c             	shl    $0xc,%edx
+  105450:	89 d1                	mov    %edx,%ecx
+  105452:	8b 7d d4             	mov    -0x2c(%ebp),%edi
+  105455:	8b 55 d8             	mov    -0x28(%ebp),%edx
+  105458:	29 d7                	sub    %edx,%edi
+  10545a:	89 fa                	mov    %edi,%edx
+  10545c:	89 44 24 14          	mov    %eax,0x14(%esp)
+  105460:	89 74 24 10          	mov    %esi,0x10(%esp)
+  105464:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  105468:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  10546c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  105470:	c7 04 24 14 71 10 00 	movl   $0x107114,(%esp)
+  105477:	e8 c0 ae ff ff       	call   10033c <cprintf>
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+        cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
+                left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
+        size_t l, r = left * NPTEENTRY;
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+  10547c:	ba 00 00 c0 fa       	mov    $0xfac00000,%edx
+  105481:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  105484:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  105487:	89 ce                	mov    %ecx,%esi
+  105489:	c1 e6 0a             	shl    $0xa,%esi
+  10548c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
+  10548f:	89 cb                	mov    %ecx,%ebx
+  105491:	c1 e3 0a             	shl    $0xa,%ebx
+  105494:	8d 4d d4             	lea    -0x2c(%ebp),%ecx
+  105497:	89 4c 24 14          	mov    %ecx,0x14(%esp)
+  10549b:	8d 4d d8             	lea    -0x28(%ebp),%ecx
+  10549e:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  1054a2:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  1054a6:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1054aa:	89 74 24 04          	mov    %esi,0x4(%esp)
+  1054ae:	89 1c 24             	mov    %ebx,(%esp)
+  1054b1:	e8 3c fe ff ff       	call   1052f2 <get_pgtable_items>
+  1054b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  1054b9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  1054bd:	0f 85 65 ff ff ff    	jne    105428 <print_pgdir+0x80>
+//print_pgdir - print the PDT&PT
+void
+print_pgdir(void) {
+    cprintf("-------------------- BEGIN --------------------\n");
+    size_t left, right = 0, perm;
+    while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
+  1054c3:	ba 00 b0 fe fa       	mov    $0xfafeb000,%edx
+  1054c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  1054cb:	8d 4d dc             	lea    -0x24(%ebp),%ecx
+  1054ce:	89 4c 24 14          	mov    %ecx,0x14(%esp)
+  1054d2:	8d 4d e0             	lea    -0x20(%ebp),%ecx
+  1054d5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+  1054d9:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  1054dd:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1054e1:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
+  1054e8:	00 
+  1054e9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  1054f0:	e8 fd fd ff ff       	call   1052f2 <get_pgtable_items>
+  1054f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  1054f8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  1054fc:	0f 85 c7 fe ff ff    	jne    1053c9 <print_pgdir+0x21>
+        while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
+            cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
+                    l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
+        }
+    }
+    cprintf("--------------------- END ---------------------\n");
+  105502:	c7 04 24 38 71 10 00 	movl   $0x107138,(%esp)
+  105509:	e8 2e ae ff ff       	call   10033c <cprintf>
+}
+  10550e:	83 c4 4c             	add    $0x4c,%esp
+  105511:	5b                   	pop    %ebx
+  105512:	5e                   	pop    %esi
+  105513:	5f                   	pop    %edi
+  105514:	5d                   	pop    %ebp
+  105515:	c3                   	ret    
+
+00105516 <printnum>:
+ * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:       character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  105516:	55                   	push   %ebp
+  105517:	89 e5                	mov    %esp,%ebp
+  105519:	83 ec 58             	sub    $0x58,%esp
+  10551c:	8b 45 10             	mov    0x10(%ebp),%eax
+  10551f:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  105522:	8b 45 14             	mov    0x14(%ebp),%eax
+  105525:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  105528:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  10552b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  10552e:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  105531:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  105534:	8b 45 18             	mov    0x18(%ebp),%eax
+  105537:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  10553a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  10553d:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  105540:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  105543:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  105546:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105549:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  10554c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  105550:	74 1c                	je     10556e <printnum+0x58>
+  105552:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105555:	ba 00 00 00 00       	mov    $0x0,%edx
+  10555a:	f7 75 e4             	divl   -0x1c(%ebp)
+  10555d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  105560:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105563:	ba 00 00 00 00       	mov    $0x0,%edx
+  105568:	f7 75 e4             	divl   -0x1c(%ebp)
+  10556b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  10556e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105571:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  105574:	f7 75 e4             	divl   -0x1c(%ebp)
+  105577:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  10557a:	89 55 dc             	mov    %edx,-0x24(%ebp)
+  10557d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105580:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  105583:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  105586:	89 55 ec             	mov    %edx,-0x14(%ebp)
+  105589:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  10558c:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  10558f:	8b 45 18             	mov    0x18(%ebp),%eax
+  105592:	ba 00 00 00 00       	mov    $0x0,%edx
+  105597:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  10559a:	77 56                	ja     1055f2 <printnum+0xdc>
+  10559c:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  10559f:	72 05                	jb     1055a6 <printnum+0x90>
+  1055a1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  1055a4:	77 4c                	ja     1055f2 <printnum+0xdc>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  1055a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  1055a9:	8d 50 ff             	lea    -0x1(%eax),%edx
+  1055ac:	8b 45 20             	mov    0x20(%ebp),%eax
+  1055af:	89 44 24 18          	mov    %eax,0x18(%esp)
+  1055b3:	89 54 24 14          	mov    %edx,0x14(%esp)
+  1055b7:	8b 45 18             	mov    0x18(%ebp),%eax
+  1055ba:	89 44 24 10          	mov    %eax,0x10(%esp)
+  1055be:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  1055c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  1055c4:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1055c8:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  1055cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1055cf:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1055d3:	8b 45 08             	mov    0x8(%ebp),%eax
+  1055d6:	89 04 24             	mov    %eax,(%esp)
+  1055d9:	e8 38 ff ff ff       	call   105516 <printnum>
+  1055de:	eb 1c                	jmp    1055fc <printnum+0xe6>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  1055e0:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1055e3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1055e7:	8b 45 20             	mov    0x20(%ebp),%eax
+  1055ea:	89 04 24             	mov    %eax,(%esp)
+  1055ed:	8b 45 08             	mov    0x8(%ebp),%eax
+  1055f0:	ff d0                	call   *%eax
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+        printnum(putch, putdat, result, base, width - 1, padc);
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+  1055f2:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  1055f6:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  1055fa:	7f e4                	jg     1055e0 <printnum+0xca>
+            putch(padc, putdat);
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  1055fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  1055ff:	05 ec 71 10 00       	add    $0x1071ec,%eax
+  105604:	0f b6 00             	movzbl (%eax),%eax
+  105607:	0f be c0             	movsbl %al,%eax
+  10560a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  10560d:	89 54 24 04          	mov    %edx,0x4(%esp)
+  105611:	89 04 24             	mov    %eax,(%esp)
+  105614:	8b 45 08             	mov    0x8(%ebp),%eax
+  105617:	ff d0                	call   *%eax
+}
+  105619:	c9                   	leave  
+  10561a:	c3                   	ret    
+
+0010561b <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  10561b:	55                   	push   %ebp
+  10561c:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  10561e:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  105622:	7e 14                	jle    105638 <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  105624:	8b 45 08             	mov    0x8(%ebp),%eax
+  105627:	8b 00                	mov    (%eax),%eax
+  105629:	8d 48 08             	lea    0x8(%eax),%ecx
+  10562c:	8b 55 08             	mov    0x8(%ebp),%edx
+  10562f:	89 0a                	mov    %ecx,(%edx)
+  105631:	8b 50 04             	mov    0x4(%eax),%edx
+  105634:	8b 00                	mov    (%eax),%eax
+  105636:	eb 30                	jmp    105668 <getuint+0x4d>
+    }
+    else if (lflag) {
+  105638:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  10563c:	74 16                	je     105654 <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  10563e:	8b 45 08             	mov    0x8(%ebp),%eax
+  105641:	8b 00                	mov    (%eax),%eax
+  105643:	8d 48 04             	lea    0x4(%eax),%ecx
+  105646:	8b 55 08             	mov    0x8(%ebp),%edx
+  105649:	89 0a                	mov    %ecx,(%edx)
+  10564b:	8b 00                	mov    (%eax),%eax
+  10564d:	ba 00 00 00 00       	mov    $0x0,%edx
+  105652:	eb 14                	jmp    105668 <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  105654:	8b 45 08             	mov    0x8(%ebp),%eax
+  105657:	8b 00                	mov    (%eax),%eax
+  105659:	8d 48 04             	lea    0x4(%eax),%ecx
+  10565c:	8b 55 08             	mov    0x8(%ebp),%edx
+  10565f:	89 0a                	mov    %ecx,(%edx)
+  105661:	8b 00                	mov    (%eax),%eax
+  105663:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  105668:	5d                   	pop    %ebp
+  105669:	c3                   	ret    
+
+0010566a <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:         a varargs list pointer
+ * @lflag:      determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  10566a:	55                   	push   %ebp
+  10566b:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  10566d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  105671:	7e 14                	jle    105687 <getint+0x1d>
+        return va_arg(*ap, long long);
+  105673:	8b 45 08             	mov    0x8(%ebp),%eax
+  105676:	8b 00                	mov    (%eax),%eax
+  105678:	8d 48 08             	lea    0x8(%eax),%ecx
+  10567b:	8b 55 08             	mov    0x8(%ebp),%edx
+  10567e:	89 0a                	mov    %ecx,(%edx)
+  105680:	8b 50 04             	mov    0x4(%eax),%edx
+  105683:	8b 00                	mov    (%eax),%eax
+  105685:	eb 28                	jmp    1056af <getint+0x45>
+    }
+    else if (lflag) {
+  105687:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  10568b:	74 12                	je     10569f <getint+0x35>
+        return va_arg(*ap, long);
+  10568d:	8b 45 08             	mov    0x8(%ebp),%eax
+  105690:	8b 00                	mov    (%eax),%eax
+  105692:	8d 48 04             	lea    0x4(%eax),%ecx
+  105695:	8b 55 08             	mov    0x8(%ebp),%edx
+  105698:	89 0a                	mov    %ecx,(%edx)
+  10569a:	8b 00                	mov    (%eax),%eax
+  10569c:	99                   	cltd   
+  10569d:	eb 10                	jmp    1056af <getint+0x45>
+    }
+    else {
+        return va_arg(*ap, int);
+  10569f:	8b 45 08             	mov    0x8(%ebp),%eax
+  1056a2:	8b 00                	mov    (%eax),%eax
+  1056a4:	8d 48 04             	lea    0x4(%eax),%ecx
+  1056a7:	8b 55 08             	mov    0x8(%ebp),%edx
+  1056aa:	89 0a                	mov    %ecx,(%edx)
+  1056ac:	8b 00                	mov    (%eax),%eax
+  1056ae:	99                   	cltd   
+    }
+}
+  1056af:	5d                   	pop    %ebp
+  1056b0:	c3                   	ret    
+
+001056b1 <printfmt>:
+ * @putch:      specified putch function, print a single character
+ * @putdat:     used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  1056b1:	55                   	push   %ebp
+  1056b2:	89 e5                	mov    %esp,%ebp
+  1056b4:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  1056b7:	8d 45 14             	lea    0x14(%ebp),%eax
+  1056ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  1056bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1056c0:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  1056c4:	8b 45 10             	mov    0x10(%ebp),%eax
+  1056c7:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1056cb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1056ce:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1056d2:	8b 45 08             	mov    0x8(%ebp),%eax
+  1056d5:	89 04 24             	mov    %eax,(%esp)
+  1056d8:	e8 02 00 00 00       	call   1056df <vprintfmt>
+    va_end(ap);
+}
+  1056dd:	c9                   	leave  
+  1056de:	c3                   	ret    
+
+001056df <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  1056df:	55                   	push   %ebp
+  1056e0:	89 e5                	mov    %esp,%ebp
+  1056e2:	56                   	push   %esi
+  1056e3:	53                   	push   %ebx
+  1056e4:	83 ec 40             	sub    $0x40,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  1056e7:	eb 18                	jmp    105701 <vprintfmt+0x22>
+            if (ch == '\0') {
+  1056e9:	85 db                	test   %ebx,%ebx
+  1056eb:	75 05                	jne    1056f2 <vprintfmt+0x13>
+                return;
+  1056ed:	e9 d1 03 00 00       	jmp    105ac3 <vprintfmt+0x3e4>
+            }
+            putch(ch, putdat);
+  1056f2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1056f5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1056f9:	89 1c 24             	mov    %ebx,(%esp)
+  1056fc:	8b 45 08             	mov    0x8(%ebp),%eax
+  1056ff:	ff d0                	call   *%eax
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  105701:	8b 45 10             	mov    0x10(%ebp),%eax
+  105704:	8d 50 01             	lea    0x1(%eax),%edx
+  105707:	89 55 10             	mov    %edx,0x10(%ebp)
+  10570a:	0f b6 00             	movzbl (%eax),%eax
+  10570d:	0f b6 d8             	movzbl %al,%ebx
+  105710:	83 fb 25             	cmp    $0x25,%ebx
+  105713:	75 d4                	jne    1056e9 <vprintfmt+0xa>
+            }
+            putch(ch, putdat);
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  105715:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  105719:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  105720:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  105723:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  105726:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  10572d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  105730:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+    reswitch:
+        switch (ch = *(unsigned char *)fmt ++) {
+  105733:	8b 45 10             	mov    0x10(%ebp),%eax
+  105736:	8d 50 01             	lea    0x1(%eax),%edx
+  105739:	89 55 10             	mov    %edx,0x10(%ebp)
+  10573c:	0f b6 00             	movzbl (%eax),%eax
+  10573f:	0f b6 d8             	movzbl %al,%ebx
+  105742:	8d 43 dd             	lea    -0x23(%ebx),%eax
+  105745:	83 f8 55             	cmp    $0x55,%eax
+  105748:	0f 87 44 03 00 00    	ja     105a92 <vprintfmt+0x3b3>
+  10574e:	8b 04 85 10 72 10 00 	mov    0x107210(,%eax,4),%eax
+  105755:	ff e0                	jmp    *%eax
+
+        // flag to pad on the right
+        case '-':
+            padc = '-';
+  105757:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  10575b:	eb d6                	jmp    105733 <vprintfmt+0x54>
+
+        // flag to pad with 0's instead of spaces
+        case '0':
+            padc = '0';
+  10575d:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  105761:	eb d0                	jmp    105733 <vprintfmt+0x54>
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  105763:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  10576a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  10576d:	89 d0                	mov    %edx,%eax
+  10576f:	c1 e0 02             	shl    $0x2,%eax
+  105772:	01 d0                	add    %edx,%eax
+  105774:	01 c0                	add    %eax,%eax
+  105776:	01 d8                	add    %ebx,%eax
+  105778:	83 e8 30             	sub    $0x30,%eax
+  10577b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  10577e:	8b 45 10             	mov    0x10(%ebp),%eax
+  105781:	0f b6 00             	movzbl (%eax),%eax
+  105784:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  105787:	83 fb 2f             	cmp    $0x2f,%ebx
+  10578a:	7e 0b                	jle    105797 <vprintfmt+0xb8>
+  10578c:	83 fb 39             	cmp    $0x39,%ebx
+  10578f:	7f 06                	jg     105797 <vprintfmt+0xb8>
+            padc = '0';
+            goto reswitch;
+
+        // width field
+        case '1' ... '9':
+            for (precision = 0; ; ++ fmt) {
+  105791:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+                precision = precision * 10 + ch - '0';
+                ch = *fmt;
+                if (ch < '0' || ch > '9') {
+                    break;
+                }
+            }
+  105795:	eb d3                	jmp    10576a <vprintfmt+0x8b>
+            goto process_precision;
+  105797:	eb 33                	jmp    1057cc <vprintfmt+0xed>
+
+        case '*':
+            precision = va_arg(ap, int);
+  105799:	8b 45 14             	mov    0x14(%ebp),%eax
+  10579c:	8d 50 04             	lea    0x4(%eax),%edx
+  10579f:	89 55 14             	mov    %edx,0x14(%ebp)
+  1057a2:	8b 00                	mov    (%eax),%eax
+  1057a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  1057a7:	eb 23                	jmp    1057cc <vprintfmt+0xed>
+
+        case '.':
+            if (width < 0)
+  1057a9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  1057ad:	79 0c                	jns    1057bb <vprintfmt+0xdc>
+                width = 0;
+  1057af:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  1057b6:	e9 78 ff ff ff       	jmp    105733 <vprintfmt+0x54>
+  1057bb:	e9 73 ff ff ff       	jmp    105733 <vprintfmt+0x54>
+
+        case '#':
+            altflag = 1;
+  1057c0:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  1057c7:	e9 67 ff ff ff       	jmp    105733 <vprintfmt+0x54>
+
+        process_precision:
+            if (width < 0)
+  1057cc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  1057d0:	79 12                	jns    1057e4 <vprintfmt+0x105>
+                width = precision, precision = -1;
+  1057d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1057d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  1057d8:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  1057df:	e9 4f ff ff ff       	jmp    105733 <vprintfmt+0x54>
+  1057e4:	e9 4a ff ff ff       	jmp    105733 <vprintfmt+0x54>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  1057e9:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  1057ed:	e9 41 ff ff ff       	jmp    105733 <vprintfmt+0x54>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  1057f2:	8b 45 14             	mov    0x14(%ebp),%eax
+  1057f5:	8d 50 04             	lea    0x4(%eax),%edx
+  1057f8:	89 55 14             	mov    %edx,0x14(%ebp)
+  1057fb:	8b 00                	mov    (%eax),%eax
+  1057fd:	8b 55 0c             	mov    0xc(%ebp),%edx
+  105800:	89 54 24 04          	mov    %edx,0x4(%esp)
+  105804:	89 04 24             	mov    %eax,(%esp)
+  105807:	8b 45 08             	mov    0x8(%ebp),%eax
+  10580a:	ff d0                	call   *%eax
+            break;
+  10580c:	e9 ac 02 00 00       	jmp    105abd <vprintfmt+0x3de>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  105811:	8b 45 14             	mov    0x14(%ebp),%eax
+  105814:	8d 50 04             	lea    0x4(%eax),%edx
+  105817:	89 55 14             	mov    %edx,0x14(%ebp)
+  10581a:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  10581c:	85 db                	test   %ebx,%ebx
+  10581e:	79 02                	jns    105822 <vprintfmt+0x143>
+                err = -err;
+  105820:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  105822:	83 fb 06             	cmp    $0x6,%ebx
+  105825:	7f 0b                	jg     105832 <vprintfmt+0x153>
+  105827:	8b 34 9d d0 71 10 00 	mov    0x1071d0(,%ebx,4),%esi
+  10582e:	85 f6                	test   %esi,%esi
+  105830:	75 23                	jne    105855 <vprintfmt+0x176>
+                printfmt(putch, putdat, "error %d", err);
+  105832:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  105836:	c7 44 24 08 fd 71 10 	movl   $0x1071fd,0x8(%esp)
+  10583d:	00 
+  10583e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105841:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105845:	8b 45 08             	mov    0x8(%ebp),%eax
+  105848:	89 04 24             	mov    %eax,(%esp)
+  10584b:	e8 61 fe ff ff       	call   1056b1 <printfmt>
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  105850:	e9 68 02 00 00       	jmp    105abd <vprintfmt+0x3de>
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+                printfmt(putch, putdat, "error %d", err);
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+  105855:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  105859:	c7 44 24 08 06 72 10 	movl   $0x107206,0x8(%esp)
+  105860:	00 
+  105861:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105864:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105868:	8b 45 08             	mov    0x8(%ebp),%eax
+  10586b:	89 04 24             	mov    %eax,(%esp)
+  10586e:	e8 3e fe ff ff       	call   1056b1 <printfmt>
+            }
+            break;
+  105873:	e9 45 02 00 00       	jmp    105abd <vprintfmt+0x3de>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  105878:	8b 45 14             	mov    0x14(%ebp),%eax
+  10587b:	8d 50 04             	lea    0x4(%eax),%edx
+  10587e:	89 55 14             	mov    %edx,0x14(%ebp)
+  105881:	8b 30                	mov    (%eax),%esi
+  105883:	85 f6                	test   %esi,%esi
+  105885:	75 05                	jne    10588c <vprintfmt+0x1ad>
+                p = "(null)";
+  105887:	be 09 72 10 00       	mov    $0x107209,%esi
+            }
+            if (width > 0 && padc != '-') {
+  10588c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  105890:	7e 3e                	jle    1058d0 <vprintfmt+0x1f1>
+  105892:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  105896:	74 38                	je     1058d0 <vprintfmt+0x1f1>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  105898:	8b 5d e8             	mov    -0x18(%ebp),%ebx
+  10589b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10589e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1058a2:	89 34 24             	mov    %esi,(%esp)
+  1058a5:	e8 15 03 00 00       	call   105bbf <strnlen>
+  1058aa:	29 c3                	sub    %eax,%ebx
+  1058ac:	89 d8                	mov    %ebx,%eax
+  1058ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  1058b1:	eb 17                	jmp    1058ca <vprintfmt+0x1eb>
+                    putch(padc, putdat);
+  1058b3:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  1058b7:	8b 55 0c             	mov    0xc(%ebp),%edx
+  1058ba:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1058be:	89 04 24             	mov    %eax,(%esp)
+  1058c1:	8b 45 08             	mov    0x8(%ebp),%eax
+  1058c4:	ff d0                	call   *%eax
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+                p = "(null)";
+            }
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  1058c6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  1058ca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  1058ce:	7f e3                	jg     1058b3 <vprintfmt+0x1d4>
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  1058d0:	eb 38                	jmp    10590a <vprintfmt+0x22b>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  1058d2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  1058d6:	74 1f                	je     1058f7 <vprintfmt+0x218>
+  1058d8:	83 fb 1f             	cmp    $0x1f,%ebx
+  1058db:	7e 05                	jle    1058e2 <vprintfmt+0x203>
+  1058dd:	83 fb 7e             	cmp    $0x7e,%ebx
+  1058e0:	7e 15                	jle    1058f7 <vprintfmt+0x218>
+                    putch('?', putdat);
+  1058e2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1058e5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1058e9:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  1058f0:	8b 45 08             	mov    0x8(%ebp),%eax
+  1058f3:	ff d0                	call   *%eax
+  1058f5:	eb 0f                	jmp    105906 <vprintfmt+0x227>
+                }
+                else {
+                    putch(ch, putdat);
+  1058f7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1058fa:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1058fe:	89 1c 24             	mov    %ebx,(%esp)
+  105901:	8b 45 08             	mov    0x8(%ebp),%eax
+  105904:	ff d0                	call   *%eax
+            if (width > 0 && padc != '-') {
+                for (width -= strnlen(p, precision); width > 0; width --) {
+                    putch(padc, putdat);
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  105906:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  10590a:	89 f0                	mov    %esi,%eax
+  10590c:	8d 70 01             	lea    0x1(%eax),%esi
+  10590f:	0f b6 00             	movzbl (%eax),%eax
+  105912:	0f be d8             	movsbl %al,%ebx
+  105915:	85 db                	test   %ebx,%ebx
+  105917:	74 10                	je     105929 <vprintfmt+0x24a>
+  105919:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  10591d:	78 b3                	js     1058d2 <vprintfmt+0x1f3>
+  10591f:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  105923:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  105927:	79 a9                	jns    1058d2 <vprintfmt+0x1f3>
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  105929:	eb 17                	jmp    105942 <vprintfmt+0x263>
+                putch(' ', putdat);
+  10592b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10592e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105932:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  105939:	8b 45 08             	mov    0x8(%ebp),%eax
+  10593c:	ff d0                	call   *%eax
+                }
+                else {
+                    putch(ch, putdat);
+                }
+            }
+            for (; width > 0; width --) {
+  10593e:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  105942:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  105946:	7f e3                	jg     10592b <vprintfmt+0x24c>
+                putch(' ', putdat);
+            }
+            break;
+  105948:	e9 70 01 00 00       	jmp    105abd <vprintfmt+0x3de>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  10594d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105950:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105954:	8d 45 14             	lea    0x14(%ebp),%eax
+  105957:	89 04 24             	mov    %eax,(%esp)
+  10595a:	e8 0b fd ff ff       	call   10566a <getint>
+  10595f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  105962:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  105965:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105968:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  10596b:	85 d2                	test   %edx,%edx
+  10596d:	79 26                	jns    105995 <vprintfmt+0x2b6>
+                putch('-', putdat);
+  10596f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105972:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105976:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  10597d:	8b 45 08             	mov    0x8(%ebp),%eax
+  105980:	ff d0                	call   *%eax
+                num = -(long long)num;
+  105982:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105985:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  105988:	f7 d8                	neg    %eax
+  10598a:	83 d2 00             	adc    $0x0,%edx
+  10598d:	f7 da                	neg    %edx
+  10598f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  105992:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  105995:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  10599c:	e9 a8 00 00 00       	jmp    105a49 <vprintfmt+0x36a>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  1059a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1059a4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1059a8:	8d 45 14             	lea    0x14(%ebp),%eax
+  1059ab:	89 04 24             	mov    %eax,(%esp)
+  1059ae:	e8 68 fc ff ff       	call   10561b <getuint>
+  1059b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  1059b6:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  1059b9:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  1059c0:	e9 84 00 00 00       	jmp    105a49 <vprintfmt+0x36a>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  1059c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1059c8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1059cc:	8d 45 14             	lea    0x14(%ebp),%eax
+  1059cf:	89 04 24             	mov    %eax,(%esp)
+  1059d2:	e8 44 fc ff ff       	call   10561b <getuint>
+  1059d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  1059da:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  1059dd:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  1059e4:	eb 63                	jmp    105a49 <vprintfmt+0x36a>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  1059e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1059e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1059ed:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  1059f4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1059f7:	ff d0                	call   *%eax
+            putch('x', putdat);
+  1059f9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1059fc:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105a00:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  105a07:	8b 45 08             	mov    0x8(%ebp),%eax
+  105a0a:	ff d0                	call   *%eax
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  105a0c:	8b 45 14             	mov    0x14(%ebp),%eax
+  105a0f:	8d 50 04             	lea    0x4(%eax),%edx
+  105a12:	89 55 14             	mov    %edx,0x14(%ebp)
+  105a15:	8b 00                	mov    (%eax),%eax
+  105a17:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  105a1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  105a21:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  105a28:	eb 1f                	jmp    105a49 <vprintfmt+0x36a>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  105a2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105a2d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105a31:	8d 45 14             	lea    0x14(%ebp),%eax
+  105a34:	89 04 24             	mov    %eax,(%esp)
+  105a37:	e8 df fb ff ff       	call   10561b <getuint>
+  105a3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  105a3f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  105a42:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  105a49:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  105a4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  105a50:	89 54 24 18          	mov    %edx,0x18(%esp)
+  105a54:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  105a57:	89 54 24 14          	mov    %edx,0x14(%esp)
+  105a5b:	89 44 24 10          	mov    %eax,0x10(%esp)
+  105a5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105a62:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  105a65:	89 44 24 08          	mov    %eax,0x8(%esp)
+  105a69:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  105a6d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105a70:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105a74:	8b 45 08             	mov    0x8(%ebp),%eax
+  105a77:	89 04 24             	mov    %eax,(%esp)
+  105a7a:	e8 97 fa ff ff       	call   105516 <printnum>
+            break;
+  105a7f:	eb 3c                	jmp    105abd <vprintfmt+0x3de>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  105a81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105a84:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105a88:	89 1c 24             	mov    %ebx,(%esp)
+  105a8b:	8b 45 08             	mov    0x8(%ebp),%eax
+  105a8e:	ff d0                	call   *%eax
+            break;
+  105a90:	eb 2b                	jmp    105abd <vprintfmt+0x3de>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  105a92:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105a95:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105a99:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  105aa0:	8b 45 08             	mov    0x8(%ebp),%eax
+  105aa3:	ff d0                	call   *%eax
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  105aa5:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  105aa9:	eb 04                	jmp    105aaf <vprintfmt+0x3d0>
+  105aab:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  105aaf:	8b 45 10             	mov    0x10(%ebp),%eax
+  105ab2:	83 e8 01             	sub    $0x1,%eax
+  105ab5:	0f b6 00             	movzbl (%eax),%eax
+  105ab8:	3c 25                	cmp    $0x25,%al
+  105aba:	75 ef                	jne    105aab <vprintfmt+0x3cc>
+                /* do nothing */;
+            break;
+  105abc:	90                   	nop
+        }
+    }
+  105abd:	90                   	nop
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  105abe:	e9 3e fc ff ff       	jmp    105701 <vprintfmt+0x22>
+            for (fmt --; fmt[-1] != '%'; fmt --)
+                /* do nothing */;
+            break;
+        }
+    }
+}
+  105ac3:	83 c4 40             	add    $0x40,%esp
+  105ac6:	5b                   	pop    %ebx
+  105ac7:	5e                   	pop    %esi
+  105ac8:	5d                   	pop    %ebp
+  105ac9:	c3                   	ret    
+
+00105aca <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:         the character will be printed
+ * @b:          the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  105aca:	55                   	push   %ebp
+  105acb:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  105acd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105ad0:	8b 40 08             	mov    0x8(%eax),%eax
+  105ad3:	8d 50 01             	lea    0x1(%eax),%edx
+  105ad6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105ad9:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  105adc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105adf:	8b 10                	mov    (%eax),%edx
+  105ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105ae4:	8b 40 04             	mov    0x4(%eax),%eax
+  105ae7:	39 c2                	cmp    %eax,%edx
+  105ae9:	73 12                	jae    105afd <sprintputch+0x33>
+        *b->buf ++ = ch;
+  105aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105aee:	8b 00                	mov    (%eax),%eax
+  105af0:	8d 48 01             	lea    0x1(%eax),%ecx
+  105af3:	8b 55 0c             	mov    0xc(%ebp),%edx
+  105af6:	89 0a                	mov    %ecx,(%edx)
+  105af8:	8b 55 08             	mov    0x8(%ebp),%edx
+  105afb:	88 10                	mov    %dl,(%eax)
+    }
+}
+  105afd:	5d                   	pop    %ebp
+  105afe:	c3                   	ret    
+
+00105aff <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:       the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  105aff:	55                   	push   %ebp
+  105b00:	89 e5                	mov    %esp,%ebp
+  105b02:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  105b05:	8d 45 14             	lea    0x14(%ebp),%eax
+  105b08:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  105b0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105b0e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  105b12:	8b 45 10             	mov    0x10(%ebp),%eax
+  105b15:	89 44 24 08          	mov    %eax,0x8(%esp)
+  105b19:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105b1c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105b20:	8b 45 08             	mov    0x8(%ebp),%eax
+  105b23:	89 04 24             	mov    %eax,(%esp)
+  105b26:	e8 08 00 00 00       	call   105b33 <vsnprintf>
+  105b2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  105b2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  105b31:	c9                   	leave  
+  105b32:	c3                   	ret    
+
+00105b33 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  105b33:	55                   	push   %ebp
+  105b34:	89 e5                	mov    %esp,%ebp
+  105b36:	83 ec 28             	sub    $0x28,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  105b39:	8b 45 08             	mov    0x8(%ebp),%eax
+  105b3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  105b3f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105b42:	8d 50 ff             	lea    -0x1(%eax),%edx
+  105b45:	8b 45 08             	mov    0x8(%ebp),%eax
+  105b48:	01 d0                	add    %edx,%eax
+  105b4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  105b4d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  105b54:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  105b58:	74 0a                	je     105b64 <vsnprintf+0x31>
+  105b5a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  105b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105b60:	39 c2                	cmp    %eax,%edx
+  105b62:	76 07                	jbe    105b6b <vsnprintf+0x38>
+        return -E_INVAL;
+  105b64:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  105b69:	eb 2a                	jmp    105b95 <vsnprintf+0x62>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  105b6b:	8b 45 14             	mov    0x14(%ebp),%eax
+  105b6e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  105b72:	8b 45 10             	mov    0x10(%ebp),%eax
+  105b75:	89 44 24 08          	mov    %eax,0x8(%esp)
+  105b79:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  105b7c:	89 44 24 04          	mov    %eax,0x4(%esp)
+  105b80:	c7 04 24 ca 5a 10 00 	movl   $0x105aca,(%esp)
+  105b87:	e8 53 fb ff ff       	call   1056df <vprintfmt>
+    // null terminate the buffer
+    *b.buf = '\0';
+  105b8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  105b8f:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  105b92:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  105b95:	c9                   	leave  
+  105b96:	c3                   	ret    
+
+00105b97 <strlen>:
+ * @s:      the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  105b97:	55                   	push   %ebp
+  105b98:	89 e5                	mov    %esp,%ebp
+  105b9a:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  105b9d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  105ba4:	eb 04                	jmp    105baa <strlen+0x13>
+        cnt ++;
+  105ba6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+    size_t cnt = 0;
+    while (*s ++ != '\0') {
+  105baa:	8b 45 08             	mov    0x8(%ebp),%eax
+  105bad:	8d 50 01             	lea    0x1(%eax),%edx
+  105bb0:	89 55 08             	mov    %edx,0x8(%ebp)
+  105bb3:	0f b6 00             	movzbl (%eax),%eax
+  105bb6:	84 c0                	test   %al,%al
+  105bb8:	75 ec                	jne    105ba6 <strlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  105bba:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  105bbd:	c9                   	leave  
+  105bbe:	c3                   	ret    
+
+00105bbf <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  105bbf:	55                   	push   %ebp
+  105bc0:	89 e5                	mov    %esp,%ebp
+  105bc2:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  105bc5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  105bcc:	eb 04                	jmp    105bd2 <strnlen+0x13>
+        cnt ++;
+  105bce:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+    size_t cnt = 0;
+    while (cnt < len && *s ++ != '\0') {
+  105bd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  105bd5:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  105bd8:	73 10                	jae    105bea <strnlen+0x2b>
+  105bda:	8b 45 08             	mov    0x8(%ebp),%eax
+  105bdd:	8d 50 01             	lea    0x1(%eax),%edx
+  105be0:	89 55 08             	mov    %edx,0x8(%ebp)
+  105be3:	0f b6 00             	movzbl (%eax),%eax
+  105be6:	84 c0                	test   %al,%al
+  105be8:	75 e4                	jne    105bce <strnlen+0xf>
+        cnt ++;
+    }
+    return cnt;
+  105bea:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  105bed:	c9                   	leave  
+  105bee:	c3                   	ret    
+
+00105bef <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  105bef:	55                   	push   %ebp
+  105bf0:	89 e5                	mov    %esp,%ebp
+  105bf2:	57                   	push   %edi
+  105bf3:	56                   	push   %esi
+  105bf4:	83 ec 20             	sub    $0x20,%esp
+  105bf7:	8b 45 08             	mov    0x8(%ebp),%eax
+  105bfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  105bfd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105c00:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  105c03:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  105c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  105c09:	89 d1                	mov    %edx,%ecx
+  105c0b:	89 c2                	mov    %eax,%edx
+  105c0d:	89 ce                	mov    %ecx,%esi
+  105c0f:	89 d7                	mov    %edx,%edi
+  105c11:	ac                   	lods   %ds:(%esi),%al
+  105c12:	aa                   	stos   %al,%es:(%edi)
+  105c13:	84 c0                	test   %al,%al
+  105c15:	75 fa                	jne    105c11 <strcpy+0x22>
+  105c17:	89 fa                	mov    %edi,%edx
+  105c19:	89 f1                	mov    %esi,%ecx
+  105c1b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  105c1e:	89 55 e8             	mov    %edx,-0x18(%ebp)
+  105c21:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+        "stosb;"
+        "testb %%al, %%al;"
+        "jne 1b;"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        : "0" (src), "1" (dst) : "memory");
+    return dst;
+  105c24:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  105c27:	83 c4 20             	add    $0x20,%esp
+  105c2a:	5e                   	pop    %esi
+  105c2b:	5f                   	pop    %edi
+  105c2c:	5d                   	pop    %ebp
+  105c2d:	c3                   	ret    
+
+00105c2e <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  105c2e:	55                   	push   %ebp
+  105c2f:	89 e5                	mov    %esp,%ebp
+  105c31:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  105c34:	8b 45 08             	mov    0x8(%ebp),%eax
+  105c37:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  105c3a:	eb 21                	jmp    105c5d <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  105c3c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105c3f:	0f b6 10             	movzbl (%eax),%edx
+  105c42:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  105c45:	88 10                	mov    %dl,(%eax)
+  105c47:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  105c4a:	0f b6 00             	movzbl (%eax),%eax
+  105c4d:	84 c0                	test   %al,%al
+  105c4f:	74 04                	je     105c55 <strncpy+0x27>
+            src ++;
+  105c51:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  105c55:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  105c59:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+    char *p = dst;
+    while (len > 0) {
+  105c5d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  105c61:	75 d9                	jne    105c3c <strncpy+0xe>
+        if ((*p = *src) != '\0') {
+            src ++;
+        }
+        p ++, len --;
+    }
+    return dst;
+  105c63:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  105c66:	c9                   	leave  
+  105c67:	c3                   	ret    
+
+00105c68 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  105c68:	55                   	push   %ebp
+  105c69:	89 e5                	mov    %esp,%ebp
+  105c6b:	57                   	push   %edi
+  105c6c:	56                   	push   %esi
+  105c6d:	83 ec 20             	sub    $0x20,%esp
+  105c70:	8b 45 08             	mov    0x8(%ebp),%eax
+  105c73:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  105c76:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105c79:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_STRCMP
+#define __HAVE_ARCH_STRCMP
+static inline int
+__strcmp(const char *s1, const char *s2) {
+    int d0, d1, ret;
+    asm volatile (
+  105c7c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  105c7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105c82:	89 d1                	mov    %edx,%ecx
+  105c84:	89 c2                	mov    %eax,%edx
+  105c86:	89 ce                	mov    %ecx,%esi
+  105c88:	89 d7                	mov    %edx,%edi
+  105c8a:	ac                   	lods   %ds:(%esi),%al
+  105c8b:	ae                   	scas   %es:(%edi),%al
+  105c8c:	75 08                	jne    105c96 <strcmp+0x2e>
+  105c8e:	84 c0                	test   %al,%al
+  105c90:	75 f8                	jne    105c8a <strcmp+0x22>
+  105c92:	31 c0                	xor    %eax,%eax
+  105c94:	eb 04                	jmp    105c9a <strcmp+0x32>
+  105c96:	19 c0                	sbb    %eax,%eax
+  105c98:	0c 01                	or     $0x1,%al
+  105c9a:	89 fa                	mov    %edi,%edx
+  105c9c:	89 f1                	mov    %esi,%ecx
+  105c9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  105ca1:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  105ca4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+        "orb $1, %%al;"
+        "3:"
+        : "=a" (ret), "=&S" (d0), "=&D" (d1)
+        : "1" (s1), "2" (s2)
+        : "memory");
+    return ret;
+  105ca7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  105caa:	83 c4 20             	add    $0x20,%esp
+  105cad:	5e                   	pop    %esi
+  105cae:	5f                   	pop    %edi
+  105caf:	5d                   	pop    %ebp
+  105cb0:	c3                   	ret    
+
+00105cb1 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  105cb1:	55                   	push   %ebp
+  105cb2:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  105cb4:	eb 0c                	jmp    105cc2 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  105cb6:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  105cba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  105cbe:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  105cc2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  105cc6:	74 1a                	je     105ce2 <strncmp+0x31>
+  105cc8:	8b 45 08             	mov    0x8(%ebp),%eax
+  105ccb:	0f b6 00             	movzbl (%eax),%eax
+  105cce:	84 c0                	test   %al,%al
+  105cd0:	74 10                	je     105ce2 <strncmp+0x31>
+  105cd2:	8b 45 08             	mov    0x8(%ebp),%eax
+  105cd5:	0f b6 10             	movzbl (%eax),%edx
+  105cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105cdb:	0f b6 00             	movzbl (%eax),%eax
+  105cde:	38 c2                	cmp    %al,%dl
+  105ce0:	74 d4                	je     105cb6 <strncmp+0x5>
+        n --, s1 ++, s2 ++;
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  105ce2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  105ce6:	74 18                	je     105d00 <strncmp+0x4f>
+  105ce8:	8b 45 08             	mov    0x8(%ebp),%eax
+  105ceb:	0f b6 00             	movzbl (%eax),%eax
+  105cee:	0f b6 d0             	movzbl %al,%edx
+  105cf1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105cf4:	0f b6 00             	movzbl (%eax),%eax
+  105cf7:	0f b6 c0             	movzbl %al,%eax
+  105cfa:	29 c2                	sub    %eax,%edx
+  105cfc:	89 d0                	mov    %edx,%eax
+  105cfe:	eb 05                	jmp    105d05 <strncmp+0x54>
+  105d00:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  105d05:	5d                   	pop    %ebp
+  105d06:	c3                   	ret    
+
+00105d07 <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  105d07:	55                   	push   %ebp
+  105d08:	89 e5                	mov    %esp,%ebp
+  105d0a:	83 ec 04             	sub    $0x4,%esp
+  105d0d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105d10:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  105d13:	eb 14                	jmp    105d29 <strchr+0x22>
+        if (*s == c) {
+  105d15:	8b 45 08             	mov    0x8(%ebp),%eax
+  105d18:	0f b6 00             	movzbl (%eax),%eax
+  105d1b:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  105d1e:	75 05                	jne    105d25 <strchr+0x1e>
+            return (char *)s;
+  105d20:	8b 45 08             	mov    0x8(%ebp),%eax
+  105d23:	eb 13                	jmp    105d38 <strchr+0x31>
+        }
+        s ++;
+  105d25:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+    while (*s != '\0') {
+  105d29:	8b 45 08             	mov    0x8(%ebp),%eax
+  105d2c:	0f b6 00             	movzbl (%eax),%eax
+  105d2f:	84 c0                	test   %al,%al
+  105d31:	75 e2                	jne    105d15 <strchr+0xe>
+        if (*s == c) {
+            return (char *)s;
+        }
+        s ++;
+    }
+    return NULL;
+  105d33:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  105d38:	c9                   	leave  
+  105d39:	c3                   	ret    
+
+00105d3a <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  105d3a:	55                   	push   %ebp
+  105d3b:	89 e5                	mov    %esp,%ebp
+  105d3d:	83 ec 04             	sub    $0x4,%esp
+  105d40:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105d43:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  105d46:	eb 11                	jmp    105d59 <strfind+0x1f>
+        if (*s == c) {
+  105d48:	8b 45 08             	mov    0x8(%ebp),%eax
+  105d4b:	0f b6 00             	movzbl (%eax),%eax
+  105d4e:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  105d51:	75 02                	jne    105d55 <strfind+0x1b>
+            break;
+  105d53:	eb 0e                	jmp    105d63 <strfind+0x29>
+        }
+        s ++;
+  105d55:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+    while (*s != '\0') {
+  105d59:	8b 45 08             	mov    0x8(%ebp),%eax
+  105d5c:	0f b6 00             	movzbl (%eax),%eax
+  105d5f:	84 c0                	test   %al,%al
+  105d61:	75 e5                	jne    105d48 <strfind+0xe>
+        if (*s == c) {
+            break;
+        }
+        s ++;
+    }
+    return (char *)s;
+  105d63:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  105d66:	c9                   	leave  
+  105d67:	c3                   	ret    
+
+00105d68 <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  105d68:	55                   	push   %ebp
+  105d69:	89 e5                	mov    %esp,%ebp
+  105d6b:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  105d6e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  105d75:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  105d7c:	eb 04                	jmp    105d82 <strtol+0x1a>
+        s ++;
+  105d7e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+strtol(const char *s, char **endptr, int base) {
+    int neg = 0;
+    long val = 0;
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  105d82:	8b 45 08             	mov    0x8(%ebp),%eax
+  105d85:	0f b6 00             	movzbl (%eax),%eax
+  105d88:	3c 20                	cmp    $0x20,%al
+  105d8a:	74 f2                	je     105d7e <strtol+0x16>
+  105d8c:	8b 45 08             	mov    0x8(%ebp),%eax
+  105d8f:	0f b6 00             	movzbl (%eax),%eax
+  105d92:	3c 09                	cmp    $0x9,%al
+  105d94:	74 e8                	je     105d7e <strtol+0x16>
+        s ++;
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  105d96:	8b 45 08             	mov    0x8(%ebp),%eax
+  105d99:	0f b6 00             	movzbl (%eax),%eax
+  105d9c:	3c 2b                	cmp    $0x2b,%al
+  105d9e:	75 06                	jne    105da6 <strtol+0x3e>
+        s ++;
+  105da0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  105da4:	eb 15                	jmp    105dbb <strtol+0x53>
+    }
+    else if (*s == '-') {
+  105da6:	8b 45 08             	mov    0x8(%ebp),%eax
+  105da9:	0f b6 00             	movzbl (%eax),%eax
+  105dac:	3c 2d                	cmp    $0x2d,%al
+  105dae:	75 0b                	jne    105dbb <strtol+0x53>
+        s ++, neg = 1;
+  105db0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  105db4:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  105dbb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  105dbf:	74 06                	je     105dc7 <strtol+0x5f>
+  105dc1:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  105dc5:	75 24                	jne    105deb <strtol+0x83>
+  105dc7:	8b 45 08             	mov    0x8(%ebp),%eax
+  105dca:	0f b6 00             	movzbl (%eax),%eax
+  105dcd:	3c 30                	cmp    $0x30,%al
+  105dcf:	75 1a                	jne    105deb <strtol+0x83>
+  105dd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  105dd4:	83 c0 01             	add    $0x1,%eax
+  105dd7:	0f b6 00             	movzbl (%eax),%eax
+  105dda:	3c 78                	cmp    $0x78,%al
+  105ddc:	75 0d                	jne    105deb <strtol+0x83>
+        s += 2, base = 16;
+  105dde:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  105de2:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  105de9:	eb 2a                	jmp    105e15 <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  105deb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  105def:	75 17                	jne    105e08 <strtol+0xa0>
+  105df1:	8b 45 08             	mov    0x8(%ebp),%eax
+  105df4:	0f b6 00             	movzbl (%eax),%eax
+  105df7:	3c 30                	cmp    $0x30,%al
+  105df9:	75 0d                	jne    105e08 <strtol+0xa0>
+        s ++, base = 8;
+  105dfb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  105dff:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  105e06:	eb 0d                	jmp    105e15 <strtol+0xad>
+    }
+    else if (base == 0) {
+  105e08:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  105e0c:	75 07                	jne    105e15 <strtol+0xad>
+        base = 10;
+  105e0e:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  105e15:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e18:	0f b6 00             	movzbl (%eax),%eax
+  105e1b:	3c 2f                	cmp    $0x2f,%al
+  105e1d:	7e 1b                	jle    105e3a <strtol+0xd2>
+  105e1f:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e22:	0f b6 00             	movzbl (%eax),%eax
+  105e25:	3c 39                	cmp    $0x39,%al
+  105e27:	7f 11                	jg     105e3a <strtol+0xd2>
+            dig = *s - '0';
+  105e29:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e2c:	0f b6 00             	movzbl (%eax),%eax
+  105e2f:	0f be c0             	movsbl %al,%eax
+  105e32:	83 e8 30             	sub    $0x30,%eax
+  105e35:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  105e38:	eb 48                	jmp    105e82 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  105e3a:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e3d:	0f b6 00             	movzbl (%eax),%eax
+  105e40:	3c 60                	cmp    $0x60,%al
+  105e42:	7e 1b                	jle    105e5f <strtol+0xf7>
+  105e44:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e47:	0f b6 00             	movzbl (%eax),%eax
+  105e4a:	3c 7a                	cmp    $0x7a,%al
+  105e4c:	7f 11                	jg     105e5f <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  105e4e:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e51:	0f b6 00             	movzbl (%eax),%eax
+  105e54:	0f be c0             	movsbl %al,%eax
+  105e57:	83 e8 57             	sub    $0x57,%eax
+  105e5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  105e5d:	eb 23                	jmp    105e82 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  105e5f:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e62:	0f b6 00             	movzbl (%eax),%eax
+  105e65:	3c 40                	cmp    $0x40,%al
+  105e67:	7e 3d                	jle    105ea6 <strtol+0x13e>
+  105e69:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e6c:	0f b6 00             	movzbl (%eax),%eax
+  105e6f:	3c 5a                	cmp    $0x5a,%al
+  105e71:	7f 33                	jg     105ea6 <strtol+0x13e>
+            dig = *s - 'A' + 10;
+  105e73:	8b 45 08             	mov    0x8(%ebp),%eax
+  105e76:	0f b6 00             	movzbl (%eax),%eax
+  105e79:	0f be c0             	movsbl %al,%eax
+  105e7c:	83 e8 37             	sub    $0x37,%eax
+  105e7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  105e82:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  105e85:	3b 45 10             	cmp    0x10(%ebp),%eax
+  105e88:	7c 02                	jl     105e8c <strtol+0x124>
+            break;
+  105e8a:	eb 1a                	jmp    105ea6 <strtol+0x13e>
+        }
+        s ++, val = (val * base) + dig;
+  105e8c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  105e90:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  105e93:	0f af 45 10          	imul   0x10(%ebp),%eax
+  105e97:	89 c2                	mov    %eax,%edx
+  105e99:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  105e9c:	01 d0                	add    %edx,%eax
+  105e9e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  105ea1:	e9 6f ff ff ff       	jmp    105e15 <strtol+0xad>
+
+    if (endptr) {
+  105ea6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  105eaa:	74 08                	je     105eb4 <strtol+0x14c>
+        *endptr = (char *) s;
+  105eac:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105eaf:	8b 55 08             	mov    0x8(%ebp),%edx
+  105eb2:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  105eb4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  105eb8:	74 07                	je     105ec1 <strtol+0x159>
+  105eba:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  105ebd:	f7 d8                	neg    %eax
+  105ebf:	eb 03                	jmp    105ec4 <strtol+0x15c>
+  105ec1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  105ec4:	c9                   	leave  
+  105ec5:	c3                   	ret    
+
+00105ec6 <memset>:
+ * @n:      number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  105ec6:	55                   	push   %ebp
+  105ec7:	89 e5                	mov    %esp,%ebp
+  105ec9:	57                   	push   %edi
+  105eca:	83 ec 24             	sub    $0x24,%esp
+  105ecd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105ed0:	88 45 d8             	mov    %al,-0x28(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  105ed3:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+  105ed7:	8b 55 08             	mov    0x8(%ebp),%edx
+  105eda:	89 55 f8             	mov    %edx,-0x8(%ebp)
+  105edd:	88 45 f7             	mov    %al,-0x9(%ebp)
+  105ee0:	8b 45 10             	mov    0x10(%ebp),%eax
+  105ee3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  105ee6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  105ee9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+  105eed:	8b 55 f8             	mov    -0x8(%ebp),%edx
+  105ef0:	89 d7                	mov    %edx,%edi
+  105ef2:	f3 aa                	rep stos %al,%es:(%edi)
+  105ef4:	89 fa                	mov    %edi,%edx
+  105ef6:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+  105ef9:	89 55 e8             	mov    %edx,-0x18(%ebp)
+        "rep; stosb;"
+        : "=&c" (d0), "=&D" (d1)
+        : "0" (n), "a" (c), "1" (s)
+        : "memory");
+    return s;
+  105efc:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  105eff:	83 c4 24             	add    $0x24,%esp
+  105f02:	5f                   	pop    %edi
+  105f03:	5d                   	pop    %ebp
+  105f04:	c3                   	ret    
+
+00105f05 <memmove>:
+ * @n:      number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  105f05:	55                   	push   %ebp
+  105f06:	89 e5                	mov    %esp,%ebp
+  105f08:	57                   	push   %edi
+  105f09:	56                   	push   %esi
+  105f0a:	53                   	push   %ebx
+  105f0b:	83 ec 30             	sub    $0x30,%esp
+  105f0e:	8b 45 08             	mov    0x8(%ebp),%eax
+  105f11:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  105f14:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105f17:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  105f1a:	8b 45 10             	mov    0x10(%ebp),%eax
+  105f1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  105f20:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105f23:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  105f26:	73 42                	jae    105f6a <memmove+0x65>
+  105f28:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105f2b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  105f2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  105f31:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  105f34:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  105f37:	89 45 dc             	mov    %eax,-0x24(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  105f3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  105f3d:	c1 e8 02             	shr    $0x2,%eax
+  105f40:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  105f42:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  105f45:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  105f48:	89 d7                	mov    %edx,%edi
+  105f4a:	89 c6                	mov    %eax,%esi
+  105f4c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  105f4e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  105f51:	83 e1 03             	and    $0x3,%ecx
+  105f54:	74 02                	je     105f58 <memmove+0x53>
+  105f56:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  105f58:	89 f0                	mov    %esi,%eax
+  105f5a:	89 fa                	mov    %edi,%edx
+  105f5c:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  105f5f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+  105f62:	89 45 d0             	mov    %eax,-0x30(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  105f65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  105f68:	eb 36                	jmp    105fa0 <memmove+0x9b>
+    asm volatile (
+        "std;"
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  105f6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  105f6d:	8d 50 ff             	lea    -0x1(%eax),%edx
+  105f70:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  105f73:	01 c2                	add    %eax,%edx
+  105f75:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  105f78:	8d 48 ff             	lea    -0x1(%eax),%ecx
+  105f7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105f7e:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+        return __memcpy(dst, src, n);
+    }
+    int d0, d1, d2;
+    asm volatile (
+  105f81:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  105f84:	89 c1                	mov    %eax,%ecx
+  105f86:	89 d8                	mov    %ebx,%eax
+  105f88:	89 d6                	mov    %edx,%esi
+  105f8a:	89 c7                	mov    %eax,%edi
+  105f8c:	fd                   	std    
+  105f8d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  105f8f:	fc                   	cld    
+  105f90:	89 f8                	mov    %edi,%eax
+  105f92:	89 f2                	mov    %esi,%edx
+  105f94:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  105f97:	89 55 c8             	mov    %edx,-0x38(%ebp)
+  105f9a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+        "rep; movsb;"
+        "cld;"
+        : "=&c" (d0), "=&S" (d1), "=&D" (d2)
+        : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+        : "memory");
+    return dst;
+  105f9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  105fa0:	83 c4 30             	add    $0x30,%esp
+  105fa3:	5b                   	pop    %ebx
+  105fa4:	5e                   	pop    %esi
+  105fa5:	5f                   	pop    %edi
+  105fa6:	5d                   	pop    %ebp
+  105fa7:	c3                   	ret    
+
+00105fa8 <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  105fa8:	55                   	push   %ebp
+  105fa9:	89 e5                	mov    %esp,%ebp
+  105fab:	57                   	push   %edi
+  105fac:	56                   	push   %esi
+  105fad:	83 ec 20             	sub    $0x20,%esp
+  105fb0:	8b 45 08             	mov    0x8(%ebp),%eax
+  105fb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  105fb6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  105fb9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  105fbc:	8b 45 10             	mov    0x10(%ebp),%eax
+  105fbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        "andl $3, %%ecx;"
+        "jz 1f;"
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  105fc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  105fc5:	c1 e8 02             	shr    $0x2,%eax
+  105fc8:	89 c1                	mov    %eax,%ecx
+#ifndef __HAVE_ARCH_MEMCPY
+#define __HAVE_ARCH_MEMCPY
+static inline void *
+__memcpy(void *dst, const void *src, size_t n) {
+    int d0, d1, d2;
+    asm volatile (
+  105fca:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  105fcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  105fd0:	89 d7                	mov    %edx,%edi
+  105fd2:	89 c6                	mov    %eax,%esi
+  105fd4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  105fd6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+  105fd9:	83 e1 03             	and    $0x3,%ecx
+  105fdc:	74 02                	je     105fe0 <memcpy+0x38>
+  105fde:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  105fe0:	89 f0                	mov    %esi,%eax
+  105fe2:	89 fa                	mov    %edi,%edx
+  105fe4:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+  105fe7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+  105fea:	89 45 e0             	mov    %eax,-0x20(%ebp)
+        "rep; movsb;"
+        "1:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+        : "memory");
+    return dst;
+  105fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  105ff0:	83 c4 20             	add    $0x20,%esp
+  105ff3:	5e                   	pop    %esi
+  105ff4:	5f                   	pop    %edi
+  105ff5:	5d                   	pop    %ebp
+  105ff6:	c3                   	ret    
+
+00105ff7 <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  105ff7:	55                   	push   %ebp
+  105ff8:	89 e5                	mov    %esp,%ebp
+  105ffa:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  105ffd:	8b 45 08             	mov    0x8(%ebp),%eax
+  106000:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  106003:	8b 45 0c             	mov    0xc(%ebp),%eax
+  106006:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  106009:	eb 30                	jmp    10603b <memcmp+0x44>
+        if (*s1 != *s2) {
+  10600b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10600e:	0f b6 10             	movzbl (%eax),%edx
+  106011:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  106014:	0f b6 00             	movzbl (%eax),%eax
+  106017:	38 c2                	cmp    %al,%dl
+  106019:	74 18                	je     106033 <memcmp+0x3c>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  10601b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10601e:	0f b6 00             	movzbl (%eax),%eax
+  106021:	0f b6 d0             	movzbl %al,%edx
+  106024:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  106027:	0f b6 00             	movzbl (%eax),%eax
+  10602a:	0f b6 c0             	movzbl %al,%eax
+  10602d:	29 c2                	sub    %eax,%edx
+  10602f:	89 d0                	mov    %edx,%eax
+  106031:	eb 1a                	jmp    10604d <memcmp+0x56>
+        }
+        s1 ++, s2 ++;
+  106033:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  106037:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+    const char *s1 = (const char *)v1;
+    const char *s2 = (const char *)v2;
+    while (n -- > 0) {
+  10603b:	8b 45 10             	mov    0x10(%ebp),%eax
+  10603e:	8d 50 ff             	lea    -0x1(%eax),%edx
+  106041:	89 55 10             	mov    %edx,0x10(%ebp)
+  106044:	85 c0                	test   %eax,%eax
+  106046:	75 c3                	jne    10600b <memcmp+0x14>
+        if (*s1 != *s2) {
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+        }
+        s1 ++, s2 ++;
+    }
+    return 0;
+  106048:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  10604d:	c9                   	leave  
+  10604e:	c3                   	ret    
diff -r -u -P lab2_origin/obj/kernel_nopage.sym lab2/obj/kernel_nopage.sym
--- lab2_origin/obj/kernel_nopage.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kernel_nopage.sym	2021-08-29 21:35:38.870604847 +0800
@@ -0,0 +1,468 @@
+00100000 .text
+00106060 .rodata
+00107368 .stab
+00112001 .stabstr
+00115000 .data
+00117a40 .bss
+00000000 .comment
+00000000 obj/kern/init/entry.o
+00117018 __gdtdesc
+00100019 relocated
+00100028 spin
+00117000 __gdt
+00000000 init.c
+0010012a lab1_print_cur_status
+00117a40 round.1438
+001001f0 lab1_switch_to_user
+001001f5 lab1_switch_to_kernel
+001001fa lab1_switch_test
+00000000 readline.c
+00117a60 buf
+00000000 stdio.c
+001002e9 cputch
+00000000 kdebug.c
+001003dd stab_binsearch
+001009a9 read_eip
+00000000 kmonitor.c
+00117020 commands
+00100a73 parse
+00100b2d runcmd
+00000000 panic.c
+00117e60 is_panic
+00000000 clock.c
+00000000 console.c
+00100ddf __intr_save
+00100e09 __intr_restore
+00100e1c delay
+00117e80 crt_buf
+00117e84 crt_pos
+00117e86 addr_6845
+00100e64 cga_init
+00117e88 serial_exists
+00100f4a serial_init
+0010102d lpt_putc_sub
+001010a6 lpt_putc
+001010e5 cga_putc
+001012b9 serial_putc_sub
+00101312 serial_putc
+00117ea0 cons
+00101351 cons_intr
+0010139c serial_proc_data
+00117060 shiftcode
+00117160 togglecode
+00117260 normalmap
+00117360 shiftmap
+00117460 ctlmap
+00117560 charcode
+00101410 kbd_proc_data
+001180a8 shift.1532
+00101599 kbd_intr
+001015ad kbd_init
+00000000 intr.c
+00000000 picirq.c
+00117570 irq_mask
+001180ac did_init
+001016a9 pic_setmask
+00000000 trap.c
+0010186a print_ticks
+001180c0 idt
+00117580 idt_pd
+00101a1d trapname
+00106740 excnames.1482
+001175a0 IA32flags
+00101ce0 trap_dispatch
+00000000 default_pmm.c
+00102997 page2ppn
+001029b1 page2pa
+001029c7 page_ref
+001029d1 set_page_ref
+001029de default_init
+00102a0b default_init_memmap
+00102b5c default_alloc_pages
+00102cd9 default_free_pages
+00102f1e default_nr_free_pages
+00102f28 basic_check
+00103464 default_check
+00000000 pmm.c
+00103abc page2ppn
+00103ad6 page2pa
+00103aec pa2page
+00103b3b page2kva
+00103b8f pte2page
+00103bcd page_ref
+00103bd7 set_page_ref
+00103be4 page_ref_inc
+00103bfb page_ref_dec
+00103c12 __intr_save
+00103c3c __intr_restore
+001188e0 ts
+00117a00 gdt
+00117a30 gdt_pd
+00103c4f lgdt
+00103c91 gdt_init
+00103d80 init_pmm_manager
+00103db3 init_memmap
+00103e67 page_init
+00104258 enable_paging
+00104291 boot_map_segment
+0010439e boot_alloc_page
+0010485d check_alloc_page
+0010487b check_pgdir
+00104f16 check_boot_pgdir
+001046a2 page_remove_pte
+001052a4 perm2str
+00118948 str.1716
+001052f2 get_pgtable_items
+00000000 printfmt.c
+001071d0 error_string
+00105516 printnum
+0010561b getuint
+0010566a getint
+00105aca sprintputch
+00000000 string.c
+00000000 
+001028ef vector242
+00102346 vector119
+00100870 print_kerninfo
+00102226 vector87
+0010221d vector86
+0010295b vector251
+00105bef strcpy
+0010224a vector91
+00102040 vector33
+0010252f vector162
+00102793 vector213
+001022e3 vector108
+0010209a vector43
+00100000 kern_entry
+00100cae mon_backtrace
+00102553 vector165
+00102643 vector185
+00102322 vector115
+00102361 vector122
+00104747 page_insert
+001024e7 vector156
+00102913 vector245
+00102673 vector189
+00101f66 vector7
+0010213c vector61
+00101fef vector24
+001022fe vector111
+001026f7 vector200
+00102172 vector67
+0010240f vector138
+001021b1 vector74
+00105f05 memmove
+00102118 vector57
+00105aff snprintf
+00101a64 print_trapframe
+0010279f vector214
+001056df vprintfmt
+00102292 vector99
+00104649 get_page
+00101f05 __alltraps
+0010162e cons_getc
+00102433 vector141
+00100d72 is_kernel_panic
+001025a7 vector172
+001009ba print_stackframe
+001028e3 vector241
+00102973 vector253
+00101f42 vector3
+00101f39 vector2
+0010283b vector227
+0010276f vector210
+00102817 vector224
+00102088 vector41
+0010033c cprintf
+00101fd4 vector21
+001025e3 vector177
+0010233d vector118
+0010218d vector70
+00102184 vector69
+001028b3 vector237
+00102157 vector64
+0010200a vector27
+001023c7 vector132
+0010264f vector186
+001027c3 vector217
+00105fa8 memcpy
+00101f30 vector1
+001025ef vector178
+0010206d vector38
+001028bf vector238
+00100233 readline
+001023d3 vector133
+001021a8 vector73
+00102457 vector144
+00106b88 vpd
+0010002a kern_init
+0010297f vector254
+001022a4 vector101
+0010277b vector211
+001025bf vector174
+001028fb vector243
+00102397 vector128
+001021f0 vector81
+00103e0a free_pages
+00101f92 vector13
+00105b33 vsnprintf
+001020e2 vector51
+00101fa9 vector16
+00117a36 edata
+001015c6 cons_init
+001189bc pmm_manager
+001028d7 vector240
+001020fd vector54
+00101fc2 vector19
+00112000 __STAB_END__
+00102253 vector92
+00102907 vector244
+00103c84 load_esp0
+00102427 vector140
+001020ac vector45
+001021de vector79
+00102853 vector229
+001024ff vector158
+00101701 pic_enable
+00102076 vector39
+00102577 vector168
+00102052 vector35
+00102310 vector113
+00112001 __STABSTR_BEGIN__
+0010237c vector125
+00100cc0 __panic
+001027b7 vector216
+0010214e vector63
+00102001 vector26
+001013f3 serial_intr
+001026a3 vector193
+001026c7 vector196
+001000eb grade_backtrace0
+00102763 vector209
+00101f4b vector4
+0010258f vector170
+001023f7 vector136
+00101f7d vector10
+0010273f vector206
+0010298b vector255
+00102613 vector181
+0010212a vector59
+00100105 grade_backtrace
+00102214 vector85
+0010220b vector84
+0010262b vector183
+0010250b vector159
+00102787 vector212
+001020be vector47
+00105d68 strtol
+00102847 vector228
+00102091 vector42
+00102319 vector114
+00105bbf strnlen
+001025cb vector175
+0010244b vector143
+001023af vector130
+00106af0 default_pmm_manager
+0010291f vector246
+00101f76 vector9
+0010243f vector142
+0010229b vector100
+00102703 vector201
+001018ac idt_init
+00100906 print_debuginfo
+00102133 vector60
+00101fe6 vector23
+001028a7 vector236
+001188c0 npage
+0010286b vector231
+00102169 vector66
+0010201c vector29
+001053a8 print_pgdir
+001023eb vector135
+00100bdf kmonitor
+001021cc vector77
+00102607 vector180
+00100d7c clock_init
+00102757 vector208
+00102289 vector98
+00102280 vector97
+00103e3c nr_free_pages
+001025d7 vector176
+001026af vector194
+00102037 vector32
+001189c0 boot_cr3
+001189c8 end
+001026eb vector199
+001023bb vector131
+00102967 vector252
+00101f27 vector0
+00105d3a strfind
+001015f2 cons_putc
+0010604f etext
+00102463 vector145
+001022da vector107
+001188c4 boot_pgdir
+0010207f vector40
+0010169d intr_enable
+001022ad vector102
+0010210f vector56
+0010217b vector68
+00101f5d vector6
+001023a3 vector129
+001026d3 vector197
+001024b7 vector152
+00117600 __vectors
+0010285f vector230
+00105cb1 strncmp
+00104511 get_pte
+00102064 vector37
+00102733 vector205
+00102523 vector161
+00105c2e strncpy
+00102196 vector71
+00102517 vector160
+001027ab vector215
+001024f3 vector157
+001016a3 intr_disable
+00101c29 print_regs
+00102307 vector112
+0010009a grade_backtrace2
+0010261f vector182
+00101f8b vector12
+00105ff7 memcmp
+001022ec vector109
+00101fcb vector20
+001020f4 vector53
+00101fb9 vector18
+0010226e vector95
+0010282f vector226
+001020d0 vector49
+001020a3 vector44
+001021d5 vector78
+001025b3 vector173
+00102334 vector117
+00101a4e trap_in_kernel
+001021f9 vector82
+001027ff vector222
+00101f6f vector8
+00102493 vector149
+00100362 cputchar
+00105ec6 memset
+00102877 vector232
+001022d1 vector106
+001027e7 vector220
+00102241 vector90
+0010253b vector163
+0010288f vector234
+00102145 vector62
+00101ff8 vector25
+001026df vector198
+0010234f vector120
+001003c4 getchar
+00104703 page_remove
+001020d9 vector50
+00101fa0 vector15
+001056b1 printfmt
+001024ab vector151
+00102202 vector83
+00102238 vector89
+0010222f vector88
+00101ef2 trap
+001025fb vector179
+00102049 vector34
+00114a5a __STABSTR_END__
+001020b5 vector46
+00105c68 strcmp
+001023df vector134
+0010280b vector223
+001027cf vector218
+00100533 debuginfo_eip
+0010172f pic_init
+00102823 vector225
+0010265b vector187
+001043e2 pmm_init
+00102025 vector30
+0010238e vector127
+0011894c ticks
+00102697 vector192
+0010255f vector166
+001021c3 vector76
+001021ba vector75
+001026bb vector195
+0010249f vector150
+00102121 vector58
+00102937 vector248
+0010236a vector123
+00102277 vector96
+0010202e vector31
+0010271b vector203
+00103dd2 alloc_pages
+0010241b vector139
+001024c3 vector153
+00102547 vector164
+00102358 vector121
+00118960 switchk2u
+00101f54 vector5
+0010256b vector167
+001024db vector155
+00102943 vector249
+00106b84 vpt
+0010294f vector250
+00102373 vector124
+001022f5 vector110
+00102727 vector204
+00101f1c __trapret
+00100309 vcprintf
+00102403 vector137
+00100d2c __warn
+0010292b vector247
+00101fdd vector22
+0010270f vector202
+0010219f vector72
+00102106 vector55
+00100375 cputs
+00117000 bootstacktop
+00102385 vector126
+00102160 vector65
+00102013 vector28
+00102583 vector169
+00102883 vector233
+0010247b vector147
+00115000 bootstack
+001022bf vector104
+001189b0 free_area
+0010232b vector116
+00107368 __STAB_BEGIN__
+001020eb vector52
+00101fb2 vector17
+00102637 vector184
+00105b97 strlen
+0010274b vector207
+0010267f vector190
+001028cb vector239
+00102265 vector94
+0010225c vector93
+00102667 vector188
+00105d07 strchr
+001020c7 vector48
+001000be grade_backtrace1
+001027db vector219
+00102487 vector148
+001027f3 vector221
+001021e7 vector80
+0010259b vector171
+001024cf vector154
+0010205b vector36
+001189ac switchu2k
+0010289b vector235
+001022c8 vector105
+00100c9c mon_kerninfo
+001189c4 pages
+0010246f vector146
+0010268b vector191
+001022b6 vector103
+00100c3f mon_help
+00101f84 vector11
+00104800 tlb_invalidate
+00101f99 vector14
diff -r -u -P lab2_origin/obj/kernel.sym lab2/obj/kernel.sym
--- lab2_origin/obj/kernel.sym	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/kernel.sym	2021-08-29 21:35:38.866604847 +0800
@@ -0,0 +1,468 @@
+c0100000 .text
+c0106060 .rodata
+c0107368 .stab
+c0112001 .stabstr
+c0115000 .data
+c0117a40 .bss
+00000000 .comment
+00000000 obj/kern/init/entry.o
+c0117018 __gdtdesc
+c0100019 relocated
+c0100028 spin
+c0117000 __gdt
+00000000 init.c
+c010012a lab1_print_cur_status
+c0117a40 round.1438
+c01001f0 lab1_switch_to_user
+c01001f5 lab1_switch_to_kernel
+c01001fa lab1_switch_test
+00000000 readline.c
+c0117a60 buf
+00000000 stdio.c
+c01002e9 cputch
+00000000 kdebug.c
+c01003dd stab_binsearch
+c01009a9 read_eip
+00000000 kmonitor.c
+c0117020 commands
+c0100a73 parse
+c0100b2d runcmd
+00000000 panic.c
+c0117e60 is_panic
+00000000 clock.c
+00000000 console.c
+c0100ddf __intr_save
+c0100e09 __intr_restore
+c0100e1c delay
+c0117e80 crt_buf
+c0117e84 crt_pos
+c0117e86 addr_6845
+c0100e64 cga_init
+c0117e88 serial_exists
+c0100f4a serial_init
+c010102d lpt_putc_sub
+c01010a6 lpt_putc
+c01010e5 cga_putc
+c01012b9 serial_putc_sub
+c0101312 serial_putc
+c0117ea0 cons
+c0101351 cons_intr
+c010139c serial_proc_data
+c0117060 shiftcode
+c0117160 togglecode
+c0117260 normalmap
+c0117360 shiftmap
+c0117460 ctlmap
+c0117560 charcode
+c0101410 kbd_proc_data
+c01180a8 shift.1532
+c0101599 kbd_intr
+c01015ad kbd_init
+00000000 intr.c
+00000000 picirq.c
+c0117570 irq_mask
+c01180ac did_init
+c01016a9 pic_setmask
+00000000 trap.c
+c010186a print_ticks
+c01180c0 idt
+c0117580 idt_pd
+c0101a1d trapname
+c0106740 excnames.1482
+c01175a0 IA32flags
+c0101ce0 trap_dispatch
+00000000 default_pmm.c
+c0102997 page2ppn
+c01029b1 page2pa
+c01029c7 page_ref
+c01029d1 set_page_ref
+c01029de default_init
+c0102a0b default_init_memmap
+c0102b5c default_alloc_pages
+c0102cd9 default_free_pages
+c0102f1e default_nr_free_pages
+c0102f28 basic_check
+c0103464 default_check
+00000000 pmm.c
+c0103abc page2ppn
+c0103ad6 page2pa
+c0103aec pa2page
+c0103b3b page2kva
+c0103b8f pte2page
+c0103bcd page_ref
+c0103bd7 set_page_ref
+c0103be4 page_ref_inc
+c0103bfb page_ref_dec
+c0103c12 __intr_save
+c0103c3c __intr_restore
+c01188e0 ts
+c0117a00 gdt
+c0117a30 gdt_pd
+c0103c4f lgdt
+c0103c91 gdt_init
+c0103d80 init_pmm_manager
+c0103db3 init_memmap
+c0103e67 page_init
+c0104258 enable_paging
+c0104291 boot_map_segment
+c010439e boot_alloc_page
+c010485d check_alloc_page
+c010487b check_pgdir
+c0104f16 check_boot_pgdir
+c01046a2 page_remove_pte
+c01052a4 perm2str
+c0118948 str.1716
+c01052f2 get_pgtable_items
+00000000 printfmt.c
+c01071d0 error_string
+c0105516 printnum
+c010561b getuint
+c010566a getint
+c0105aca sprintputch
+00000000 string.c
+00000000 
+c01028ef vector242
+c0102346 vector119
+c0100870 print_kerninfo
+c0102226 vector87
+c010221d vector86
+c010295b vector251
+c0105bef strcpy
+c010224a vector91
+c0102040 vector33
+c010252f vector162
+c0102793 vector213
+c01022e3 vector108
+c010209a vector43
+c0100000 kern_entry
+c0100cae mon_backtrace
+c0102553 vector165
+c0102643 vector185
+c0102322 vector115
+c0102361 vector122
+c0104747 page_insert
+c01024e7 vector156
+c0102913 vector245
+c0102673 vector189
+c0101f66 vector7
+c010213c vector61
+c0101fef vector24
+c01022fe vector111
+c01026f7 vector200
+c0102172 vector67
+c010240f vector138
+c01021b1 vector74
+c0105f05 memmove
+c0102118 vector57
+c0105aff snprintf
+c0101a64 print_trapframe
+c010279f vector214
+c01056df vprintfmt
+c0102292 vector99
+c0104649 get_page
+c0101f05 __alltraps
+c010162e cons_getc
+c0102433 vector141
+c0100d72 is_kernel_panic
+c01025a7 vector172
+c01009ba print_stackframe
+c01028e3 vector241
+c0102973 vector253
+c0101f42 vector3
+c0101f39 vector2
+c010283b vector227
+c010276f vector210
+c0102817 vector224
+c0102088 vector41
+c010033c cprintf
+c0101fd4 vector21
+c01025e3 vector177
+c010233d vector118
+c010218d vector70
+c0102184 vector69
+c01028b3 vector237
+c0102157 vector64
+c010200a vector27
+c01023c7 vector132
+c010264f vector186
+c01027c3 vector217
+c0105fa8 memcpy
+c0101f30 vector1
+c01025ef vector178
+c010206d vector38
+c01028bf vector238
+c0100233 readline
+c01023d3 vector133
+c01021a8 vector73
+c0102457 vector144
+c0106b88 vpd
+c010002a kern_init
+c010297f vector254
+c01022a4 vector101
+c010277b vector211
+c01025bf vector174
+c01028fb vector243
+c0102397 vector128
+c01021f0 vector81
+c0103e0a free_pages
+c0101f92 vector13
+c0105b33 vsnprintf
+c01020e2 vector51
+c0101fa9 vector16
+c0117a36 edata
+c01015c6 cons_init
+c01189bc pmm_manager
+c01028d7 vector240
+c01020fd vector54
+c0101fc2 vector19
+c0112000 __STAB_END__
+c0102253 vector92
+c0102907 vector244
+c0103c84 load_esp0
+c0102427 vector140
+c01020ac vector45
+c01021de vector79
+c0102853 vector229
+c01024ff vector158
+c0101701 pic_enable
+c0102076 vector39
+c0102577 vector168
+c0102052 vector35
+c0102310 vector113
+c0112001 __STABSTR_BEGIN__
+c010237c vector125
+c0100cc0 __panic
+c01027b7 vector216
+c010214e vector63
+c0102001 vector26
+c01013f3 serial_intr
+c01026a3 vector193
+c01026c7 vector196
+c01000eb grade_backtrace0
+c0102763 vector209
+c0101f4b vector4
+c010258f vector170
+c01023f7 vector136
+c0101f7d vector10
+c010273f vector206
+c010298b vector255
+c0102613 vector181
+c010212a vector59
+c0100105 grade_backtrace
+c0102214 vector85
+c010220b vector84
+c010262b vector183
+c010250b vector159
+c0102787 vector212
+c01020be vector47
+c0105d68 strtol
+c0102847 vector228
+c0102091 vector42
+c0102319 vector114
+c0105bbf strnlen
+c01025cb vector175
+c010244b vector143
+c01023af vector130
+c0106af0 default_pmm_manager
+c010291f vector246
+c0101f76 vector9
+c010243f vector142
+c010229b vector100
+c0102703 vector201
+c01018ac idt_init
+c0100906 print_debuginfo
+c0102133 vector60
+c0101fe6 vector23
+c01028a7 vector236
+c01188c0 npage
+c010286b vector231
+c0102169 vector66
+c010201c vector29
+c01053a8 print_pgdir
+c01023eb vector135
+c0100bdf kmonitor
+c01021cc vector77
+c0102607 vector180
+c0100d7c clock_init
+c0102757 vector208
+c0102289 vector98
+c0102280 vector97
+c0103e3c nr_free_pages
+c01025d7 vector176
+c01026af vector194
+c0102037 vector32
+c01189c0 boot_cr3
+c01189c8 end
+c01026eb vector199
+c01023bb vector131
+c0102967 vector252
+c0101f27 vector0
+c0105d3a strfind
+c01015f2 cons_putc
+c010604f etext
+c0102463 vector145
+c01022da vector107
+c01188c4 boot_pgdir
+c010207f vector40
+c010169d intr_enable
+c01022ad vector102
+c010210f vector56
+c010217b vector68
+c0101f5d vector6
+c01023a3 vector129
+c01026d3 vector197
+c01024b7 vector152
+c0117600 __vectors
+c010285f vector230
+c0105cb1 strncmp
+c0104511 get_pte
+c0102064 vector37
+c0102733 vector205
+c0102523 vector161
+c0105c2e strncpy
+c0102196 vector71
+c0102517 vector160
+c01027ab vector215
+c01024f3 vector157
+c01016a3 intr_disable
+c0101c29 print_regs
+c0102307 vector112
+c010009a grade_backtrace2
+c010261f vector182
+c0101f8b vector12
+c0105ff7 memcmp
+c01022ec vector109
+c0101fcb vector20
+c01020f4 vector53
+c0101fb9 vector18
+c010226e vector95
+c010282f vector226
+c01020d0 vector49
+c01020a3 vector44
+c01021d5 vector78
+c01025b3 vector173
+c0102334 vector117
+c0101a4e trap_in_kernel
+c01021f9 vector82
+c01027ff vector222
+c0101f6f vector8
+c0102493 vector149
+c0100362 cputchar
+c0105ec6 memset
+c0102877 vector232
+c01022d1 vector106
+c01027e7 vector220
+c0102241 vector90
+c010253b vector163
+c010288f vector234
+c0102145 vector62
+c0101ff8 vector25
+c01026df vector198
+c010234f vector120
+c01003c4 getchar
+c0104703 page_remove
+c01020d9 vector50
+c0101fa0 vector15
+c01056b1 printfmt
+c01024ab vector151
+c0102202 vector83
+c0102238 vector89
+c010222f vector88
+c0101ef2 trap
+c01025fb vector179
+c0102049 vector34
+c0114a5a __STABSTR_END__
+c01020b5 vector46
+c0105c68 strcmp
+c01023df vector134
+c010280b vector223
+c01027cf vector218
+c0100533 debuginfo_eip
+c010172f pic_init
+c0102823 vector225
+c010265b vector187
+c01043e2 pmm_init
+c0102025 vector30
+c010238e vector127
+c011894c ticks
+c0102697 vector192
+c010255f vector166
+c01021c3 vector76
+c01021ba vector75
+c01026bb vector195
+c010249f vector150
+c0102121 vector58
+c0102937 vector248
+c010236a vector123
+c0102277 vector96
+c010202e vector31
+c010271b vector203
+c0103dd2 alloc_pages
+c010241b vector139
+c01024c3 vector153
+c0102547 vector164
+c0102358 vector121
+c0118960 switchk2u
+c0101f54 vector5
+c010256b vector167
+c01024db vector155
+c0102943 vector249
+c0106b84 vpt
+c010294f vector250
+c0102373 vector124
+c01022f5 vector110
+c0102727 vector204
+c0101f1c __trapret
+c0100309 vcprintf
+c0102403 vector137
+c0100d2c __warn
+c010292b vector247
+c0101fdd vector22
+c010270f vector202
+c010219f vector72
+c0102106 vector55
+c0100375 cputs
+c0117000 bootstacktop
+c0102385 vector126
+c0102160 vector65
+c0102013 vector28
+c0102583 vector169
+c0102883 vector233
+c010247b vector147
+c0115000 bootstack
+c01022bf vector104
+c01189b0 free_area
+c010232b vector116
+c0107368 __STAB_BEGIN__
+c01020eb vector52
+c0101fb2 vector17
+c0102637 vector184
+c0105b97 strlen
+c010274b vector207
+c010267f vector190
+c01028cb vector239
+c0102265 vector94
+c010225c vector93
+c0102667 vector188
+c0105d07 strchr
+c01020c7 vector48
+c01000be grade_backtrace1
+c01027db vector219
+c0102487 vector148
+c01027f3 vector221
+c01021e7 vector80
+c010259b vector171
+c01024cf vector154
+c010205b vector36
+c01189ac switchu2k
+c010289b vector235
+c01022c8 vector105
+c0100c9c mon_kerninfo
+c01189c4 pages
+c010246f vector146
+c010268b vector191
+c01022b6 vector103
+c0100c3f mon_help
+c0101f84 vector11
+c0104800 tlb_invalidate
+c0101f99 vector14
diff -r -u -P lab2_origin/obj/libs/printfmt.d lab2/obj/libs/printfmt.d
--- lab2_origin/obj/libs/printfmt.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/libs/printfmt.d	2021-08-29 21:35:38.038604852 +0800
@@ -0,0 +1,2 @@
+obj/libs/printfmt.o obj/libs/printfmt.d: libs/printfmt.c libs/defs.h \
+ libs/x86.h libs/error.h libs/stdio.h libs/stdarg.h libs/string.h
Binary files lab2_origin/obj/libs/printfmt.o and lab2/obj/libs/printfmt.o differ
diff -r -u -P lab2_origin/obj/libs/string.d lab2/obj/libs/string.d
--- lab2_origin/obj/libs/string.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/libs/string.d	2021-08-29 21:35:38.022604852 +0800
@@ -0,0 +1,2 @@
+obj/libs/string.o obj/libs/string.d: libs/string.c libs/string.h \
+ libs/defs.h libs/x86.h
Binary files lab2_origin/obj/libs/string.o and lab2/obj/libs/string.o differ
diff -r -u -P lab2_origin/obj/sign/tools/sign.d lab2/obj/sign/tools/sign.d
--- lab2_origin/obj/sign/tools/sign.d	1970-01-01 08:00:00.000000000 +0800
+++ lab2/obj/sign/tools/sign.d	2021-08-29 21:35:38.054604852 +0800
@@ -0,0 +1 @@
+obj/sign/tools/sign.o obj/sign/tools/sign.d: tools/sign.c
Binary files lab2_origin/obj/sign/tools/sign.o and lab2/obj/sign/tools/sign.o differ
diff -r -u -P lab2_origin/.qemu.out lab2/.qemu.out
--- lab2_origin/.qemu.out	1970-01-01 08:00:00.000000000 +0800
+++ lab2/.qemu.out	2021-08-29 21:35:41.326604832 +0800
@@ -0,0 +1,74 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc010002a (phys)
+  etext  0xc010604f (phys)
+  edata  0xc0117a36 (phys)
+  end    0xc01189c8 (phys)
+Kernel executable memory footprint: 99KB
+ebp:0xc0116f38 eip:0xc01009d0 args:0x00010094 0x00000000 0xc0116f68 0xc01000bc 
+    kern/debug/kdebug.c:306: print_stackframe+21
+ebp:0xc0116f48 eip:0xc0100cb9 args:0x00000000 0x00000000 0x00000000 0xc0116fb8 
+    kern/debug/kmonitor.c:129: mon_backtrace+10
+ebp:0xc0116f68 eip:0xc01000bc args:0x00000000 0xc0116f90 0xffff0000 0xc0116f94 
+    kern/init/init.c:49: grade_backtrace2+33
+ebp:0xc0116f88 eip:0xc01000e5 args:0x00000000 0xffff0000 0xc0116fb4 0x00000029 
+    kern/init/init.c:54: grade_backtrace1+38
+ebp:0xc0116fa8 eip:0xc0100103 args:0x00000000 0xc010002a 0xffff0000 0x0000001d 
+    kern/init/init.c:59: grade_backtrace0+23
+ebp:0xc0116fc8 eip:0xc0100128 args:0xc010607c 0xc0106060 0x00000f92 0x00000000 
+    kern/init/init.c:64: grade_backtrace+34
+ebp:0xc0116ff8 eip:0xc010007f args:0x00000000 0x00000000 0x0000ffff 0x40cf9a00 
+    kern/init/init.c:29: kern_init+84
+ebp:0x00000000 eip:0xc0100028 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    kern/init/entry.S:27: <unknown>+0
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+ebp:0x00000000 eip:0x00000000 args:0x00000000 0x00000000 0x00000000 0x00000000 
+    <unknow>: -- 0xffffffff --
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07efe000, [00100000, 07ffdfff], type = 1.
+  memory: 00002000, [07ffe000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+++ setup timer interrupts
+100 ticks
+End of Test.
+kernel panic at kern/trap/trap.c:19:
+    EOT: kernel seems ok.
+Welcome to the kernel debug monitor!!
+Type 'help' for a list of commands.
+K> 
\ No newline at end of file
diff -r -u -P lab2_origin/tools/boot.ld lab2/tools/boot.ld
--- lab2_origin/tools/boot.ld	1970-01-01 08:00:00.000000000 +0800
+++ lab2/tools/boot.ld	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,15 @@
+OUTPUT_FORMAT("elf32-i386")
+OUTPUT_ARCH(i386)
+
+SECTIONS {
+    . = 0x7C00;
+
+    .startup : {
+        *bootasm.o(.text)
+    }
+
+    .text : { *(.text) }
+    .data : { *(.data .rodata) }
+    
+    /DISCARD/ : { *(.eh_*) }
+}
diff -r -u -P lab2_origin/tools/function.mk lab2/tools/function.mk
--- lab2_origin/tools/function.mk	1970-01-01 08:00:00.000000000 +0800
+++ lab2/tools/function.mk	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,95 @@
+OBJPREFIX	:= __objs_
+
+.SECONDEXPANSION:
+# -------------------- function begin --------------------
+
+# list all files in some directories: (#directories, #types)
+listf = $(filter $(if $(2),$(addprefix %.,$(2)),%),\
+		  $(wildcard $(addsuffix $(SLASH)*,$(1))))
+
+# get .o obj files: (#files[, packet])
+toobj = $(addprefix $(OBJDIR)$(SLASH)$(if $(2),$(2)$(SLASH)),\
+		$(addsuffix .o,$(basename $(1))))
+
+# get .d dependency files: (#files[, packet])
+todep = $(patsubst %.o,%.d,$(call toobj,$(1),$(2)))
+
+totarget = $(addprefix $(BINDIR)$(SLASH),$(1))
+
+# change $(name) to $(OBJPREFIX)$(name): (#names)
+packetname = $(if $(1),$(addprefix $(OBJPREFIX),$(1)),$(OBJPREFIX))
+
+# cc compile template, generate rule for dep, obj: (file, cc[, flags, dir])
+define cc_template
+$$(call todep,$(1),$(4)): $(1) | $$$$(dir $$$$@)
+	@$(2) -I$$(dir $(1)) $(3) -MM $$< -MT "$$(patsubst %.d,%.o,$$@) $$@"> $$@
+$$(call toobj,$(1),$(4)): $(1) | $$$$(dir $$$$@)
+	@echo + cc $$<
+	$(V)$(2) -I$$(dir $(1)) $(3) -c $$< -o $$@
+ALLOBJS += $$(call toobj,$(1),$(4))
+endef
+
+# compile file: (#files, cc[, flags, dir])
+define do_cc_compile
+$$(foreach f,$(1),$$(eval $$(call cc_template,$$(f),$(2),$(3),$(4))))
+endef
+
+# add files to packet: (#files, cc[, flags, packet, dir])
+define do_add_files_to_packet
+__temp_packet__ := $(call packetname,$(4))
+ifeq ($$(origin $$(__temp_packet__)),undefined)
+$$(__temp_packet__) :=
+endif
+__temp_objs__ := $(call toobj,$(1),$(5))
+$$(foreach f,$(1),$$(eval $$(call cc_template,$$(f),$(2),$(3),$(5))))
+$$(__temp_packet__) += $$(__temp_objs__)
+endef
+
+# add objs to packet: (#objs, packet)
+define do_add_objs_to_packet
+__temp_packet__ := $(call packetname,$(2))
+ifeq ($$(origin $$(__temp_packet__)),undefined)
+$$(__temp_packet__) :=
+endif
+$$(__temp_packet__) += $(1)
+endef
+
+# add packets and objs to target (target, #packes, #objs[, cc, flags])
+define do_create_target
+__temp_target__ = $(call totarget,$(1))
+__temp_objs__ = $$(foreach p,$(call packetname,$(2)),$$($$(p))) $(3)
+TARGETS += $$(__temp_target__)
+ifneq ($(4),)
+$$(__temp_target__): $$(__temp_objs__) | $$$$(dir $$$$@)
+	$(V)$(4) $(5) $$^ -o $$@
+else
+$$(__temp_target__): $$(__temp_objs__) | $$$$(dir $$$$@)
+endif
+endef
+
+# finish all
+define do_finish_all
+ALLDEPS = $$(ALLOBJS:.o=.d)
+$$(sort $$(dir $$(ALLOBJS)) $(BINDIR)$(SLASH) $(OBJDIR)$(SLASH)):
+	@$(MKDIR) $$@
+endef
+
+# --------------------  function end  --------------------
+# compile file: (#files, cc[, flags, dir])
+cc_compile = $(eval $(call do_cc_compile,$(1),$(2),$(3),$(4)))
+
+# add files to packet: (#files, cc[, flags, packet, dir])
+add_files = $(eval $(call do_add_files_to_packet,$(1),$(2),$(3),$(4),$(5)))
+
+# add objs to packet: (#objs, packet)
+add_objs = $(eval $(call do_add_objs_to_packet,$(1),$(2)))
+
+# add packets and objs to target (target, #packes, #objs, cc, [, flags])
+create_target = $(eval $(call do_create_target,$(1),$(2),$(3),$(4),$(5)))
+
+read_packet = $(foreach p,$(call packetname,$(1)),$($(p)))
+
+add_dependency = $(eval $(1): $(2))
+
+finish_all = $(eval $(call do_finish_all))
+
diff -r -u -P lab2_origin/tools/gdbinit lab2/tools/gdbinit
--- lab2_origin/tools/gdbinit	1970-01-01 08:00:00.000000000 +0800
+++ lab2/tools/gdbinit	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,3 @@
+file bin/kernel
+target remote :1234
+break kern_init
diff -r -u -P lab2_origin/tools/grade.sh lab2/tools/grade.sh
--- lab2_origin/tools/grade.sh	1970-01-01 08:00:00.000000000 +0800
+++ lab2/tools/grade.sh	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,340 @@
+#!/bin/sh
+
+verbose=false
+if [ "x$1" = "x-v" ]; then
+    verbose=true
+    out=/dev/stdout
+    err=/dev/stderr
+else
+    out=/dev/null
+    err=/dev/null
+fi
+
+## make & makeopts
+if gmake --version > /dev/null 2>&1; then
+    make=gmake;
+else
+    make=make;
+fi
+
+makeopts="--quiet --no-print-directory -j"
+
+make_print() {
+    echo `$make $makeopts print-$1`
+}
+
+## command tools
+awk='awk'
+bc='bc'
+date='date'
+grep='grep'
+rm='rm -f'
+sed='sed'
+
+## symbol table
+sym_table='obj/kernel.sym'
+
+## gdb & gdbopts
+gdb="$(make_print GDB)"
+gdbport='1234'
+
+gdb_in="$(make_print GRADE_GDB_IN)"
+
+## qemu & qemuopts
+qemu="$(make_print qemu)"
+
+qemu_out="$(make_print GRADE_QEMU_OUT)"
+
+if $qemu -nographic -help | grep -q '^-gdb'; then
+    qemugdb="-gdb tcp::$gdbport"
+else
+    qemugdb="-s -p $gdbport"
+fi
+
+## default variables
+default_timeout=30
+default_pts=5
+
+pts=5
+part=0
+part_pos=0
+total=0
+total_pos=0
+
+## default functions
+update_score() {
+    total=`expr $total + $part`
+    total_pos=`expr $total_pos + $part_pos`
+    part=0
+    part_pos=0
+}
+
+get_time() {
+    echo `$date +%s.%N 2> /dev/null`
+}
+
+show_part() {
+    echo "Part $1 Score: $part/$part_pos"
+    echo
+    update_score
+}
+
+show_final() {
+    update_score
+    echo "Total Score: $total/$total_pos"
+    if [ $total -lt $total_pos ]; then
+        exit 1
+    fi
+}
+
+show_time() {
+    t1=$(get_time)
+    time=`echo "scale=1; ($t1-$t0)/1" | $sed 's/.N/.0/g' | $bc 2> /dev/null`
+    echo "(${time}s)"
+}
+
+show_build_tag() {
+    echo "$1:" | $awk '{printf "%-24s ", $0}'
+}
+
+show_check_tag() {
+    echo "$1:" | $awk '{printf "  -%-40s  ", $0}'
+}
+
+show_msg() {
+    echo $1
+    shift
+    if [ $# -gt 0 ]; then
+        echo "$@" | awk '{printf "   %s\n", $0}'
+        echo
+    fi
+}
+
+pass() {
+    show_msg OK "$@"
+    part=`expr $part + $pts`
+    part_pos=`expr $part_pos + $pts`
+}
+
+fail() {
+    show_msg WRONG "$@"
+    part_pos=`expr $part_pos + $pts`
+}
+
+run_qemu() {
+    # Run qemu with serial output redirected to $qemu_out. If $brkfun is non-empty,
+    # wait until $brkfun is reached or $timeout expires, then kill QEMU
+    qemuextra=
+    if [ "$brkfun" ]; then
+        qemuextra="-S $qemugdb"
+    fi
+
+    if [ -z "$timeout" ] || [ $timeout -le 0 ]; then
+        timeout=$default_timeout;
+    fi
+
+    t0=$(get_time)
+    (
+        ulimit -t $timeout
+        exec $qemu -nographic $qemuopts -serial file:$qemu_out -monitor null -no-reboot $qemuextra
+    ) > $out 2> $err &
+    pid=$!
+
+    # wait for QEMU to start
+    sleep 1
+
+    if [ -n "$brkfun" ]; then
+        # find the address of the kernel $brkfun function
+        brkaddr=`$grep " $brkfun\$" $sym_table | $sed -e's/ .*$//g'`
+        (
+            echo "target remote localhost:$gdbport"
+            echo "break *0x$brkaddr"
+            echo "continue"
+        ) > $gdb_in
+
+        $gdb -batch -nx -x $gdb_in > /dev/null 2>&1
+
+        # make sure that QEMU is dead
+        # on OS X, exiting gdb doesn't always exit qemu
+        kill $pid > /dev/null 2>&1
+    fi
+}
+
+build_run() {
+    # usage: build_run <tag> <args>
+    show_build_tag "$1"
+    shift
+
+    if $verbose; then
+        echo "$make $@ ..."
+    fi
+    $make $makeopts $@ 'DEFS+=-DDEBUG_GRADE' > $out 2> $err
+
+    if [ $? -ne 0 ]; then
+        echo $make $@ failed
+        exit 1
+    fi
+
+    # now run qemu and save the output
+    run_qemu
+
+    show_time
+}
+
+check_result() {
+    # usage: check_result <tag> <check> <check args...>
+    show_check_tag "$1"
+    shift
+
+    # give qemu some time to run (for asynchronous mode)
+    if [ ! -s $qemu_out ]; then
+        sleep 4
+    fi
+
+    if [ ! -s $qemu_out ]; then
+        fail > /dev/null
+        echo 'no $qemu_out'
+    else
+        check=$1
+        shift
+        $check "$@"
+    fi
+}
+
+check_regexps() {
+    okay=yes
+    not=0
+    reg=0
+    error=
+    for i do
+        if [ "x$i" = "x!" ]; then
+            not=1
+        elif [ "x$i" = "x-" ]; then
+            reg=1
+        else
+            if [ $reg -ne 0 ]; then
+                $grep '-E' "^$i\$" $qemu_out > /dev/null
+            else
+                $grep '-F' "$i" $qemu_out > /dev/null
+            fi
+            found=$(($? == 0))
+            if [ $found -eq $not ]; then
+                if [ $found -eq 0 ]; then
+                    msg="!! error: missing '$i'"
+                else
+                    msg="!! error: got unexpected line '$i'"
+                fi
+                okay=no
+                if [ -z "$error" ]; then
+                    error="$msg"
+                else
+                    error="$error\n$msg"
+                fi
+            fi
+            not=0
+            reg=0
+        fi
+    done
+    if [ "$okay" = "yes" ]; then
+        pass
+    else
+        fail "$error"
+        if $verbose; then
+            exit 1
+        fi
+    fi
+}
+
+run_test() {
+    # usage: run_test [-tag <tag>] [-Ddef...] [-check <check>] checkargs ...
+    tag=
+    check=check_regexps
+    while true; do
+        select=
+        case $1 in
+            -tag)
+                select=`expr substr $1 2 ${#1}`
+                eval $select='$2'
+                ;;
+        esac
+        if [ -z "$select" ]; then
+            break
+        fi
+        shift
+        shift
+    done
+    defs=
+    while expr "x$1" : "x-D.*" > /dev/null; do
+        defs="DEFS+='$1' $defs"
+        shift
+    done
+    if [ "x$1" = "x-check" ]; then
+        check=$2
+        shift
+        shift
+    fi
+
+    $make $makeopts touch > /dev/null 2>&1
+    build_run "$tag" "$defs"
+
+    check_result 'check result' "$check" "$@"
+}
+
+quick_run() {
+    # usage: quick_run <tag> [-Ddef...]
+    tag="$1"
+    shift
+    defs=
+    while expr "x$1" : "x-D.*" > /dev/null; do
+        defs="DEFS+='$1' $defs"
+        shift
+    done
+
+    $make $makeopts touch > /dev/null 2>&1
+    build_run "$tag" "$defs"
+}
+
+quick_check() {
+    # usage: quick_check <tag> checkargs ...
+    tag="$1"
+    shift
+    check_result "$tag" check_regexps "$@"
+}
+
+## kernel image
+osimg=$(make_print ucoreimg)
+
+## set default qemu-options
+qemuopts="-hda $osimg"
+
+## set break-function, default is readline
+brkfun=readline
+
+## check now!!
+
+quick_run 'Check PMM'
+
+pts=20
+quick_check 'check pmm'                                         \
+    'memory management: default_pmm_manager'                     \
+    'check_alloc_page() succeeded!'                             \
+    'check_pgdir() succeeded!'                                  \
+    'check_boot_pgdir() succeeded!'
+
+pts=20
+quick_check 'check page table'                                  \
+    'PDE(0e0) c0000000-f8000000 38000000 urw'                   \
+    '  |-- PTE(38000) c0000000-f8000000 38000000 -rw'           \
+    'PDE(001) fac00000-fb000000 00400000 -rw'                   \
+    '  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw'           \
+    '  |-- PTE(00001) fafeb000-fafec000 00001000 -rw'
+
+pts=10
+quick_check 'check ticks'                                       \
+    '++ setup timer interrupts'                                 \
+    '100 ticks'                                                 \
+    'End of Test.'
+
+## print final-score
+show_final
+
diff -r -u -P lab2_origin/tools/kernel.ld lab2/tools/kernel.ld
--- lab2_origin/tools/kernel.ld	1970-01-01 08:00:00.000000000 +0800
+++ lab2/tools/kernel.ld	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,58 @@
+/* Simple linker script for the ucore kernel.
+   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
+
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(kern_entry)
+
+SECTIONS {
+    /* Load the kernel at this address: "." means the current address */
+    . = 0xC0100000;
+
+    .text : {
+        *(.text .stub .text.* .gnu.linkonce.t.*)
+    }
+
+    PROVIDE(etext = .); /* Define the 'etext' symbol to this value */
+
+    .rodata : {
+        *(.rodata .rodata.* .gnu.linkonce.r.*)
+    }
+
+    /* Include debugging information in kernel memory */
+    .stab : {
+        PROVIDE(__STAB_BEGIN__ = .);
+        *(.stab);
+        PROVIDE(__STAB_END__ = .);
+        BYTE(0)     /* Force the linker to allocate space
+                   for this section */
+    }
+
+    .stabstr : {
+        PROVIDE(__STABSTR_BEGIN__ = .);
+        *(.stabstr);
+        PROVIDE(__STABSTR_END__ = .);
+        BYTE(0)     /* Force the linker to allocate space
+                   for this section */
+    }
+
+    /* Adjust the address for the data segment to the next page */
+    . = ALIGN(0x1000);
+
+    /* The data segment */
+    .data : {
+        *(.data)
+    }
+
+    PROVIDE(edata = .);
+
+    .bss : {
+        *(.bss)
+    }
+
+    PROVIDE(end = .);
+
+    /DISCARD/ : {
+        *(.eh_frame .note.GNU-stack)
+    }
+}
diff -r -u -P lab2_origin/tools/kernel_nopage.ld lab2/tools/kernel_nopage.ld
--- lab2_origin/tools/kernel_nopage.ld	1970-01-01 08:00:00.000000000 +0800
+++ lab2/tools/kernel_nopage.ld	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,59 @@
+/* Simple linker script for the ucore kernel.
+   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
+
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(kern_entry)
+
+SECTIONS {
+    /* Load the kernel at this address: "." means the current address */
+    /* the phy addr of ucore (before ucore enable paging mechanism*/
+    . = 0x0100000;
+
+    .text : {
+        *(.text .stub .text.* .gnu.linkonce.t.*)
+    }
+
+    PROVIDE(etext = .); /* Define the 'etext' symbol to this value */
+
+    .rodata : {
+        *(.rodata .rodata.* .gnu.linkonce.r.*)
+    }
+
+    /* Include debugging information in kernel memory */
+    .stab : {
+        PROVIDE(__STAB_BEGIN__ = .);
+        *(.stab);
+        PROVIDE(__STAB_END__ = .);
+        BYTE(0)     /* Force the linker to allocate space
+                   for this section */
+    }
+
+    .stabstr : {
+        PROVIDE(__STABSTR_BEGIN__ = .);
+        *(.stabstr);
+        PROVIDE(__STABSTR_END__ = .);
+        BYTE(0)     /* Force the linker to allocate space
+                   for this section */
+    }
+
+    /* Adjust the address for the data segment to the next page */
+    . = ALIGN(0x1000);
+
+    /* The data segment */
+    .data : {
+        *(.data)
+    }
+
+    PROVIDE(edata = .);
+
+    .bss : {
+        *(.bss)
+    }
+
+    PROVIDE(end = .);
+
+    /DISCARD/ : {
+        *(.eh_frame .note.GNU-stack)
+    }
+}
diff -r -u -P lab2_origin/tools/sign.c lab2/tools/sign.c
--- lab2_origin/tools/sign.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/tools/sign.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,43 @@
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+
+int
+main(int argc, char *argv[]) {
+    struct stat st;
+    if (argc != 3) {
+        fprintf(stderr, "Usage: <input filename> <output filename>\n");
+        return -1;
+    }
+    if (stat(argv[1], &st) != 0) {
+        fprintf(stderr, "Error opening file '%s': %s\n", argv[1], strerror(errno));
+        return -1;
+    }
+    printf("'%s' size: %lld bytes\n", argv[1], (long long)st.st_size);
+    if (st.st_size > 510) {
+        fprintf(stderr, "%lld >> 510!!\n", (long long)st.st_size);
+        return -1;
+    }
+    char buf[512];
+    memset(buf, 0, sizeof(buf));
+    FILE *ifp = fopen(argv[1], "rb");
+    int size = fread(buf, 1, st.st_size, ifp);
+    if (size != st.st_size) {
+        fprintf(stderr, "read '%s' error, size is %d.\n", argv[1], size);
+        return -1;
+    }
+    fclose(ifp);
+    buf[510] = 0x55;
+    buf[511] = 0xAA;
+    FILE *ofp = fopen(argv[2], "wb+");
+    size = fwrite(buf, 1, 512, ofp);
+    if (size != 512) {
+        fprintf(stderr, "write '%s' error, size is %d.\n", argv[2], size);
+        return -1;
+    }
+    fclose(ofp);
+    printf("build 512 bytes boot sector: '%s' success!\n", argv[2]);
+    return 0;
+}
+
diff -r -u -P lab2_origin/tools/vector.c lab2/tools/vector.c
--- lab2_origin/tools/vector.c	1970-01-01 08:00:00.000000000 +0800
+++ lab2/tools/vector.c	2015-03-02 00:59:39.000000000 +0800
@@ -0,0 +1,29 @@
+#include <stdio.h>
+
+int
+main(void) {
+    printf("# handler\n");
+    printf(".text\n");
+    printf(".globl __alltraps\n");
+
+    int i;
+    for (i = 0; i < 256; i ++) {
+        printf(".globl vector%d\n", i);
+        printf("vector%d:\n", i);
+        if ((i < 8 || i > 14) && i != 17) {
+            printf("  pushl $0\n");
+        }
+        printf("  pushl $%d\n", i);
+        printf("  jmp __alltraps\n");
+    }
+    printf("\n");
+    printf("# vector table\n");
+    printf(".data\n");
+    printf(".globl __vectors\n");
+    printf("__vectors:\n");
+    for (i = 0; i < 256; i ++) {
+        printf("  .long vector%d\n", i);
+    }
+    return 0;
+}
+
